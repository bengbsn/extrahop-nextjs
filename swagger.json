{
    "swagger": "2.0",
    "info": {
        "title": "ExtraHop REST API Explorer",
        "description": "The REST API Explorer is a web-based tool that enables you to view and manipulate operation information and examples for the ExtraHop REST API. You can test API operations such as methods, schemas, parameters, and response messages directly through the API Explorer. In addition, you can copy and paste sample code for cURL, Python 2.7, and Ruby from the API Explorer into your development environment.\n\n",
        "version": "1"
    },
    "schemes": [
        "https"
    ],
    "basePath": "/api/v1",
    "x-helpURL": "https://docs.extrahop.com/9.8/rest-api-guide",
    "x-docsBaseURL": "https://docs.extrahop.com/9.8",
    "produces": [
        "application/json"
    ],
    "paths": {
        "/activitymaps": {
            "get": {
                "summary": "Retrieve all saved activity maps.",
                "operationId": "getAllAssignedActivitymaps",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ActivityMap objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/ActivityMap"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new activity map.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | The description for the activity map.\nmode | string | no | The layout of the activity map. Supported values are \"2dforce\" and \"3dforce\".\nname | string | yes | The friendly name for the activity map.\nshort_code | string | no | The unique short code that is global to all activity maps.\nshow_alert_status | boolean | no | Indicates whether to show the alert status for devices on the activity map. If enabled, the color of each device on the map represents the most severe alert level associated with the device.\nwalks | array[walk] | yes | The list of one or more walk objects. A walk is the path of traffic composed of one or more steps. Each walk begins with one or more origin devices and expands to connections to peer devices that are based on protocol activity. Each expansion from the origin is a step. The contents of the object are defined in the \"walk\" section below.\nweighting | string | no | The metric value that determines how activity is weighted between devices. Supported element values are \"bytes\", \"connections\", and \"turns\".\n walk\n\nname | type | required | description\n-----|------|----------|------------\norigins | array[source_object] | yes | The list of one or more origin devices of the first step within the walk. Object contents are defined in the \"source_object\" section below.\nsteps | array[step] | yes | The list of one or more steps within the walk. Each step is defined by the protocol activity between devices of the previous step to a new set of peer devices. Object contents are defined in the \"step\" section below.\n step\n\nname | type | required | description\n-----|------|----------|------------\npeer_in | array[source_object] | no | The list of one or more peer device objects to include in the activity map. Only relationships to peers of the specified source object are included. Object contents are defined in the \"source_object\" section below.\npeer_not_in | array[source_object] | no | The list of one or more peer device objects to exclude from the activity map. Relationships to peers of the specified source object are excluded. Object contents are defined in the \"source_object\" section below.\nrelationships | array[relationship] | no | The list of one or more filters that define the relationship between two devices. The filters specify which roles and protocols to search for when locating peer devices in the step. Relationships are represented as an edge in the activity map. Object contents are defined in the \"relationship\" section below. If no value is specified, the operation will locate all peers.\n source_object\n\nname | type | required | description\n-----|------|----------|------------\nobject_id | integer | yes | The unique identifier for the source object.\nobject_type | string | yes | The metric source type. \u003cbr\u003e**Supported values:** \"device\", \"device_group\"\n\n relationship\n\nname | type | required | description\n-----|------|----------|------------\nprotocol | string | no | The metric protocol associated with the relationship, such as \"HTTP\" or \"DNS\". The operation only locates connections between devices over the specified protocol.\nrole | string | no | The device role associated with the metric protocol of the relationship. The operation only locates connections between devices over the associated protocol in the specified role. Supported role values are \"client\", \"server\", or \"any\". Set to \"any\" to locate all client, server, and peer device relationships associated with the specified protocol.\n\n\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The activity map properties.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ActivityMap_CREATE"
                        }
                    }
                ],
                "operationId": "createActivitymaps",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/activitymaps/query": {
            "post": {
                "summary": "Perform a network topology query.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nedge_annotations | array[string] | no | The list of one or more edge annotations to include in the topology query. \u003cbr\u003e**Supported values:** \"protocols\", \"appearances\"\nfrom | integer or string | yes | The beginning timestamp of the time range the query will search, expressed in milliseconds since the epoch.\nuntil | integer or string | no | The ending timestamp of the time range the query will search, expressed in milliseconds since the epoch. If no value is set, the query end defaults to \"now\".\nwalks | array[topology_walk] | yes | The list of one or more walk objects to include in the topology query. A walk is the path of traffic composed of one or more steps. Each walk begins with one or more origin devices and expands to connections to peer devices that are based on protocol activity. Each expansion from the origin is a step. Object contents are defined in the \"topology_walk\" section below.\nweighting | string | no | The metric value that determines how activity is weighted between devices. \u003cbr\u003e**Supported values:** \"bytes\", \"connections\", \"turns\"\n topology_walk\n\nname | type | required | description\n-----|------|----------|------------\norigins | array[topology_source] | yes | The list of one or more origin devices of the first step within the walk. Object contents are defined in the \"topology_source\" section below.\nsteps | array[topology_step] | yes | The list of one or more steps within the walk. Each step is defined by the protocol activity between devices of the previous step to a new set of peer devices. Object coontents are defined in the \"topology_step\" section below.\n topology_step\n\nname | type | required | description\n-----|------|----------|------------\npeer_in | array[topology_source] | no | The list of one or more peer devices to include in the topology graph. Only relationships to peers of the specified source object are included. Object contents are defined in the \"topology_source\" section below.\npeer_not_in | array[topology_source] | no | The list of one or more peer devices to exclude from the topology graph. Relationships to peer devices of the specified source object are excluded. Object contents are defined in the \"topology_source\" section below.\nrelationships | array[topology_relationship] | no | The list of one or more filters that define the relationship between two devices. The filters specify which roles and protocols to search for when locating peer devices in the step. Relationships are represented as an edge in the activity map. If no value is set, the operation includes all peers. Object contents are defined in the \"topology_relationship\" section below.\n topology_source\n\nname | type | required | description\n-----|------|----------|------------\nobject_id | integer | yes | The unique identifier for the source object. Set to 0 if the value of the \"object_type\" parameter is \"all_devices\".\nobject_type | string | yes | The type of source object. \u003cbr\u003e**Supported values:** \"all_devices\", \"device_group\", \"device\"\n\n topology_relationship\n\nname | type | required | description\n-----|------|----------|------------\nprotocol | string | no | The protocol over which the origin device is communicating, such as \"HTTP\". If no value is set, the object includes any protocol.\nrole | string | no | The role of the peer device in relation to the origin device. \u003cbr\u003e**Supported values:** \"client\", \"server\", \"any\"\n\n\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The topology query properties.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topology_request"
                        }
                    }
                ],
                "operationId": "createActivitymapsQuery",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved topology graph.",
                        "schema": {
                            "$ref": "#/definitions/topology_response"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "500": {
                        "description": "Internal error retrieving topology graph."
                    }
                },
                "deprecated": false
            }
        },
        "/activitymaps/{id}": {
            "delete": {
                "summary": "Delete a specific activity map.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the activity map.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteActivitymapsId",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The user does not have sufficient permissions to delete the activity map."
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "500": {
                        "description": "Internal server error."
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific activity map.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the activity map.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getActivitymapsId",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "200": {
                        "description": "A single ActivityMap object",
                        "schema": {
                            "$ref": "#/definitions/ActivityMap"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific activity map.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | The description for the activity map.\nmode | string | no | The layout of the activity map. Supported values are \"2dforce\" and \"3dforce\".\nname | string | yes | The friendly name for the activity map.\nowner | string | no | The user that owns the activity map.\nshort_code | string | no | The unique short code that is global to all activity maps.\nshow_alert_status | boolean | no | Indicates whether to show the alert status for devices on the activity map. If enabled, the color of each device on the map represents the most severe alert level associated with the device.\nwalks | array[walk] | yes | The list of one or more walk objects. A walk is the path of traffic composed of one or more steps. Each walk begins with one or more origin devices and expands to connections to peer devices that are based on protocol activity. Each expansion from the origin is a step. The contents of the object are defined in the \"walk\" section below.\nweighting | string | no | The metric value that determines how activity is weighted between devices. Supported element values are \"bytes\", \"connections\", and \"turns\".\n walk\n\nname | type | required | description\n-----|------|----------|------------\norigins | array[source_object] | yes | The list of one or more origin devices of the first step within the walk. Object contents are defined in the \"source_object\" section below.\nsteps | array[step] | yes | The list of one or more steps within the walk. Each step is defined by the protocol activity between devices of the previous step to a new set of peer devices. Object contents are defined in the \"step\" section below.\n step\n\nname | type | required | description\n-----|------|----------|------------\npeer_in | array[source_object] | no | The list of one or more peer device objects to include in the activity map. Only relationships to peers of the specified source object are included. Object contents are defined in the \"source_object\" section below.\npeer_not_in | array[source_object] | no | The list of one or more peer device objects to exclude from the activity map. Relationships to peers of the specified source object are excluded. Object contents are defined in the \"source_object\" section below.\nrelationships | array[relationship] | no | The list of one or more filters that define the relationship between two devices. The filters specify which roles and protocols to search for when locating peer devices in the step. Relationships are represented as an edge in the activity map. Object contents are defined in the \"relationship\" section below. If no value is specified, the operation will locate all peers.\n source_object\n\nname | type | required | description\n-----|------|----------|------------\nobject_id | integer | yes | The unique identifier for the source object.\nobject_type | string | yes | The metric source type. \u003cbr\u003e**Supported values:** \"device\", \"device_group\"\n\n relationship\n\nname | type | required | description\n-----|------|----------|------------\nprotocol | string | no | The metric protocol associated with the relationship, such as \"HTTP\" or \"DNS\". The operation only locates connections between devices over the specified protocol.\nrole | string | no | The device role associated with the metric protocol of the relationship. The operation only locates connections between devices over the associated protocol in the specified role. Supported role values are \"client\", \"server\", or \"any\". Set to \"any\" to locate all client, server, and peer device relationships associated with the specified protocol.\n\n\n",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the activity map.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The activity map properties to update.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ActivityMap_UPDATE"
                        }
                    }
                ],
                "operationId": "updateActivitymapsId",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "204": {
                        "description": "Successfully updated resource."
                    },
                    "400": {
                        "description": "Invalid request parameters."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions."
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "500": {
                        "description": "Internal error."
                    }
                },
                "deprecated": false
            }
        },
        "/activitymaps/{id}/query": {
            "post": {
                "summary": "Perform a topology query for a specific activity map.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nedge_annotations | array[string] | no | The list of one or more edge annotations to include in the topology query. \u003cbr\u003e**Supported values:** \"protocols\", \"appearances\"\nfrom | integer or string | yes | The beginning timestamp of the time range the query will search, expressed in milliseconds since the epoch.\nuntil | integer or string | no | The ending timestamp of the time range the query will search, expressed in milliseconds since the epoch. If no value is set, the query end defaults to \"now\".",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the activity map.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The topology query properties.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topology_captive_request"
                        }
                    }
                ],
                "operationId": "createActivitymapsIdQuery",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved topology graph.",
                        "schema": {
                            "$ref": "#/definitions/topology_response"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions."
                    },
                    "404": {
                        "description": "Resource does not exist."
                    },
                    "500": {
                        "description": "Internal error."
                    }
                },
                "deprecated": false
            }
        },
        "/activitymaps/{id}/sharing": {
            "get": {
                "summary": "Retrieve the users and their sharing permissions for a specific activity map.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the activity map.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getActivitymapsIdSharing",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved sharing configuration.",
                        "schema": {
                            "$ref": "#/definitions/ActivityMapSharing"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The user is not authorized to interact with this activity map.",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update the users and their sharing permissions for a specific activity map.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nanyone | string | no | The activity map permission level of all local or remote users in the sensor or console. Supported permission levels are \"viewer\" and \"null\".\ngroups | object | yes | All of the user groups and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the sensor or console, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard.\nusers | object | yes | All of the users and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The users and their permission levels.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ActivityMapSharing_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the activity map.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateActivitymapsIdSharing",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "204": {
                        "description": "The activity map was successfully updated."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The user is not authorized to interact with this activity map.",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Replace the users and their sharing permissions for a specific activity map.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nanyone | string | no | The activity map permission level of all local or remote users in the sensor or console. Supported permission levels are \"viewer\" and \"null\".\ngroups | object | yes | All of the user groups and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the sensor or console, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard.\nusers | object | yes | All of the users and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The users and their permission levels.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ActivityMapSharing_REPLACE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the activity map.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "replaceActivitymapsIdSharing",
                "tags": [
                    "Activity Map"
                ],
                "responses": {
                    "204": {
                        "description": "The activity map was successfully updated."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The user is not authorized to interact with this activity map.",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts": {
            "get": {
                "summary": "Retrieve all alerts.",
                "operationId": "getAllAssignedAlerts",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Alert objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Alert"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new alert with specified values.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\napply_all | boolean | yes | Indicates whether the alert is assigned to all available data sources.\nauthor | string | no | The name of the user that created the alert.\ncategories | array[string] | no | The list of one or more detection categories. An alert is generated only if a detection is identified in the specified categories. Only applicable to detection alerts.\ncc | array[string] | no | The list of email addresses, not included in an email group, to receive notifications.\ndescription | string | no | An optional description for the alert.\ndisabled | boolean | no | Indicates whether the alert is disabled.\nfield_name | string | no | The name of the monitored metric. Only applicable to threshold alerts.\nfield_name2 | string | no | The second monitored metric when applying a ratio. Only applicable to threshold alerts.\nfield_op | string | no | The type of comparison between the field_name and field_name2 fields when applying a ratio. Only applicable to threshold alerts. \u003cbr\u003e**Supported values:** \"/\", null\ninterval_length | integer | no | The length of the alert interval, expressed in seconds.  Only applicable to threshold alerts. \u003cbr\u003e**Supported values:** 30, 60, 120, 300, 600, 900, 1200, 1800\nname | string | yes | The unique, friendly name for the alert.\nnotify_snmp | boolean | no | Indicates whether to send an SNMP trap when an alert is generated.\nobject_type | string | no | The type of metric source monitored by the alert configuration. Only applicable to detection alerts. \u003cbr\u003e**Supported values:** \"application\", \"device\"\noperand | string | no | The value to compare against alert conditions. The compare method is specified by the value of the operator field. Only applicable to threshold alerts.\noperator | string | no | The logical operator applied when comparing the value of the operand field to alert conditions. Only applicable to threshold alerts. \u003cbr\u003e**Supported values:** \"==\", \"\u003e\", \"\u003c\", \"\u003e=\", \"\u003c=\"\nparam | object | no | The first alert parameter, which is either a key pattern or a data point.  Only applicable to threshold alerts.\nparam2 | object | no | The second alert parameter, which is either a key pattern or a data point. Only applicable to threshold alerts.\nprotocols | array[string] | no | The list of monitored protocols. Only applicable to detection alerts.\nrefire_interval | integer | no | The time interval in which alert conditions are monitored, expressed in seconds. \u003cbr\u003e**Supported values:** 300, 600, 900, 1800, 3600, 7200, 14400\nseverity | integer | no | The severity level of the alert, which is displayed in the Alert History, email notifications, and SNMP traps. Severity levels 0-2 require immediate attention. Severity levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#alert-severity-levels). \u003cbr\u003e**Supported values:** 0, 1, 2, 3, 4, 5, 6, 7\nstat_name | string | no | The statistic name for the alert. Only applicable to threshold alerts.\ntype | string | yes | The type of alert. \u003cbr\u003e**Supported values:** \"threshold\"\nunits | string | no | The interval in which to evaluate the alert condition. Only applicable to threshold alerts. \u003cbr\u003e**Supported values:** \"none\", \"period\", \"1 sec\", \"1 min\", \"1 hr\"",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property values to the new alert.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Alert_CREATE"
                        }
                    }
                ],
                "operationId": "createAlerts",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}": {
            "delete": {
                "summary": "Delete a specific alert.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteAlertsId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific alert.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAlertsId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "A single Alert object",
                        "schema": {
                            "$ref": "#/definitions/Alert"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Apply updates to a specific alert.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\napply_all | boolean | yes | Indicates whether the alert is assigned to all available data sources.\nauthor | string | no | The name of the user that created the alert.\ncategories | array[string] | no | The list of one or more detection categories. An alert is generated only if a detection is identified in the specified categories. Only applicable to detection alerts.\ncc | array[string] | no | The list of email addresses, not included in an email group, to receive notifications.\ndescription | string | no | An optional description for the alert.\ndisabled | boolean | no | Indicates whether the alert is disabled.\nfield_name | string | no | The name of the monitored metric. Only applicable to threshold alerts.\nfield_name2 | string | no | The second monitored metric when applying a ratio. Only applicable to threshold alerts.\nfield_op | string | no | The type of comparison between the field_name and field_name2 fields when applying a ratio. Only applicable to threshold alerts. \u003cbr\u003e**Supported values:** \"/\", null\ninterval_length | integer | no | The length of the alert interval, expressed in seconds.  Only applicable to threshold alerts. \u003cbr\u003e**Supported values:** 30, 60, 120, 300, 600, 900, 1200, 1800\nname | string | yes | The unique, friendly name for the alert.\nnotify_snmp | boolean | no | Indicates whether to send an SNMP trap when an alert is generated.\nobject_type | string | no | The type of metric source monitored by the alert configuration. Only applicable to detection alerts. \u003cbr\u003e**Supported values:** \"application\", \"device\"\noperand | string | no | The value to compare against alert conditions. The compare method is specified by the value of the operator field. Only applicable to threshold alerts.\noperator | string | no | The logical operator applied when comparing the value of the operand field to alert conditions. Only applicable to threshold alerts. \u003cbr\u003e**Supported values:** \"==\", \"\u003e\", \"\u003c\", \"\u003e=\", \"\u003c=\"\nparam | object | no | The first alert parameter, which is either a key pattern or a data point.  Only applicable to threshold alerts.\nparam2 | object | no | The second alert parameter, which is either a key pattern or a data point. Only applicable to threshold alerts.\nprotocols | array[string] | no | The list of monitored protocols. Only applicable to detection alerts.\nrefire_interval | integer | no | The time interval in which alert conditions are monitored, expressed in seconds. \u003cbr\u003e**Supported values:** 300, 600, 900, 1800, 3600, 7200, 14400\nseverity | integer | no | The severity level of the alert, which is displayed in the Alert History, email notifications, and SNMP traps. Severity levels 0-2 require immediate attention. Severity levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#alert-severity-levels). \u003cbr\u003e**Supported values:** 0, 1, 2, 3, 4, 5, 6, 7\nstat_name | string | no | The statistic name for the alert. Only applicable to threshold alerts.\ntype | string | yes | The type of alert. \u003cbr\u003e**Supported values:** \"threshold\"\nunits | string | no | The interval in which to evaluate the alert condition. Only applicable to threshold alerts. \u003cbr\u003e**Supported values:** \"none\", \"period\", \"1 sec\", \"1 min\", \"1 hr\"",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to the alert.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Alert_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateAlertsId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/applications": {
            "get": {
                "summary": "Retrieve all applications that have a specific alert assigned.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedAlertsIdApplications",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Application objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Application"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific alert to applications.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for applications that is assigned and unassigned to the alert.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsAlertsIdApplications",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/applications/{child-id}": {
            "delete": {
                "summary": "Unassign an application from a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignAlertsIdApplicationsChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign an application to a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignAlertsIdApplicationsChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/devicegroups": {
            "get": {
                "summary": "Retrieve all device groups that are assigned to a specific alert.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedAlertsIdDevicegroups",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DeviceGroup objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceGroup"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific alert to device groups.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for device groups that is assigned and unassigned to the alert.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsAlertsIdDevicegroups",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/devicegroups/{child-id}": {
            "delete": {
                "summary": "Unassign a device group from a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignAlertsIdDevicegroupsChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a device group to a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignAlertsIdDevicegroupsChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/devices": {
            "get": {
                "summary": "Retrieve all devices that have a specific alert assigned.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedAlertsIdDevices",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Device objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Device"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific alert to devices.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for devices that is assigned and unassigned to the alert.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsAlertsIdDevices",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/devices/{child-id}": {
            "delete": {
                "summary": "Unassign a device from a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignAlertsIdDevicesChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a device to a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignAlertsIdDevicesChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/emailgroups": {
            "get": {
                "summary": "Retrieve all email groups that are assigned to a specific alert.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedAlertsIdEmailgroups",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "An array of EmailGroup objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/EmailGroup"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific alert to email groups.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for email groups that is assigned and unassigned to the alert.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsAlertsIdEmailgroups",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/emailgroups/{child-id}": {
            "delete": {
                "summary": "Unassign an email group from a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the email group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignAlertsIdEmailgroupsChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign an email group to a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the email group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignAlertsIdEmailgroupsChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/exclusionintervals": {
            "get": {
                "summary": "Retrieve all exclusion intervals assigned to a specific alert.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedAlertsIdExclusionintervals",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ExclusionInterval objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/ExclusionInterval"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific alert to exclusion intervals.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for exclusion intervals that is assigned and unassigned to the alert.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsAlertsIdExclusionintervals",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/exclusionintervals/{child-id}": {
            "delete": {
                "summary": "Unassign an exclusion interval from a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the exclusion interval.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignAlertsIdExclusionintervalsChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign an exclusion interval to a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the exclusion interval.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignAlertsIdExclusionintervalsChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/networks": {
            "get": {
                "summary": "Retrieve all networks that have a specific alert assigned.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedAlertsIdNetworks",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Network objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Network"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific alert to networks.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for networks that is assigned and unassigned to the alert.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsAlertsIdNetworks",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/networks/{child-id}": {
            "delete": {
                "summary": "Unassign a network from a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignAlertsIdNetworksChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a network to a specific alert.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignAlertsIdNetworksChildId",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/alerts/{id}/stats": {
            "get": {
                "summary": "Retrieve all additional statistics for a specific alert.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedAlertsIdStats",
                "tags": [
                    "Alert"
                ],
                "responses": {
                    "200": {
                        "description": "An array of AlertAdditionalStat objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/AlertAdditionalStat"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/analysispriority/config/{appliance_id}": {
            "get": {
                "summary": "Retrieve the analysis priority rules for a specific sensor.",
                "parameters": [
                    {
                        "name": "appliance_id",
                        "in": "path",
                        "description": "The identifier for a sensor. Set this value to 0 if calling on a sensor.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAnalysispriorityConfigAppliance_id",
                "tags": [
                    "Analysis Priority"
                ],
                "responses": {
                    "200": {
                        "description": "The request was successful.",
                        "schema": {
                            "$ref": "#/definitions/analysis_priority_config"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The specified ID is not for a sensor."
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Replace the analysis priority rules for a specific sensor.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nadvanced_rules | array[analysis_priority_rule] | no | The Advanced Analysis priority rules for a device group.\nautofill_advanced | boolean | yes | Indicates whether to automatically place devices in Advanced Analysis until capacity is reached. Devices in the advanced_rules list are prioritized, followed by devices in the standard_rules list, and then by the discovery time for the device. The capacity for Advanced Analysis is determined by the ExtraHop system license.\nautofill_standard | boolean | yes | Indicates whether to automatically place devices in Standard Analysis until total capacity is reached. Devices in the standard_rules list are prioritized, followed by the discovery time for the device. The total capacity is determined by the ExtraHop system license.\nstandard_rules | array[analysis_priority_rule] | no | The Standard Analysis priority rules for a device group.\n analysis_priority_rule\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | The description for analysis priority rules.\nobject_id | integer | yes | The unique identifier for the group.\ntype | string | yes | The type of group the analysis priority rules apply to. \u003cbr\u003e**Supported values:** \"device_group\"\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The properties of the priority analysis rules.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/analysis_priority_config"
                        }
                    },
                    {
                        "name": "appliance_id",
                        "in": "path",
                        "description": "The identifier for a sensor. Set this value to 0 if calling on a sensor.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "replaceAnalysispriorityConfigAppliance_id",
                "tags": [
                    "Analysis Priority"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The current user has insufficient privileges."
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The specified ID is not for a sensor."
                    }
                },
                "deprecated": false
            }
        },
        "/analysispriority/{appliance_id}/manager": {
            "get": {
                "summary": "Retrieve the console that manages analysis priority rules for a specific sensor.",
                "description": "This operation can only be called on a sensor.",
                "parameters": [
                    {
                        "name": "appliance_id",
                        "in": "path",
                        "description": "The identifier for the local sensor. This value must be set to 0.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAnalysispriorityAppliance_idManager",
                "tags": [
                    "Analysis Priority"
                ],
                "responses": {
                    "200": {
                        "description": "The request was successful.",
                        "schema": {
                            "$ref": "#/definitions/get_config_manager"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "Invalid ID. The value must be 0 to specify the local sensor."
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update which sensor or console manages analysis priority rules for the local sensor.",
                "description": "This operation can only be called on a sensor.\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nmanager | integer | no | The unique identifier for the managing sensor or console.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The ID of the sensor or console that will manage analysis priority rules for the local sensor. Set this value to 0 to restore management to the local sensor.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/update_config_manager"
                        }
                    },
                    {
                        "name": "appliance_id",
                        "in": "path",
                        "description": "The identifier for the local sensor. This value must be set to 0.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateAnalysispriorityAppliance_idManager",
                "tags": [
                    "Analysis Priority"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/apikeys": {
            "get": {
                "summary": "Retrieve all API keys.",
                "operationId": "getAllAssignedApikeys",
                "tags": [
                    "APIKey"
                ],
                "responses": {
                    "200": {
                        "description": "An array of APIKey objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/APIKey"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create the initial API key for the setup user account.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\npassword | string | yes | The password for the setup user.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The password of the setup user.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/setup_generate_apikey"
                        }
                    }
                ],
                "operationId": "createApikeys",
                "tags": [
                    "APIKey"
                ],
                "responses": {
                    "201": {
                        "description": "Resource successfully created.",
                        "schema": {
                            "$ref": "#/definitions/apikey_response"
                        }
                    },
                    "401": {
                        "description": "Password is missing or invalid."
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "An API key already exists for the setup user."
                    },
                    "422": {
                        "description": "API key generation is disabled."
                    },
                    "500": {
                        "description": "An internal server error occurred."
                    }
                },
                "deprecated": false
            }
        },
        "/apikeys/{keyid}": {
            "get": {
                "summary": "Retrieve information about a specific API key.",
                "parameters": [
                    {
                        "name": "keyid",
                        "in": "path",
                        "description": "The unique identifier for the API key.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getApikeysKeyid",
                "tags": [
                    "APIKey"
                ],
                "responses": {
                    "200": {
                        "description": "A single APIKey object",
                        "schema": {
                            "$ref": "#/definitions/APIKey"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/appliances": {
            "get": {
                "summary": "Retrieve information about this appliance and all connected appliances.",
                "operationId": "getAllAssignedAppliances",
                "tags": [
                    "Appliance"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Appliance objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Appliance"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Establish a new connection to a remote ExtraHop appliance.",
                "description": "You can only establish a connection to a remote ExtraHop appliance that is licensed for the same edition as the local ExtraHop appliance.\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndata_access | boolean | yes | Indicates whether data can be shared between the local and remote appliances.\nfingerprint | string | no | The fingerprint of the remote appliance. If you are connecting a console to an EXA or ExtraHop packetsore, this field is required. Otherwise, to bypass fingerprint verification, specify 'insecure_skip_verification'. Note that bypassing verification can allow for man-in-the-middle attacks.\nhost | string | yes | The hostname of the remote appliance.\nlocal_nickname_for_remote | string | no | The nickname for the local appliance, referred to by the remote appliance.\nmanaged_by_local | boolean | no | Indicates whether the remote appliance is managed by the local appliance. If you are connecting a console to a sensor, this field is not required because console always manage connected sensors.\nmanages_local | boolean | no | Indicates whether the remote appliance manages the local appliance.\nproduct_key | string | no | The product key for the remote appliance. If this parameter is specified, the remote appliance is licensed with the product key. This parameter is invalid when the remote_pairing_token parameter is specified.\nremote_appliance_type | string | yes | The type of appliance for the new connection. \u003cbr\u003e**Supported values:** \"command\", \"explore\", \"discover\", \"trace\"\nremote_nickname_for_local | string | no | The nickname for the remote appliance, referred to by the local appliance. If you are connecting a sensor to any other appliance, this field is required.\nremote_pairing_token | string | no | The token generated on the target sensor or EXA 5300 recordstore. You must specify this parameter to authenticate to the target sensor or recordstore. This parameter is not valid if you are connecting to an ExtraHop packetstore or EXA 5200 recordstore.\nremote_setup_password | string | no | The password for the setup user account on the target EXA or ExtraHop packetstore. This parameter is not required if the remote appliance is a node in an Explore cluster already connected to the console. This parameter is not valid if the remote appliance is a sensor.\nreset_configuration | boolean | no | Indicates whether to reset the configuration of the remote appliance.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Specify the properties of the new connection.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/connect_appliance"
                        }
                    }
                ],
                "operationId": "createAppliances",
                "tags": [
                    "Appliance"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The specified remote appliance is invalid."
                    }
                },
                "deprecated": false
            }
        },
        "/appliances/{id}": {
            "delete": {
                "summary": "Disconnect a specific ExtraHop appliance from this console.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Specify the unique identifier for the remote appliance.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteAppliancesId",
                "tags": [
                    "Appliance"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve information about this appliance or connected appliances.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Specify the unique identifier for the appliance. Specify 0 to select the local appliance.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAppliancesId",
                "tags": [
                    "Appliance"
                ],
                "responses": {
                    "200": {
                        "description": "A single Appliance object",
                        "schema": {
                            "$ref": "#/definitions/Appliance"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/appliances/{id}/cloudservices": {
            "get": {
                "summary": "Retrieve the status of ExtraHop Cloud Services on this appliance.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Specify the unique identifier for the appliance. This value must be set to 0, which selects the local appliance.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAppliancesIdCloudservices",
                "tags": [
                    "Appliance"
                ],
                "responses": {
                    "200": {
                        "description": "A single ApplianceCloudServices object",
                        "schema": {
                            "$ref": "#/definitions/ApplianceCloudServices"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Modify ExtraHop Cloud Services settings on this appliance.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\naction | string | yes | Specify the action to modify ExtraHop Cloud Services settings. \u003cbr\u003e**Supported values:** \"unenroll\"",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Specify the unique identifier for the appliance. This value must be set to 0, which selects the local appliance.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Specify the action to modify ExtraHop Cloud Services settings.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/appliance_action"
                        }
                    }
                ],
                "operationId": "createAppliancesIdCloudservices",
                "tags": [
                    "Appliance"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/appliances/{id}/productkey": {
            "get": {
                "summary": "Retrieve the product key for a specified appliance (only valid on consoles).",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Specify the unique identifier for the appliance.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedAppliancesIdProductkey",
                "tags": [
                    "Appliance"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ApplianceProductKey objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/ApplianceProductKey"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/applications": {
            "get": {
                "summary": "Retrieve all applications that were active within a specific timeframe.",
                "parameters": [
                    {
                        "name": "active_from",
                        "in": "query",
                        "description": "Return only applications that are active after the specified time. Positive values specify the time in milliseconds since the epoch. Negative values specify the time in milliseconds before the current time.",
                        "required": false,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "active_until",
                        "in": "query",
                        "description": "Return only applications that are active before the specified time. Positive values specify the time in milliseconds since the epoch. Negative values specify the time in milliseconds before the current time.",
                        "required": false,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "limit",
                        "in": "query",
                        "description": "Limit the number of applications that are returned to the specified maximum number.",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "default": 100
                    },
                    {
                        "name": "offset",
                        "in": "query",
                        "description": "Skip the first n application results. This parameter is often combined with the limit parameter.",
                        "required": false,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "search_type",
                        "in": "query",
                        "description": "The object type to search for.",
                        "required": true,
                        "type": "string",
                        "enum": [
                            "any",
                            "name",
                            "node",
                            "discovery_id",
                            "extrahop-id"
                        ],
                        "default": "any"
                    },
                    {
                        "name": "value",
                        "in": "query",
                        "description": "The search criteria. Add a forward slash before and after the criteria to apply RegEx matching.",
                        "required": false,
                        "type": "string"
                    }
                ],
                "operationId": "getAllAssignedApplications",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Application objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Application"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new application.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncriteria | array[criteria] | no | An array of protocol and source criteria associated with the application. The contents of this array are defined in the 'criteria' section below.\ndescription | string | no | An optional description for the application.\ndiscovery_id | string | yes | The unique identifier for the application, which is displayed on the application page in the ExtraHop system.\ndisplay_name | string | yes | The friendly name for the application.\nnode_id | integer | no | The unique identifier for the sensor that this application is associated with. The identifier can be retrieved through the GET /appliances operation. This field is valid only on a console.\n criteria\n\nname | type | required | description\n-----|------|----------|------------\nprotocol_default | string | yes | The default protocols monitored by the application. Supported values are 'any' and 'none'.\nprotocols | object | no | The list of one or more protocol and role mappings associated with the application. The application only collects metrics from the specified protocols. The format of each protocol is {'protocol':'role'}. Example: {'http': 'server'}. Supported role values are 'client', 'server', 'any', or 'none'.\nsources | array[source] | yes | An array containing one or more metric sources associated with the application. The application only collects metrics from the specified sources. The contents of this array are defined in the 'source' section below.\n source\n\nname | type | required | description\n-----|------|----------|------------\nid | integer | yes | The unique identifier for the device or device group associated with the application.\ntype | string | yes | The type of metric source associated with the application. Supported source type values are 'device' and 'device_group'.\n\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The properties of the application.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Application_CREATE"
                        }
                    }
                ],
                "operationId": "createApplications",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/applications/{id}": {
            "get": {
                "summary": "Retrieve a specific application.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "include_criteria",
                        "in": "query",
                        "description": "Indicates whether to include the criteria associated with the application in the response.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getApplicationsId",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "200": {
                        "description": "A single Application object",
                        "schema": {
                            "$ref": "#/definitions/Application"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific application.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncriteria | array[criteria] | no | An array of protocol and source criteria associated with the application. The contents of this array are defined in the 'criteria' section below.\ndescription | string | no | An optional description for the application.\ndisplay_name | string | yes | The friendly name for the application.\n criteria\n\nname | type | required | description\n-----|------|----------|------------\nprotocol_default | string | yes | The default protocols monitored by the application. Supported values are 'any' and 'none'.\nprotocols | object | no | The list of one or more protocol and role mappings associated with the application. The application only collects metrics from the specified protocols. The format of each protocol is {'protocol':'role'}. Example: {'http': 'server'}. Supported role values are 'client', 'server', 'any', or 'none'.\nsources | array[source] | yes | An array containing one or more metric sources associated with the application. The application only collects metrics from the specified sources. The contents of this array are defined in the 'source' section below.\n source\n\nname | type | required | description\n-----|------|----------|------------\nid | integer | yes | The unique identifier for the device or device group associated with the application.\ntype | string | yes | The type of metric source associated with the application. Supported source type values are 'device' and 'device_group'.\n\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property updates to the application.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Application_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateApplicationsId",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/applications/{id}/activity": {
            "get": {
                "summary": "Retrieve all activity for a specific application.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedApplicationsIdActivity",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ApplicationActivity objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/ApplicationActivity"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/applications/{id}/alerts": {
            "get": {
                "summary": "Retrieve all alerts that are assigned to a specific application.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Retrieve the unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "direct_assignments_only",
                        "in": "query",
                        "description": "Indicates whether results are restricted to alerts that are directly assigned to the application.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getAllAssignedApplicationsIdAlerts",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Alert objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Alert"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign alerts to a specific application.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Assign or unassign the specified list of unique identifiers for alerts.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Provide a unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsApplicationsIdAlerts",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/applications/{id}/alerts/{child-id}": {
            "delete": {
                "summary": "Unassign an alert from a specific application.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignApplicationsIdAlertsChildId",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign an alert to a specific application.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignApplicationsIdAlertsChildId",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/applications/{id}/dashboards": {
            "get": {
                "summary": "Retrieve all dashboards related to a specific application.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the application.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedApplicationsIdDashboards",
                "tags": [
                    "Application"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Dashboard objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Dashboard"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/auditlog": {
            "get": {
                "summary": "Retrieve all audit log messages.",
                "parameters": [
                    {
                        "name": "limit",
                        "in": "query",
                        "description": "The maximum number of log messages to return.",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "default": 100
                    },
                    {
                        "name": "offset",
                        "in": "query",
                        "description": "The number of log messages to skip in the results. Returns log messages starting from the offset value.",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "default": 0
                    }
                ],
                "operationId": "getAllAssignedAuditlog",
                "tags": [
                    "Audit Log"
                ],
                "responses": {
                    "200": {
                        "description": "An array of AuditLog objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/AuditLog"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/auth/identityproviders": {
            "get": {
                "summary": "Retrieve all identity providers.",
                "operationId": "getAllAssignedAuthIdentityproviders",
                "tags": [
                    "Auth"
                ],
                "responses": {
                    "200": {
                        "description": "An array of AuthIdentityProvider objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/AuthIdentityProvider"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Add an identity provider for remote authentication.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nauto_provision_users | boolean | yes | Indicates whether a user can be created on the ExtraHop system from the identity provider.\nenabled | boolean | yes | Indicates whether authentication through the identity provider is enabled on the ExtraHop system.\nentity_id | string | no | The SAML 2.0 entityID.\nname | string | yes | The name of the identity provider.\nsigning_certificate | string | no | The SAML 2.0 X.509 signing certificate in PEM format.\nsso_url | string | no | The SAML 2.0 Single Sign-On (SSO) URL.\ntype | string | yes | The type of identity provider. \u003cbr\u003e**Supported values:** \"saml\"",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Parameters for the identity provider.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/AuthIdentityProvider_CREATE"
                        }
                    }
                ],
                "operationId": "createAuthIdentityproviders",
                "tags": [
                    "Auth"
                ],
                "responses": {
                    "201": {
                        "description": "Successfully added the identity provider."
                    },
                    "400": {
                        "description": "The specified parameters for the identity provider are invalid.",
                        "schema": {
                            "$ref": "#/definitions/idp_bad_request"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "The name of the specified identity provider already exists.",
                        "schema": {
                            "$ref": "#/definitions/idp_bad_request"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/auth/identityproviders/{id}": {
            "delete": {
                "summary": "Delete a specific identity provider.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the identity provider.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteAuthIdentityprovidersId",
                "tags": [
                    "Auth"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific identity provider.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the identity provider.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAuthIdentityprovidersId",
                "tags": [
                    "Auth"
                ],
                "responses": {
                    "200": {
                        "description": "A single AuthIdentityProvider object",
                        "schema": {
                            "$ref": "#/definitions/AuthIdentityProvider"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update an existing identity provider.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nauto_provision_users | boolean | yes | Indicates whether a user can be created on the ExtraHop system from the identity provider.\nenabled | boolean | yes | Indicates whether authentication through the identity provider is enabled on the ExtraHop system.\nentity_id | string | no | The SAML 2.0 entityID.\nname | string | yes | The name of the identity provider.\nsigning_certificate | string | no | The SAML 2.0 X.509 signing certificate in PEM format.\nsso_url | string | no | The SAML 2.0 Single Sign-On (SSO) URL.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the identity provider.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The parameters for the identity provider.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/AuthIdentityProvider_UPDATE"
                        }
                    }
                ],
                "operationId": "updateAuthIdentityprovidersId",
                "tags": [
                    "Auth"
                ],
                "responses": {
                    "204": {
                        "description": "Successfully updated the identity provider."
                    },
                    "400": {
                        "description": "The specified parameters for the identity provider are invalid.",
                        "schema": {
                            "$ref": "#/definitions/idp_bad_request"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "There is no identity provider with the specified ID.",
                        "schema": {
                            "$ref": "#/definitions/idp_bad_request"
                        }
                    },
                    "409": {
                        "description": "The name of the specified identity provider already exists.",
                        "schema": {
                            "$ref": "#/definitions/idp_bad_request"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/auth/identityproviders/{id}/privileges": {
            "get": {
                "summary": "Retrieve the privilege settings for a specific identity provider.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the identity provider.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAuthIdentityprovidersIdPrivileges",
                "tags": [
                    "Auth"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "There is no SAML identity provider with the specified ID."
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update the privilege settings for a specific identity provider.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndetectionsaccesslevel | detectionsaccesslevel_map | no | Deprecated. Replaced by the ndrlevel field.\nndrlevel | ndrlevel_map | no | An object that maps a SAML attribute to NDR privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels).\nnpmlevel | npmlevel_map | no | An object that maps a SAML attribute to NPM privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels).\npacketslevel | packetslevel_map | no | An object that maps a SAML attribute to packet privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels).\nwritelevel | writelevel_map | no | An object that maps a SAML attribute to write privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels).\n detectionsaccesslevel_map\n\nname | type | required | description\n-----|------|----------|------------\nattribute_name | string | no | Specifies the SAML attribute that grants detection privileges on the ExtraHop system.\nfull | string | no | Specifies the SAML attribute value that grants access to detections on the ExtraHop system.\nnone | string | no | Specifies the SAML attribute value that prevents all access to detections on the ExtraHop system.\n\n ndrlevel_map\n\nname | type | required | description\n-----|------|----------|------------\nattribute_name | string | no | Specifies the SAML attribute that grants NDR privileges on the ExtraHop system.\nfull | string | no | Specifies the SAML attribute value that grants access to NDR on the ExtraHop system.\nnone | string | no | Specifies the SAML attribute value that prevents all access to NDR on the ExtraHop system.\n\n npmlevel_map\n\nname | type | required | description\n-----|------|----------|------------\nattribute_name | string | no | Specifies the SAML attribute that grants NPM privileges on the ExtraHop system.\nfull | string | no | Specifies the SAML attribute value that grants access to NPM on the ExtraHop system.\nnone | string | no | Specifies the SAML attribute value that prevents all access to NPM on the ExtraHop system.\n\n packetslevel_map\n\nname | type | required | description\n-----|------|----------|------------\nattribute_name | string | no | Specifies the SAML attribute that grants packet privileges on the ExtraHop system.\nfull | string | no | Specifies the SAML attribute value that grants access to packets on the ExtraHop system.\nfull_with_keys | string | no | Specifies the SAML attribute value that grants access to packets and session keys on the ExtraHop system.\nnone | string | no | Specifies the SAML attribute value that prevents all access to packets on the ExtraHop system.\nslices_only | string | no | Specifies the SAML attribute value that grants access to only packet slices on the ExtraHop system.\n\n writelevel_map\n\nname | type | required | description\n-----|------|----------|------------\nattribute_name | string | no | Specifies the SAML attribute that grants write privileges on the ExtraHop system.\nfull_readonly | string | no | Specifies the SAML attribute value that grants full read-only privileges on the ExtraHop system.\nfull_write | string | no | Specifies the SAML attribute value that grants full write privileges on the ExtraHop system.\nlimited_write | string | no | Specifies the SAML attribute value that grants limited write privileges on the ExtraHop system.\nnone | string | no | Specifies the SAML attribute value that prevents all access to the ExtraHop system.\npersonal_write | string | no | Specifies the SAML attribute value that grants personal write privileges on the ExtraHop system.\nrestricted_readonly | string | no | Specifies the SAML attribute value that grants restricted read-only privileges on the ExtraHop system.\nunlimited | string | no | Specifies the SAML attribute value that grants unlimited write privileges on the ExtraHop system.\n",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the identity provider.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "An object that contains the privilege settings.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/AuthIdentityProviderSamlAttributeMap_UPDATE"
                        }
                    }
                ],
                "operationId": "updateAuthIdentityprovidersIdPrivileges",
                "tags": [
                    "Auth"
                ],
                "responses": {
                    "204": {
                        "description": "Successfully updated privilege settings."
                    },
                    "400": {
                        "description": "The specified attribute map is invalid."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "There is no SAML identity provider with the specified ID."
                    }
                },
                "deprecated": false
            }
        },
        "/auth/samlsp": {
            "get": {
                "summary": "Retrieve SAML security provider (SP) metadata for this ExtraHop system.",
                "parameters": [
                    {
                        "name": "xml",
                        "in": "query",
                        "description": "Indicates whether to retrieve the SAML 2.0 XML metadata.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "produces": [
                    "application/json",
                    "application/xml"
                ],
                "operationId": "getAuthSamlsp",
                "tags": [
                    "Auth"
                ],
                "responses": {
                    "200": {
                        "description": "A single AuthSAML object",
                        "schema": {
                            "$ref": "#/definitions/AuthSAML"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/bundles": {
            "get": {
                "summary": "Retrieve metadata about all bundles.",
                "operationId": "getAllAssignedBundles",
                "tags": [
                    "Bundle"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Bundle objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Bundle"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Upload a new bundle.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "A JSON formatted bundle export.",
                        "required": true,
                        "schema": {
                            "type": "string",
                            "description": "A JSON formatted bundle export."
                        }
                    }
                ],
                "operationId": "createBundles",
                "tags": [
                    "Bundle"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/bundles/{id}": {
            "delete": {
                "summary": "Delete a specific bundle.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the bundle.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteBundlesId",
                "tags": [
                    "Bundle"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific bundle export.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the bundle.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getBundlesId",
                "tags": [
                    "Bundle"
                ],
                "responses": {
                    "200": {
                        "description": "An export in JSON format of the bundle contents."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/bundles/{id}/apply": {
            "post": {
                "summary": "Apply a saved bundle.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ninclude_assignments | boolean | yes | Indicates whether object assignments should be restored with the bundle.\nnode_ids | array[integer] | yes | A list of unique identifiers for the sensors on which to apply the bundle. This field is valid only on a console.\npolicy | string | yes | Indicates whether conflicting objects should be overwritten or skipped. \u003cbr\u003e**Supported values:** \"overwrite\", \"skip\"",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the bundle.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The configuration options for applying the bundle.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/bundle_apply"
                        }
                    }
                ],
                "operationId": "createBundlesIdApply",
                "tags": [
                    "Bundle"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/cloud/connect": {
            "post": {
                "summary": "Connect a sensor to RevealX 360.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncloud_token | string | yes | The token you generated from RevealX 360.\nnickname | string | yes | A nickname to easily identify the sensor.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The token you generated from RevealX 360.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Cloud_CREATE"
                        }
                    }
                ],
                "operationId": "createCloudConnect",
                "tags": [
                    "Cloud"
                ],
                "responses": {
                    "201": {
                        "description": "Successfully connected to RevealX 360."
                    },
                    "400": {
                        "description": "Failed to connect to RevealX 360."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The cloud_token parameter is missing."
                    }
                },
                "deprecated": false
            }
        },
        "/customdevices": {
            "get": {
                "summary": "Retrieve all custom devices.",
                "parameters": [
                    {
                        "name": "include_criteria",
                        "in": "query",
                        "description": "Indicates whether the custom device criteria should be included.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getAllAssignedCustomdevices",
                "tags": [
                    "Custom Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of CustomDevice objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/CustomDevice"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a custom device.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nauthor | string | no | The name of the custom device creator.\ncriteria | array[CustomDeviceCriterion] | no | An array of custom device criteria for this device. If this field is specified with the PATCH method, all previously specified criteria are deleted.\ndescription | string | no | An optional description of the custom device.\ndisabled | boolean | yes | Indicates whether the custom device is inactive.\nextrahop_id | string | no | A unique identifier for the custom device. If this field is not specified, an ID is generated from the custom device name. The ID cannot contain spaces and cannot be changed after the custom device is saved.\nname | string | yes | The friendly name for the custom device.\n CustomDeviceCriterion\n\nname | type | required | description\n-----|------|----------|------------\ndst_port_max | integer | no | The maximum destination port boundary to match the custom device to. Supported values: 1-65535.\ndst_port_min | integer | no | The lower destination port boundary to match the custom device to. Supported values: 1-65535.\nipaddr | string | no | The IP address to match the custom device to.\nipaddr_direction | string | no | The direction of traffic to match the ipaddr address to. The criteria determines which direction of traffic to or from the ipaddr address is matched. \u003cbr\u003e**Supported values:** \"any\", \"dst\", \"src\"\nipaddr_peer | string | no | The IP address that the ipadder address is communicating with to match the custom device to. If specified, this parameter limits the traffic matched by the custom device. For example, if ipaddr_direction is \"src\", the custom device only matches traffic to the ipaddr_peer address from the ipaddr address. This parameter is only valid if ipaddr is specified and ipaddr_direction is not \"any\".\nsrc_port_max | integer | no | The maximum source port boundary to match the custom device to. Supported values: 1-65535.\nsrc_port_min | integer | no | The lower source port boundary to match the custom device to. Supported values: 1-65535.\nvlan_max | integer | no | The maximum VLAN boundary to match the custom device to.\nvlan_min | integer | no | The lower VLAN boundary to match the custom device to.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property values to the new custom device.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/CustomDevice_CREATE"
                        }
                    }
                ],
                "operationId": "createCustomdevices",
                "tags": [
                    "Custom Device"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/customdevices/{id}": {
            "delete": {
                "summary": "Delete a specific custom device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the custom device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteCustomdevicesId",
                "tags": [
                    "Custom Device"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific custom device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the custom device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "include_criteria",
                        "in": "query",
                        "description": "Indicates whether the custom device criteria should be included.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getCustomdevicesId",
                "tags": [
                    "Custom Device"
                ],
                "responses": {
                    "200": {
                        "description": "A single CustomDevice object",
                        "schema": {
                            "$ref": "#/definitions/CustomDevice"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific custom device.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nauthor | string | no | The name of the custom device creator.\ncriteria | array[CustomDeviceCriterion] | no | An array of custom device criteria for this device. If this field is specified with the PATCH method, all previously specified criteria are deleted.\ndescription | string | no | An optional description of the custom device.\ndisabled | boolean | yes | Indicates whether the custom device is inactive.\nname | string | yes | The friendly name for the custom device.\n CustomDeviceCriterion\n\nname | type | required | description\n-----|------|----------|------------\ndst_port_max | integer | no | The maximum destination port boundary to match the custom device to. Supported values: 1-65535.\ndst_port_min | integer | no | The lower destination port boundary to match the custom device to. Supported values: 1-65535.\nipaddr | string | no | The IP address to match the custom device to.\nipaddr_direction | string | no | The direction of traffic to match the ipaddr address to. The criteria determines which direction of traffic to or from the ipaddr address is matched. \u003cbr\u003e**Supported values:** \"any\", \"dst\", \"src\"\nipaddr_peer | string | no | The IP address that the ipadder address is communicating with to match the custom device to. If specified, this parameter limits the traffic matched by the custom device. For example, if ipaddr_direction is \"src\", the custom device only matches traffic to the ipaddr_peer address from the ipaddr address. This parameter is only valid if ipaddr is specified and ipaddr_direction is not \"any\".\nsrc_port_max | integer | no | The maximum source port boundary to match the custom device to. Supported values: 1-65535.\nsrc_port_min | integer | no | The lower source port boundary to match the custom device to. Supported values: 1-65535.\nvlan_max | integer | no | The maximum VLAN boundary to match the custom device to.\nvlan_min | integer | no | The lower VLAN boundary to match the custom device to.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to the custom device.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/CustomDevice_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the custom device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateCustomdevicesId",
                "tags": [
                    "Custom Device"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/customizations": {
            "get": {
                "summary": "Retrieve all backup files.",
                "operationId": "getAllAssignedCustomizations",
                "tags": [
                    "Customization"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Customization objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Customization"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a backup file.",
                "description": "This operation creates a backup file for the sensor or console, which includes customizations and system resources.\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nname | string | yes | A unique name for the backup file.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "A unique name for the backup file.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/backup_name"
                        }
                    }
                ],
                "operationId": "createCustomizations",
                "tags": [
                    "Customization"
                ],
                "responses": {
                    "201": {
                        "description": "Backup file successfully created."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/customizations/status": {
            "get": {
                "summary": "Retrieve status details for the most recent backup attempt.",
                "operationId": "getCustomizationsStatus",
                "tags": [
                    "Customization"
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved backup status.",
                        "schema": {
                            "$ref": "#/definitions/customization_status"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/customizations/{id}": {
            "delete": {
                "summary": "Delete a specific backup file.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the backup file.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteCustomizationsId",
                "tags": [
                    "Customization"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific backup file.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the backup file.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "produces": [
                    "application/octet-stream"
                ],
                "operationId": "getCustomizationsId",
                "tags": [
                    "Customization"
                ],
                "responses": {
                    "200": {
                        "description": "Successful request"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/customizations/{id}/apply": {
            "post": {
                "summary": "Restore only customizations from a backup file.",
                "description": "This operation only restores customizations from the specified backup file. Resources are not restored.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the backup file.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "createCustomizationsIdApply",
                "tags": [
                    "Customization"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/customizations/{id}/download": {
            "post": {
                "summary": "Download a specific backup file.",
                "description": "Run this operation in the ExtraHop API Explorer to retrieve scripts in Ruby, Python or Curl. Then, run the script in your environment to download the backup file.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the backup file.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "produces": [
                    "application/x-gzip"
                ],
                "operationId": "createCustomizationsIdDownload",
                "tags": [
                    "Customization"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The specified backup file cannot be downloaded."
                    }
                },
                "deprecated": false
            }
        },
        "/dashboards": {
            "get": {
                "summary": "Retrieve all dashboards.",
                "operationId": "getAllAssignedDashboards",
                "tags": [
                    "Dashboard"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Dashboard objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Dashboard"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/dashboards/{id}": {
            "delete": {
                "summary": "Delete a specific dashboard.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the dashboard.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteDashboardsId",
                "tags": [
                    "Dashboard"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific dashboard.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the dashboard.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDashboardsId",
                "tags": [
                    "Dashboard"
                ],
                "responses": {
                    "200": {
                        "description": "A single Dashboard object",
                        "schema": {
                            "$ref": "#/definitions/Dashboard"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update ownership of a specific dashboard.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nowner | string | no | The username of the dashboard owner.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The username of the dashboard owner.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Dashboard_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the dashboard.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateDashboardsId",
                "tags": [
                    "Dashboard"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/dashboards/{id}/sharing": {
            "get": {
                "summary": "Retrieve the users and their sharing permissions for a specific dashboard.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the dashboard.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDashboardsIdSharing",
                "tags": [
                    "Dashboard"
                ],
                "responses": {
                    "200": {
                        "description": "The request was successful.",
                        "schema": {
                            "$ref": "#/definitions/DashboardSharing"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The user is not authorized to interact with this dashboard.",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update the users and their sharing permissions for a specific dashboard.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nanyone | string | no | The dashboard permission level of all local or remote users in the ExtraHop system. \u003cbr\u003e**Supported values:** \"viewer\", null\ngroups | object | yes | The IDs and permission levels of all user groups that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the ExtraHop system, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard.\nusers | object | yes | The usernames and permission levels of all users that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The users and their permission levels.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/DashboardSharing_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the dashboard.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateDashboardsIdSharing",
                "tags": [
                    "Dashboard"
                ],
                "responses": {
                    "204": {
                        "description": "The resource was successfully updated."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The user is not authorized to interact with this dashboard.",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Replace the users and their sharing permissions for a specific dashboard.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nanyone | string | no | The dashboard permission level of all local or remote users in the ExtraHop system. \u003cbr\u003e**Supported values:** \"viewer\", null\ngroups | object | yes | The IDs and permission levels of all user groups that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the ExtraHop system, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard.\nusers | object | yes | The usernames and permission levels of all users that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The users and their permission levels.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/DashboardSharing_REPLACE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the dashboard.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "replaceDashboardsIdSharing",
                "tags": [
                    "Dashboard"
                ],
                "responses": {
                    "204": {
                        "description": "The resource was successfully updated."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The user is not authorized to interact with this dashboard.",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The provided user or user group does not exist."
                    }
                },
                "deprecated": false
            }
        },
        "/detections": {
            "get": {
                "summary": "Retrieve all detections.",
                "parameters": [
                    {
                        "name": "limit",
                        "in": "query",
                        "description": "Limit the number of detections returned to the specified maximum number. A random selection of detections is returned.",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "default": 1000
                    }
                ],
                "operationId": "getAllAssignedDetections",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Detections objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Detections"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/formats": {
            "get": {
                "summary": "Retrieve all detection formats.",
                "operationId": "getAllAssignedDetectionsFormats",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DetectionsFormats objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DetectionsFormats"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new custom detection format.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nauthor | string | no | The author of the detection format.\ncategories | array[string] | no | The list of categories the detection belongs to. For POST and PATCH operations, specify a list with a single string. You cannot specify more than one category for custom detection formats. The \"perf\" or \"sec\" category is automatically added to all detection formats.\ndisplay_name | string | yes | The display name of the detection type that appears on the Detections page in the ExtraHop system.\nmitre_categories | array[string] | no | The IDs of the MITRE techniques associated with the detection.\ntype | string | yes | A string identifier for the detection type. The string can only contain letters, numbers, and underscores. Although detection types are unique across built-in formats, and detection types are unique across custom formats, a built-in and custom format can share the same detection type.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The parameters of the detection format.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/DetectionsFormats_CREATE"
                        }
                    }
                ],
                "operationId": "createDetectionsFormats",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/formats/{id}": {
            "delete": {
                "summary": "Delete a specific custom detection format. You cannot delete built-in detection formats.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The string identifier of the detection format.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteDetectionsFormatsId",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific detection format.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The string identifier of the detection format.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "built_in_only",
                        "in": "query",
                        "description": "If this field is true, returns only built-in detection formats. If this field is false, and both a custom format and a built-in format have the same ID, returns the custom format. The default value is false.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getDetectionsFormatsId",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "A single DetectionsFormats object",
                        "schema": {
                            "$ref": "#/definitions/DetectionsFormats"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific custom detection format. You cannot update built-in detection formats.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nauthor | string | no | The author of the detection format.\ncategories | array[string] | no | The list of categories the detection belongs to. For POST and PATCH operations, specify a list with a single string. You cannot specify more than one category for custom detection formats. The \"perf\" or \"sec\" category is automatically added to all detection formats.\ndisplay_name | string | yes | The display name of the detection type that appears on the Detections page in the ExtraHop system.\nmitre_categories | array[string] | no | The IDs of the MITRE techniques associated with the detection.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The string identifier of the detection format.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The parameters of the detection format.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/DetectionsFormats_UPDATE"
                        }
                    }
                ],
                "operationId": "updateDetectionsFormatsId",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/rules/hiding": {
            "get": {
                "summary": "Retrieve all tuning rules.",
                "operationId": "getAllAssignedDetectionsRulesHiding",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DetectionsHidingRules objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DetectionsHidingRules"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a tuning rule.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | The description of the tuning rule.\ndetection_type | string | yes | The type of detection that this tuning rule applies to. View a list of valid fields for \"type\" by running the GET /detections/formats operation. Specify \"all_performance\" or \"all_security\" to apply the rule to all performance or all security detections.\nexpiration | integer | yes | The time that the tuning rule expires, expressed in milliseconds since the epoch. A value of null or 0 indicates that the rule does not expire.\noffender | detection_hiding_participant | yes | The offender that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any offender.\nproperties | array[detection_property_filter] | no | The filter criteria for detection properties.\nvictim | detection_hiding_participant | yes | The victim that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any victim.\n detection_hiding_participant\n\nname | type | required | description\n-----|------|----------|------------\nobject_hostname | array or string | no | The hostname of a participant. You can specify a single hostname in a string or multiple hostnames in an array. This option is valid only if the object_type is \"hostname\".\nobject_id | integer | no | The ID for the device, device group, or network locality. This option is valid only if the object_type is \"device\", \"device_group\", or \"network_locality\".\nobject_locality | string | no | The network locality type of the participant. Specify either \"external\" or \"internal\". This option is valid only if the object_type is \"locality_type\". \u003cbr\u003e**Supported values:** \"internal\", \"external\"\nobject_scanner | string or array | no | The name of an external scanning service. You can specify a single service in a string or multiple values in an array. You can also specify \"Any\" to select any scanning service. This option is valid only if the object_type is \"scanner_service\".\nobject_type | string | yes | The type of participant. \u003cbr\u003e**Supported values:** \"device\", \"device_group\", \"ipaddr\", \"locality_type\", \"network_locality\", \"hostname\", \"scanner_service\"\nobject_value | array or string | no | The IP address or CIDR block of the participant. You can specify a single address or block in a string or multiple addresses or blocks in an array. This option is valid only if the object_type is \"ipaddr\".\n\n detection_property_filter\n\nname | type | required | description\n-----|------|----------|------------\noperand | string or integer or object | no | The value that the filter attempts to match. The filter compares the value of the operand to the value of the detection property and applies the compare method specified by the operator parameter. You can specify the operand as a string, integer, or object. For more information, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#operand-values-for-detection-property-tuning-rules).\noperator | string | yes | The compare method applied when matching the operand value against the detection property value. \u003cbr\u003e**Supported values:** \"=\", \"!=\", \"~\", \"!~\", \"in\"\nproperty | string | yes | The name of the property to filter.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The tuning rule parameters.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/DetectionsHidingRules_CREATE"
                        }
                    }
                ],
                "operationId": "createDetectionsRulesHiding",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/rules/hiding/{id}": {
            "delete": {
                "summary": "Delete a tuning rule.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tuning rule.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteDetectionsRulesHidingId",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific tuning rule.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tuning rule.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDetectionsRulesHidingId",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "A single DetectionsHidingRules object",
                        "schema": {
                            "$ref": "#/definitions/DetectionsHidingRules"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a tuning rule.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | The description of the tuning rule.\nenabled | boolean | no | Indicates whether the tuning rule is enabled.\nexpiration | integer | no | The time that the tuning rule expires, expressed in milliseconds since the epoch. A value of null or 0 indicates that the rule does not expire.\noffender | detection_hiding_participant | no | The offender that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any offender.\nproperties | array[detection_property_filter] | no | The filter criteria for detection properties.\nvictim | detection_hiding_participant | no | The victim that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any victim.\n detection_hiding_participant\n\nname | type | required | description\n-----|------|----------|------------\nobject_hostname | array or string | no | The hostname of a participant. You can specify a single hostname in a string or multiple hostnames in an array. This option is valid only if the object_type is \"hostname\".\nobject_id | integer | no | The ID for the device, device group, or network locality. This option is valid only if the object_type is \"device\", \"device_group\", or \"network_locality\".\nobject_locality | string | no | The network locality type of the participant. Specify either \"external\" or \"internal\". This option is valid only if the object_type is \"locality_type\". \u003cbr\u003e**Supported values:** \"internal\", \"external\"\nobject_scanner | string or array | no | The name of an external scanning service. You can specify a single service in a string or multiple values in an array. You can also specify \"Any\" to select any scanning service. This option is valid only if the object_type is \"scanner_service\".\nobject_type | string | yes | The type of participant. \u003cbr\u003e**Supported values:** \"device\", \"device_group\", \"ipaddr\", \"locality_type\", \"network_locality\", \"hostname\", \"scanner_service\"\nobject_value | array or string | no | The IP address or CIDR block of the participant. You can specify a single address or block in a string or multiple addresses or blocks in an array. This option is valid only if the object_type is \"ipaddr\".\n\n detection_property_filter\n\nname | type | required | description\n-----|------|----------|------------\noperand | string or integer or object | no | The value that the filter attempts to match. The filter compares the value of the operand to the value of the detection property and applies the compare method specified by the operator parameter. You can specify the operand as a string, integer, or object. For more information, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#operand-values-for-detection-property-tuning-rules).\noperator | string | yes | The compare method applied when matching the operand value against the detection property value. \u003cbr\u003e**Supported values:** \"=\", \"!=\", \"~\", \"!~\", \"in\"\nproperty | string | yes | The name of the property to filter.\n",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tuning rule.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The tuning rule fields to update.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/detection_hiding_update_params"
                        }
                    }
                ],
                "operationId": "updateDetectionsRulesHidingId",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/search": {
            "post": {
                "summary": "Search for detections.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncreate_time | integer | no | Returns detections that were created after the specified date, expressed in milliseconds since the epoch. For sensors, this returns detections that were generated after the specified date. For consoles, this returns detections that were first synchronized to the console after the specified date.\nfilter | detection_search_filter | no | Detection-specific filters.\nfrom | integer | no | Returns detections that occurred after the specified date, expressed in milliseconds since the epoch. Detections that started before the specified date are returned if the detection was ongoing at that time.\nid_only | boolean | no | Returns only the IDs of the detections.\nlimit | integer | no | Returns no more than the specified number of detections.\nmod_time | integer | no | Returns detections that were updated after the specified date, expressed in milliseconds since the epoch.\noffset | integer | no | The number of detections to skip for pagination.\nsort | array[detection_search_sort] | no | Sorts returned detections by the specified fields. By default, detections are sorted by most recent update time and then ID in ascending order.\nuntil | integer | no | Return detections that ended before the specified date, expressed in milliseconds since the epoch.\nupdate_time | integer | no | Returns detections related to events that occurred after the specified date, expressed in milliseconds since the epoch. Note that the ExtraHop Machine Learning Service analyzes historical data to generate detections, and so there is a time delay between when the events that cause those detections occur and when the detections are generated. If you search for detections in the same update_time window multiple times, the later search might return detections that were not returned by the earlier search.\n detection_search_filter\n\nname | type | required | description\n-----|------|----------|------------\nassignee | array[string] | no | Returns detections assigned to the specified user. Specify \".none\" to search for unassigned detections or specify \".me\" to search for detections assigned to the authenticated user.\ncategories | array[string] | no | Return detections from the specified categories.\ncategory | string | no | Deprecated. Replaced by the categories field.\nrecommended | boolean | no | Returns detections recommended for triage. This field is valid only on a console.\nresolution | array[string] | no | Returns detections for tickets with the specified resolution. Specify \".none\" to search for detections without resolutions. \u003cbr\u003e**Supported values:** \"action_taken\", \"no_action_taken\"\nrisk_score_min | integer | no | Returns detections with risk scores greater than or equal to the specified value.\nstatus | array[string] | no | Returns detections with the specified status. To search for detections with a null status, which is displayed in the ExtraHop system as Open, specify \".none\". You can only change the status of a detection to \"new\" through the REST API when [third party ticket tracking is enabled](https://docs.extrahop.com/9.8/detections-configure-ticket-tracking/#configure-third-party-ticket-tracking-for-detections). \u003cbr\u003e**Supported values:** \"new\", \"in_progress\", \"closed\", \"acknowledged\"\nticket_id | array[string] | no | Returns detections that are associated with the specified tickets. Specify \".none\" to search for detections that are not associated with tickets.\ntypes | array[string] | no | Returns detections with the specified types.\n\n detection_search_sort\n\nname | type | required | description\n-----|------|----------|------------\ndirection | string | no | The order in which returned detections are sorted. \u003cbr\u003e**Supported values:** \"asc\", \"desc\"\nfield | string | yes | The field to sort detections by.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The detection search parameters.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/detection_search_params"
                        }
                    }
                ],
                "operationId": "createDetectionsSearch",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "400": {
                        "description": "The search criteria is invalid.",
                        "schema": {
                            "$ref": "#/definitions/invalid_search"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/tickets": {
            "patch": {
                "summary": "Update a ticket associated with detections. This operation is available only if detections are tracked from an external ticketing system.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassignee | string | no | The assignee of the ticket associated with the detection.\nresolution | string | no | The resolution of the ticket associated with the detection. \u003cbr\u003e**Supported values:** \"action_taken\", \"no_action_taken\"\nstatus | string | no | The status of the ticket associated with the detection. \u003cbr\u003e**Supported values:** \"new\", \"in_progress\", \"closed\", \"acknowledged\"\nticket_id | string | yes | The ID of the ticket associated with the detection.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The detection ticketing values to update.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/detection_update_ticket_params"
                        }
                    }
                ],
                "operationId": "updateDetectionsTickets",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/{id}": {
            "get": {
                "summary": "Retrieve a specific detection.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the detection.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDetectionsId",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "A single Detections object",
                        "schema": {
                            "$ref": "#/definitions/Detections"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a detection.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassignee | string | no | The assignee of the detection or the ticket associated with the detection.\nparticipants | array[detection_update_participant_params] | no | A list of devices and applications associated with the detection. You can modify specific fields for a participant, but you cannot add new participants to a detection.\nresolution | string | no | The resolution of the detection or the ticket associated with the detection. \u003cbr\u003e**Supported values:** \"action_taken\", \"no_action_taken\"\nstatus | string | no | The status of the detection or the ticket associated with the detection. If the value is null, the status displayed in the ExtraHop system is Open. The value \"new\" can only be specified through the REST API when [third party ticket tracking is enabled](https://docs.extrahop.com/9.8/detections-configure-ticket-tracking/#configure-third-party-ticket-tracking-for-detections). \u003cbr\u003e**Supported values:** \"new\", \"in_progress\", \"closed\", \"acknowledged\"\nticket_id | string | yes | The ID of the ticket associated with the detection.\n detection_update_participant_params\n\nname | type | required | description\n-----|------|----------|------------\nid | integer | yes | The ID of the participant associated with the detection.\norigins | array[string] | no | The origin IP addresses associated with the participant through the REST API.\nusernames | array[string] | no | The usernames associated with the participant through the REST API.\n",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the detection.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The detection parameters to update.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/detection_update_params"
                        }
                    }
                ],
                "operationId": "updateDetectionsId",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "204": {
                        "description": "Detection successfully updated."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/{id}/investigations": {
            "get": {
                "summary": "Retrieve all investigations that a specific detection is in.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The ID of the detection to retrieve related investigations for.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDetectionsIdInvestigations",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "A single Detections object",
                        "schema": {
                            "$ref": "#/definitions/Detections"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/{id}/notes": {
            "delete": {
                "summary": "Delete the notes for a given detection. This operation is available only if detections are tracked from an external ticketing system.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the detection.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteDetectionsIdNotes",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve the notes for a given detection. This operation is available only if detections are tracked from an external ticketing system.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the detection.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDetectionsIdNotes",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "A single DetectionsNotes object",
                        "schema": {
                            "$ref": "#/definitions/DetectionsNotes"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Create or replace notes for a given detection. This operation is available only if detections are tracked from an external ticketing system.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nnote | string | no | The note associated with the detection.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the detection.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The detection note parameters.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/DetectionsNotes_REPLACE"
                        }
                    }
                ],
                "operationId": "replaceDetectionsIdNotes",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/detections/{id}/related": {
            "get": {
                "summary": "Retrieve all detections related to a specific detection.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The ID of the detection to retrieve related detections for.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "from",
                        "in": "query",
                        "description": "Returns detections that occurred after the specified date, expressed in milliseconds since the epoch. Detections that started before the specified date are returned if the detection was ongoing at that time.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "until",
                        "in": "query",
                        "description": "Return detections that ended before the specified date, expressed in milliseconds since the epoch.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDetectionsIdRelated",
                "tags": [
                    "Detections"
                ],
                "responses": {
                    "200": {
                        "description": "A single Detections object",
                        "schema": {
                            "$ref": "#/definitions/Detections"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups": {
            "get": {
                "summary": "Retrieve all device groups.",
                "parameters": [
                    {
                        "name": "since",
                        "in": "query",
                        "description": "Only return device groups that were modified after this time, expressed in milliseconds since the epoch.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "all",
                        "in": "query",
                        "description": "Deprecated. Replaced by the type parameter.",
                        "required": false,
                        "type": "boolean"
                    },
                    {
                        "name": "name",
                        "in": "query",
                        "description": "The Regex search value to filter the device groups by name.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "type",
                        "in": "query",
                        "description": "Only return device groups of the specified type.",
                        "required": false,
                        "type": "string",
                        "enum": [
                            "user_created",
                            "built_in",
                            "all"
                        ]
                    }
                ],
                "operationId": "getAllAssignedDevicegroups",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DeviceGroup objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceGroup"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new device group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | An optional description of the device group.\ndynamic | boolean | no | Indicates whether the device group is dynamic.\neditors | array[string] | no | The list of users that can edit the device group.\nfield | string | no | Deprecated. Replaced by the filter parameter. \u003cbr\u003e**Supported values:** \"any\", \"name\", \"ip address\", \"mac address\", \"vendor\", \"type\", \"tag\", \"vlan\", \"activity\", \"node\", \"discover time\"\nfilter | group_filter | no | Specify the filter criteria for search results.\ninclude_custom_devices | boolean | no | Deprecated. Replaced by the filter parameter.\nname | string | yes | The friendly name for the device group.\nvalue | string | no | Deprecated. Replaced by the filter parameter.\n group_filter\n\nname | type | required | description\n-----|------|----------|------------\nfield | string | no | The name of the field to filter results on. The search compares the contents of the field parameter to the value of the operand parameter. \u003cbr\u003e**Supported values:** \"name\", \"ipaddr\", \"macaddr\", \"vendor\", \"tag\", \"activity\", \"node\", \"vlan\", \"discover_time\", \"role\", \"dns_name\", \"dhcp_name\", \"netbios_name\", \"cdp_name\", \"custom_name\", \"software\", \"model\", \"is_critical\", \"instance_id\", \"instance_name\", \"instance_type\", \"cloud_account\", \"vpc_id\", \"subnet_id\", \"is_active\", \"network_locality_type\", \"network_locality_id\", \"id\"\noperand | string or integer or object | no | The value that the query attempts to match. The query compares the value of the operand to the contents of the field parameter and applies the compare method specified by the operator parameter. You can specify the operand as a string, integer, or object. For information about object values, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#operand-values-for-device-groups).\noperator | string | yes | The compare method applied when matching the operand value against the field contents. All filter objects require an operator. \u003cbr\u003e**Supported values:** \"\u003e\", \"\u003c\", \"\u003c=\", \"\u003e=\", \"=\", \"!=\", \"startswith\", \"and\", \"or\", \"not\", \"exists\", \"not_exists\", \"~\", \"!~\"\nrules | array[group_filter] | no | An array of one or more filter objects, which can be embedded recursively. Only \"and\", \"or\", and \"not\" operators are allowed for this parameter.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property values to the new device group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/device_group_settings"
                        }
                    }
                ],
                "operationId": "createDevicegroups",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups/{id}": {
            "delete": {
                "summary": "Delete a specific device group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteDevicegroupsId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific device group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDevicegroupsId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "200": {
                        "description": "A single DeviceGroup object",
                        "schema": {
                            "$ref": "#/definitions/DeviceGroup"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific device group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | An optional description of the device group.\neditors | array[string] | no | The list of users that can edit the device group.\nfield | string | no | Deprecated. Replaced by the filter parameter. \u003cbr\u003e**Supported values:** \"any\", \"name\", \"ip address\", \"mac address\", \"vendor\", \"type\", \"tag\", \"vlan\", \"activity\", \"node\", \"discover time\"\nfilter | group_filter | no | Specify the filter criteria for search results.\ninclude_custom_devices | boolean | no | Deprecated. Replaced by the filter parameter.\nname | string | yes | The friendly name for the device group.\nvalue | string | no | Deprecated. Replaced by the filter parameter.\n group_filter\n\nname | type | required | description\n-----|------|----------|------------\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to a specific device group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/device_group_settings"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateDevicegroupsId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups/{id}/alerts": {
            "get": {
                "summary": "Retrieve all alerts assigned to a specific device group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "direct_assignments_only",
                        "in": "query",
                        "description": "Restrict results to only alerts that are directly assigned to the device group.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getAllAssignedDevicegroupsIdAlerts",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Alert objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Alert"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign alerts to a specific device group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for alerts that is assigned and unassigned to the device group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsDevicegroupsIdAlerts",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups/{id}/alerts/{child-id}": {
            "delete": {
                "summary": "Unassign an alert from a specific device group.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignDevicegroupsIdAlertsChildId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign an alert to a specific device group.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignDevicegroupsIdAlertsChildId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups/{id}/dashboards": {
            "get": {
                "summary": "Retrieve all dashboards related to a specific device group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedDevicegroupsIdDashboards",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Dashboard objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Dashboard"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups/{id}/devices": {
            "get": {
                "summary": "Retrieve all devices in the device group that were active within a specific time window.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "active_from",
                        "in": "query",
                        "description": "The beginning timestamp for the request. Return only devices active after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--35) for supported time units and suffixes.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "active_until",
                        "in": "query",
                        "description": "The ending timestamp for the request. Return only device active before this time. Follows the same time value guidelines as the active_from parameter.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "limit",
                        "in": "query",
                        "description": "Limit the number of devices returned.",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "default": 100
                    },
                    {
                        "name": "offset",
                        "in": "query",
                        "description": "Skip the first n device results. This parameter is often combined with the limit parameter.",
                        "required": false,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedDevicegroupsIdDevices",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Device objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Device"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign devices to a specific static device group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for devices that is assigned and unassigned to the device group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsDevicegroupsIdDevices",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups/{id}/devices/{child-id}": {
            "delete": {
                "summary": "Unassign a device to a specific static device group.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for a device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignDevicegroupsIdDevicesChildId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a device to a specific static device group.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for a device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignDevicegroupsIdDevicesChildId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups/{id}/triggers": {
            "get": {
                "summary": "Retrieve all triggers assigned to a specific device group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "direct_assignments_only",
                        "in": "query",
                        "description": "Restrict results to only triggers that are directly assigned to the device group.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getAllAssignedDevicegroupsIdTriggers",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Trigger objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Trigger"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign triggers to a specific device group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for triggers that is assigned and unassigned to the device group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsDevicegroupsIdTriggers",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devicegroups/{id}/triggers/{child-id}": {
            "delete": {
                "summary": "Unassign a trigger from a specific device group.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignDevicegroupsIdTriggersChildId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a trigger to a specific device group.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignDevicegroupsIdTriggersChildId",
                "tags": [
                    "Device Group"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices": {
            "get": {
                "summary": "Deprecated. Replaced by the POST /devices/search operation.",
                "parameters": [
                    {
                        "name": "active_from",
                        "in": "query",
                        "description": "The beginning timestamp for the request. Return only devices active after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "active_until",
                        "in": "query",
                        "description": "The ending timestamp for the request. Return only device active before this time. Follows the same time value guidelines as the active_from parameter.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "limit",
                        "in": "query",
                        "description": "Limit the number of devices returned to the specified maximum number.",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "default": 100
                    },
                    {
                        "name": "offset",
                        "in": "query",
                        "description": "Skip the first n device results. This parameter is often combined with the limit parameter.",
                        "required": false,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "search_type",
                        "in": "query",
                        "description": "Indicates the field to search.",
                        "required": true,
                        "type": "string",
                        "enum": [
                            "any",
                            "name",
                            "discovery_id",
                            "ip address",
                            "mac address",
                            "vendor",
                            "type",
                            "tag",
                            "activity",
                            "node",
                            "vlan",
                            "discover time"
                        ],
                        "default": "any"
                    },
                    {
                        "name": "value",
                        "in": "query",
                        "description": "Specifies the search criteria.",
                        "required": false,
                        "type": "string"
                    }
                ],
                "operationId": "getAllAssignedDevices",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Device objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Device"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/search": {
            "post": {
                "summary": "Retrieve all active devices that match specific criteria.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nactive_from | integer or string | no | The beginning timestamp for the request. Return only devices active after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes.\nactive_until | integer or string | no | The ending timestamp for the request. Return only devices active before this time. Follows the same time value guidelines as the active_from parameter.\nfilter | search_filter | no | Specify the filter criteria for search results.\nlimit | integer | no | Limit the number of devices returned to the specified maximum number.\noffset | integer | no | Skip the specified number of devices. This parameter is often combined with the limit parameter to paginate result sets.\nresult_fields | array[string] | no | Returns the specified fields and the device id. If this option is not specified, all fields are returned. \u003cbr\u003e**Supported values:** \"mod_time\", \"node_id\", \"id\", \"extrahop_id\", \"discovery_id\", \"display_name\", \"description\", \"user_mod_time\", \"discover_time\", \"vlanid\", \"parent_id\", \"macaddr\", \"vendor\", \"is_l3\", \"ipaddr4\", \"ipaddr6\", \"device_class\", \"default_name\", \"custom_name\", \"cdp_name\", \"dhcp_name\", \"netbios_name\", \"dns_name\", \"custom_type\", \"auto_role\", \"analysis_level\", \"analysis\", \"role\", \"on_watchlist\", \"last_seen_time\", \"activity\", \"model\", \"model_override\", \"custom_make\", \"custom_model\", \"critical\", \"custom_criticality\", \"cloud_instance_id\", \"cloud_instance_type\", \"cloud_instance_description\", \"cloud_instance_name\", \"cloud_account\", \"vpc_id\", \"subnet_id\"\n search_filter\n\nname | type | required | description\n-----|------|----------|------------\nfield | string | no | The name of the field to filter results on. The search compares the contents of the field parameter to the value of the operand parameter. \u003cbr\u003e**Supported values:** \"name\", \"discovery_id\", \"ipaddr\", \"macaddr\", \"vendor\", \"tag\", \"activity\", \"node\", \"vlan\", \"discover_time\", \"role\", \"dns_name\", \"dhcp_name\", \"netbios_name\", \"cdp_name\", \"custom_name\", \"software\", \"software_type\", \"model\", \"is_critical\", \"instance_id\", \"instance_name\", \"instance_type\", \"cloud_account\", \"vpc_id\", \"subnet_id\", \"is_active\", \"analysis\", \"network_locality_type\", \"network_locality_id\", \"id\"\noperand | integer or object or array or string | no | The value that the query attempts to match. The query compares the value of the operand to the contents of the field parameter and applies the compare method specified by the operator parameter. You can specify the operand as a string, integer, or object. For information about object values, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#operand-values-for-device-search).\noperator | string | yes | The compare method applied when matching the operand value against the field contents. All filter objects require an operator. \u003cbr\u003e**Supported values:** \"\u003e\", \"\u003c\", \"\u003c=\", \"\u003e=\", \"=\", \"!=\", \"startswith\", \"and\", \"or\", \"not\", \"exists\", \"not_exists\", \"~\", \"!~\", \"in\", \"not_in\"\nrules | array[search_filter] | no | An array of one or more filter objects, which can be embedded recursively. Only \"and\", \"or\", and \"not\" operators are allowed for this parameter.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The device criteria.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/device_search"
                        }
                    }
                ],
                "operationId": "createDevicesSearch",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "The request was successful."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}": {
            "get": {
                "summary": "Retrieve a specific device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getDevicesId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "A single Device object",
                        "schema": {
                            "$ref": "#/definitions/Device"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific device.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncloud_account | string | no | The cloud account that this device is associated with. If you configure this device property from a console, the device property on connected sensors gets overwritten.\ncloud_instance_description | string | no | The description of the device defined by the cloud service provider. If you configure this device property from a console, the device property on connected sensors gets overwritten.\ncloud_instance_id | string | no | The cloud instance ID of the device.\ncloud_instance_name | string | no | The cloud instance name of the device. If you configure this device property from a console, the device property on connected sensors gets overwritten.\ncloud_instance_type | string | no | The cloud instance type of the device. If you configure this device property from a console, the device property on connected sensors gets overwritten.\ncustom_criticality | string | no | Indicates whether a user manually specified the device as high value or not high value. An empty string indicates that the high value setting is automatically determined by the ExtraHop system. \u003cbr\u003e**Supported values:** \"critical\", \"not_critical\", \"\"\ncustom_make | string | no | The manually specified make for a device.\ncustom_model | string | no | The manually specified model for a device.\ncustom_name | string | no | The friendly name for this device.\ncustom_type | string | yes | Updates the device role. \u003cbr\u003e**Supported values:** \"attack_simulator\", \"db_server\", \"dhcp_server\", \"dns_server\", \"domain_controller\", \"file_server\", \"firewall\", \"gateway\", \"http_server\", \"ip_camera\", \"load_balancer\", \"medical_device\", \"mobile_device\", \"nat_gateway\", \"other\", \"pc\", \"printer\", \"scanner\", \"voip_phone\", \"vpn_gateway\", \"web_proxy\", \"wifi_ap\", \"\"\ndescription | string | no | An optional description for the device.\nsubnet_id | string | no | The identifier of the subnet that this device is on. If you configure this device property from a console, the device property on connected sensors gets overwritten.\nvendor | string | no | The name of the vendor who created this device.\nvpc_id | string | no | The VPC that this device is in. If you configure this device property from a console, the device property on connected sensors gets overwritten.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to the device.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Device_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateDevicesId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Successfully updated the device."
                    },
                    "400": {
                        "description": "The specified device update is invalid."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/activity": {
            "get": {
                "summary": "Retrieve all activity for a device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdActivity",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DeviceActivity objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceActivity"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/alerts": {
            "get": {
                "summary": "Retrieve all alerts that are assigned to a specific device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "direct_assignments_only",
                        "in": "query",
                        "description": "Restrict results to only alerts that are directly assigned to the device.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdAlerts",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Alert objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Alert"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific device to alerts.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for alerts that are assigned and unassigned to the device.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsDevicesIdAlerts",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/alerts/{child-id}": {
            "delete": {
                "summary": "Unassign an alert from a specific device.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignDevicesIdAlertsChildId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign an alert to a specific device.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignDevicesIdAlertsChildId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/dashboards": {
            "get": {
                "summary": "Retrieve all dashboards related to a specific device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdDashboards",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Dashboard objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Dashboard"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/devicegroups": {
            "get": {
                "summary": "Retrieve all device groups that are assigned to a specific device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "active_from",
                        "in": "query",
                        "description": "The beginning timestamp for the request. Return only dynamic device groups that the device belonged to after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "active_until",
                        "in": "query",
                        "description": "The ending timestamp for the request. Return only dynamic device groups that the device belonged to before this time. Follows the same time value guidelines as the active_from parameter.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdDevicegroups",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DeviceGroup objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceGroup"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific device to device groups.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The list of unique identifiers for device groups that are assigned and unassigned to the device.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsDevicesIdDevicegroups",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/devicegroups/{child-id}": {
            "delete": {
                "summary": "Unassign a device group from a specific device.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignDevicesIdDevicegroupsChildId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a device group to a specific device.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignDevicesIdDevicegroupsChildId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/dnsnames": {
            "get": {
                "summary": "Retrieve all DNS names that are associated with a specific device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "from",
                        "in": "query",
                        "description": "Retrieves DNS names that were associated with the device after the specified date, expressed in milliseconds since the epoch.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "until",
                        "in": "query",
                        "description": "Retrieves DNS names that were associated with the device before the specified date, expressed in milliseconds since the epoch.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdDnsnames",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DeviceDNSNameObservation objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceDNSNameObservation"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/ipaddrs": {
            "get": {
                "summary": "Retrieve all IP addresses that are associated with a specific device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "from",
                        "in": "query",
                        "description": "Retrieves IP addresses that were associated with the device after the specified date, expressed in milliseconds since the epoch.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "until",
                        "in": "query",
                        "description": "Retrieves IP addresses that were associated with the device before the specified date, expressed in milliseconds since the epoch.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdIpaddrs",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DeviceIPAddressObservation objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceIPAddressObservation"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/software": {
            "get": {
                "summary": "Retrieve a list of software running on the specified device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "from",
                        "in": "query",
                        "description": "Returns software that was observed on the device after the specified date, expressed in milliseconds since the epoch.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "until",
                        "in": "query",
                        "description": "Returns software that was observed on the device before the specified date, expressed in milliseconds since the epoch.",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdSoftware",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Software objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Software"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/tags": {
            "get": {
                "summary": "Retrieve all tags assigned to a specific device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdTags",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Tag objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Tag"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific device to tags.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "A list of unique identifiers for tags that are assigned and unassigned to the device.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsDevicesIdTags",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/tags/{child-id}": {
            "delete": {
                "summary": "Unassign a tag from a specific device.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignDevicesIdTagsChildId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a tag to a specific device.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignDevicesIdTagsChildId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/triggers": {
            "get": {
                "summary": "Retrieve all triggers that are assigned to a specific device.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "direct_assignments_only",
                        "in": "query",
                        "description": "Restrict results to only triggers that are directly assigned to the device.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getAllAssignedDevicesIdTriggers",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Trigger objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Trigger"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific device to triggers.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "A list of unique identifiers for triggers that are assigned and unassigned to the device.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsDevicesIdTriggers",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/devices/{id}/triggers/{child-id}": {
            "delete": {
                "summary": "Unassign a trigger from a specific device.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignDevicesIdTriggersChildId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a trigger to a specific device.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignDevicesIdTriggersChildId",
                "tags": [
                    "Device"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/emailgroups": {
            "get": {
                "summary": "Retrieve all email groups.",
                "operationId": "getAllAssignedEmailgroups",
                "tags": [
                    "Email Group"
                ],
                "responses": {
                    "200": {
                        "description": "An array of EmailGroup objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/EmailGroup"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new email group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nemail_addresses | array[string] | yes | The list of email addresses in the email group.\ngroup_name | string | yes | The friendly name for the email group.\nsystem_notifications | boolean | yes | Indicates whether that the group should receive system notifications.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property values to the new email group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/EmailGroup_CREATE"
                        }
                    }
                ],
                "operationId": "createEmailgroups",
                "tags": [
                    "Email Group"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/emailgroups/{id}": {
            "delete": {
                "summary": "Delete a specific email group by a unique identifier.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the email group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteEmailgroupsId",
                "tags": [
                    "Email Group"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific email group by a unique identifier.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier of the email group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getEmailgroupsId",
                "tags": [
                    "Email Group"
                ],
                "responses": {
                    "200": {
                        "description": "A single EmailGroup object",
                        "schema": {
                            "$ref": "#/definitions/EmailGroup"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Apply updates to a specific email group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nemail_addresses | array[string] | yes | The list of email addresses in the email group.\ngroup_name | string | yes | The friendly name for the email group.\nsystem_notifications | boolean | yes | Indicates whether that the group should receive system notifications.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to the email group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/EmailGroup_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the email group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateEmailgroupsId",
                "tags": [
                    "Email Group"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/exclusionintervals": {
            "get": {
                "summary": "Retrieve all exclusion intervals.",
                "operationId": "getAllAssignedExclusionintervals",
                "tags": [
                    "Exclusion Interval"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ExclusionInterval objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/ExclusionInterval"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new exclusion interval.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nalert_apply_all | boolean | yes | Indicates whether this exclusion interval should be applied to all alerts.\nauthor | string | no | The name of the creator of the exclusion interval.\ndescription | string | no | An optional description of the exclusion interval.\nend | integer | yes | The end of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions.\ninterval_type | string | yes | The time window when the exclusion interval was evaluated. \u003cbr\u003e**Supported values:** \"onetime\", \"weekly\", \"daily\"\nname | string | yes | The friendly name for the exclusion interval.\nstart | integer | yes | The start of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions.\ntrend_apply_all | boolean | yes | Indicates whether this exclusion interval should be applied to all trends.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Set the specified property values on the new exclusion interval.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ExclusionInterval_CREATE"
                        }
                    }
                ],
                "operationId": "createExclusionintervals",
                "tags": [
                    "Exclusion Interval"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/exclusionintervals/{id}": {
            "delete": {
                "summary": "Delete a specific exclusion interval.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier of the exclusion interval.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteExclusionintervalsId",
                "tags": [
                    "Exclusion Interval"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific exclusion interval.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier of the exclusion interval.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getExclusionintervalsId",
                "tags": [
                    "Exclusion Interval"
                ],
                "responses": {
                    "200": {
                        "description": "A single ExclusionInterval object",
                        "schema": {
                            "$ref": "#/definitions/ExclusionInterval"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Apply updates to a specific exclusion interval.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nalert_apply_all | boolean | yes | Indicates whether this exclusion interval should be applied to all alerts.\nauthor | string | no | The name of the creator of the exclusion interval.\ndescription | string | no | An optional description of the exclusion interval.\nend | integer | yes | The end of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions.\ninterval_type | string | yes | The time window when the exclusion interval was evaluated. \u003cbr\u003e**Supported values:** \"onetime\", \"weekly\", \"daily\"\nname | string | yes | The friendly name for the exclusion interval.\nstart | integer | yes | The start of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions.\ntrend_apply_all | boolean | yes | Indicates whether this exclusion interval should be applied to all trends.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to the exclusion interval.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ExclusionInterval_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the exclusion interval.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateExclusionintervalsId",
                "tags": [
                    "Exclusion Interval"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop": {
            "get": {
                "summary": "Retrieve metadata about the firmware running on the appliance.",
                "operationId": "getExtrahop",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object containing metadata about the firmware running on the appliance.",
                        "schema": {
                            "$ref": "#/definitions/extrahop_info"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "500": {
                        "description": "An internal server error occurred."
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/cloudresources": {
            "post": {
                "summary": "Manually update resources on the ExtraHop system. These resources are automatically updated when the system is connected to ExtraHop Cloud Services.",
                "parameters": [
                    {
                        "name": "cloudresources",
                        "in": "path",
                        "description": "The resource bundle file.",
                        "required": true,
                        "type": "file",
                        "format": "file"
                    }
                ],
                "consumes": [
                    "application/tar"
                ],
                "operationId": "createExtrahopCloudresources",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/detections/access": {
            "get": {
                "summary": "Retrieve the detections access control settings.",
                "operationId": "getExtrahopDetectionsAccess",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object containing the detections access setting on the appliance.",
                        "schema": {
                            "$ref": "#/definitions/detection_access_params"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Update detections access control settings.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nenabled | boolean | yes | Indicates whether detections access settings are enabled. When enabled, administrators can restrict detections access for specified users. You cannot disable detections access settings after the settings are enabled.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The detections access settings for the appliance.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/detection_access_params"
                        }
                    }
                ],
                "operationId": "replaceExtrahopDetectionsAccess",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/edition": {
            "get": {
                "summary": "Retrieve the system edition of the appliance.",
                "operationId": "getExtrahopEdition",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object containing a value that indicates the edition of the appliance.",
                        "schema": {
                            "$ref": "#/definitions/extrahop_edition"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/firmware": {
            "post": {
                "summary": "Upload a new firmware image to the appliance.",
                "parameters": [
                    {
                        "name": "firmware",
                        "in": "path",
                        "description": "The .tar file that contains the firmware image. Note: You cannot upload a firmware image through the REST API explorer. For more information about how to upload an image through cURL or a Python script, see [Upgrade ExtraHop firmware through the REST API](https://docs.extrahop.com/9.8/rest-upgrade-firmware/).",
                        "required": true,
                        "type": "file",
                        "format": "file"
                    }
                ],
                "consumes": [
                    "application/vnd.extrahop.firmware"
                ],
                "operationId": "createExtrahopFirmware",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "201": {
                        "description": "The firmware image file was successfully uploaded and validated.",
                        "schema": {
                            "$ref": "#/definitions/firmware_upload_success"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "415": {
                        "description": "The HTTP request did not specify application/vnd.extrahop.firmware as the content-type.",
                        "schema": {
                            "$ref": "#/definitions/firmware_upload_unsupported_media"
                        }
                    },
                    "422": {
                        "description": "The firmware image file is invalid or the appliance does not contain enough free space to store the file.",
                        "schema": {
                            "$ref": "#/definitions/firmware_upload_unprocessable_entity"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/firmware/download/url": {
            "post": {
                "summary": "Download a new firmware image onto the appliance from a URL.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nfirmware_url | string | yes | The URL of the firmware to download. HTTPS, HTTP, and FTP schemes are supported.\nforce | boolean | no | Specifies whether to skip compatibility verification. Skip verification only if ExtraHop Support has reviewed and approved the upgrade.\nupgrade | boolean | no | Specifies whether to upgrade the appliance after the firmware download is complete.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The download options.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/firmware_url_download_parameters"
                        }
                    }
                ],
                "operationId": "createExtrahopFirmwareDownloadUrl",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "202": {
                        "description": "The request was successful, and a job was created for downloading the firmware.",
                        "headers": {
                            "location": {
                                "description": "The relative URL that you can retrieve the status of the job from.",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The download process failed to start.",
                        "schema": {
                            "$ref": "#/definitions/firmware_download_unprocessable_entity"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/firmware/download/version": {
            "post": {
                "summary": "Download a new firmware image onto the appliance from ExtraHop Cloud Services.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nupgrade | boolean | no | Specifies whether to upgrade the appliance after the firmware download is complete.\nversion | string | yes | The version of the firmware to download.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The download options.",
                        "required": false,
                        "schema": {
                            "$ref": "#/definitions/firmware_hopcloud_download_parameters"
                        }
                    }
                ],
                "operationId": "createExtrahopFirmwareDownloadVersion",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "202": {
                        "description": "The request was successful, and a job was created for downloading the firmware.",
                        "headers": {
                            "location": {
                                "description": "The relative URL that you can retrieve the status of the job from.",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The download process failed to start.",
                        "schema": {
                            "$ref": "#/definitions/firmware_download_unprocessable_entity"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/firmware/latest/upgrade": {
            "post": {
                "summary": "Upgrade the appliance to the most recently uploaded firmware image.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nforce | boolean | no | Specifies whether to skip compatibility verification. Skip verification only if ExtraHop Support has reviewed and approved the upgrade.\nrestart_after | boolean | no | Indicates whether to restart the appliance after the upgrade is complete.\nsilent | boolean | no | Specifies whether to disable the ExtraHop Web UI during the upgrade process. If an upgrade fails, the appliance will automatically revert to the previous firmware version.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The installation options for upgrading the appliance.",
                        "required": false,
                        "schema": {
                            "$ref": "#/definitions/firmware_upgrade_parameters"
                        }
                    }
                ],
                "operationId": "createExtrahopFirmwareLatestUpgrade",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "202": {
                        "description": "The request was successful, and a job was created for upgrading the firmware.",
                        "schema": {
                            "$ref": "#/definitions/firmware_upgrade_success"
                        },
                        "headers": {
                            "location": {
                                "description": "The relative URL that you can retrieve the status of the job from.",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "Unable to start upgrade process.",
                        "schema": {
                            "$ref": "#/definitions/firmware_upgrade_unprocessable_entity"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/firmware/next": {
            "get": {
                "summary": "Retrieve the list of firmware versions that you can upgrade the appliance to from ExtraHop Cloud Services.",
                "operationId": "getAllAssignedExtrahopFirmwareNext",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ExtraHopFirmwareRelease objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/ExtraHopFirmwareRelease"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/firmware/previous": {
            "get": {
                "summary": "Retrieve information about a firmware version that you can roll back the appliance to.",
                "operationId": "getExtrahopFirmwarePrevious",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "Information about a previous firmware version that you can roll back the appliance to.",
                        "schema": {
                            "$ref": "#/definitions/firmware_rollback_info"
                        }
                    },
                    "400": {
                        "description": "You cannot roll back to a previous firmware version because no previous version exists on the appliance.",
                        "schema": {
                            "$ref": "#/definitions/firmware_rollback_error"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/firmware/previous/rollback": {
            "post": {
                "summary": "Roll back the appliance to the previous firmware version. Rolling back the firmware resets the datastore and removes all metrics. Connected appliances are unaffected.",
                "operationId": "createExtrahopFirmwarePreviousRollback",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "202": {
                        "description": "The firmware rollback process started."
                    },
                    "400": {
                        "description": "The firmware could not be rolled back.",
                        "schema": {
                            "$ref": "#/definitions/firmware_rollback_error"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/flowlogs/secret": {
            "get": {
                "summary": "Retrieve the flow log secret",
                "operationId": "getExtrahopFlowlogsSecret",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object that contains the secret required to send flow logs to the sensor.",
                        "schema": {
                            "$ref": "#/definitions/flowlogs_secret_response"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Generate a new flow log secret",
                "operationId": "createExtrahopFlowlogsSecret",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object that contains the secret required to send flow logs to the sensor.",
                        "schema": {
                            "$ref": "#/definitions/flowlogs_secret_response"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/idrac": {
            "get": {
                "summary": "Retrieve the iDRAC IP address of the appliance.",
                "operationId": "getExtrahopIdrac",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object containing the iDRAC IP address of the appliance.",
                        "schema": {
                            "$ref": "#/definitions/extrahop_idrac"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/platform": {
            "get": {
                "summary": "Retrieve the platform name of the appliance.",
                "operationId": "getExtrahopPlatform",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object containing a value indicating the platform name of the appliance.",
                        "schema": {
                            "$ref": "#/definitions/extrahop_platform"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/processes": {
            "get": {
                "summary": "Retrieve a list of processes running on the appliance.",
                "operationId": "getAllAssignedExtrahopProcesses",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ExtraHopProcess objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/ExtraHopProcess"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/processes/{process}/restart": {
            "post": {
                "summary": "Restart a process running on the appliance.",
                "description": "You can only restart a process that is returned by `GET /extrahop/processes` with the `can_restart` property set to `true`.",
                "parameters": [
                    {
                        "name": "process",
                        "in": "path",
                        "description": "The name of the process.",
                        "required": true,
                        "type": "string",
                        "enum": [
                            "exadmin",
                            "exalerts",
                            "examf",
                            "exapi",
                            "exbridge",
                            "excap",
                            "exconfig",
                            "exflowlogs",
                            "exsnmpq",
                            "exnotify",
                            "exportal",
                            "exremote",
                            "exsearch",
                            "exstatmirror",
                            "extrend",
                            "webserver",
                            "hopcloud-api"
                        ]
                    }
                ],
                "operationId": "createExtrahopProcessesProcessRestart",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/restart": {
            "post": {
                "summary": "Restart the appliance.",
                "operationId": "createExtrahopRestart",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "202": {
                        "description": "The appliance is restarting."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/services": {
            "get": {
                "summary": "Retrieve settings for all services.",
                "operationId": "getExtrahopServices",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object containing the settings for services.",
                        "schema": {
                            "$ref": "#/definitions/service_settings"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update the settings for services.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nadmin | service_value | no | The settings of the Management GUI service, which provides browser-based access to the appliance.\nkeyreceiver | service_value | no | The settings of the SSL Session Key Receiver, which enables the appliance to receive and decrypt session keys from the session key forwarder.\nsnmp | service_value | no | The settings of the SNMP service, which enables your network device monitoring software to collect information from the ExtraHop System.\nssh | service_value | no | The settings of the SSH service, which enables users to securely log in to the ExtraHop command-line interface (CLI).\n service_value\n\nname | type | required | description\n-----|------|----------|------------\nenabled | boolean | yes | Indicates whether the service is enabled.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The settings for services.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service_settings"
                        }
                    }
                ],
                "operationId": "updateExtrahopServices",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "400": {
                        "description": "The specified settings are invalid.",
                        "schema": {
                            "$ref": "#/definitions/update_services_input_error"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "One or more of the specified services are not licensed on the appliance.",
                        "schema": {
                            "$ref": "#/definitions/update_services_unlicensed_error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error.",
                        "schema": {
                            "$ref": "#/definitions/update_services_internal_error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/shutdown": {
            "post": {
                "summary": "Shut down the appliance.",
                "operationId": "createExtrahopShutdown",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "202": {
                        "description": "The appliance is shutting down."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/sslcert": {
            "post": {
                "summary": "Regenerate the SSL certificate on the appliance.",
                "operationId": "createExtrahopSslcert",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful, and a job was created for generating the SSL certificate.",
                        "headers": {
                            "location": {
                                "description": "The relative URL that you can retrieve the status of the job from.",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Replace the SSL certificate on the appliance.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The SSL certificate and optionally the private key. Enter as plain text, separated with a line break.",
                        "required": true,
                        "schema": {
                            "type": "string",
                            "description": "The SSL certificate and optionally the private key. Enter as plain text, separated with a line break."
                        }
                    }
                ],
                "consumes": [
                    "text/plain"
                ],
                "operationId": "replaceExtrahopSslcert",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/sslcert/signingrequest": {
            "post": {
                "summary": "Create an SSL certificate signing request.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nsubject | certificate_subject | yes | The subject of the SSL certificate. For a list of certificate subject fields, see below.\nsubject_alternative_names | array[subject_alternative_name] | yes | A list of names that the certificate applies to, such as {\"type\": \"dns\", \"name\": \"www.example.com\"}.\n certificate_subject\n\nname | type | required | description\n-----|------|----------|------------\ncommon_name | string | yes | The subject common name (CN).\ncountry_code | string | no | The subject country (C).\nemail_address | string | no | The subject e-mail address (emailAddress).\nlocality_name | string | no | The subject locality (L).\norganization_name | string | no | The subject organization (O).\norganizational_unit_name | string | no | The subject organizational unit (OU).\nstate_or_province_name | string | no | The subject state or province (ST).\n\n subject_alternative_name\n\nname | type | required | description\n-----|------|----------|------------\nname | string | yes | Name of Subject Alternative Name.\ntype | string | yes | Type of Subject Alternative Name. \u003cbr\u003e**Supported values:** \"dns\", \"ip\"\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Parameters for the SSL certificate signing request.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/certificate_signing_request_parameters"
                        }
                    }
                ],
                "operationId": "createExtrahopSslcertSigningrequest",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "Returns the SSL certificate signing request.",
                        "schema": {
                            "$ref": "#/definitions/certificate_signing_request"
                        }
                    },
                    "400": {
                        "description": "The request parameters are invalid.",
                        "schema": {
                            "$ref": "#/definitions/bad_certificate_signing_request"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/ticketing": {
            "get": {
                "summary": "Retrieve the ticketing integration status.",
                "operationId": "getExtrahopTicketing",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "Request succeeded.",
                        "schema": {
                            "$ref": "#/definitions/ticket_tracking_parameters"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update ticket tracking settings.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nenabled | boolean | no | Deprecated. Replaced by the external_ticketing_enabled and internal_ticketing_enabled fields.\nexternal_ticketing_enabled | boolean | no | Indicates whether detections are tracked from an external ticketing system. This field is required if the internal_ticketing_enabled field is specified.\ninternal_ticketing_enabled | boolean | no | Indicates whether detections are tracked from within the ExtraHop System. This field is required if the external_ticketing_enabled field is specified.\nurl_template | string | no | The URL template that links detections to external tickets. The template must include the $ticket_id variable. This field applies only if detections are tracked from an external ticketing system.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Ticket tracking settings.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/ticket_tracking_parameters"
                        }
                    }
                ],
                "operationId": "updateExtrahopTicketing",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The specified ticket tracking parameters are invalid.",
                        "schema": {
                            "$ref": "#/definitions/bad_ticket_tracking_request"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/extrahop/version": {
            "get": {
                "summary": "Retrieve the firmware version running on the appliance.",
                "operationId": "getExtrahopVersion",
                "tags": [
                    "ExtraHop"
                ],
                "responses": {
                    "200": {
                        "description": "An object containing information about the firmware running on the appliance.",
                        "schema": {
                            "$ref": "#/definitions/extrahop_version"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/investigations": {
            "get": {
                "summary": "Retrieve all investigations.",
                "operationId": "getAllAssignedInvestigations",
                "tags": [
                    "Investigations"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Investigations objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Investigations"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create an investigation.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassessment | string | no | The assessment of the investigation. \u003cbr\u003e**Supported values:** \"malicious_true_positive\", \"benign_true_positive\", \"false_positive\", \"undecided\"\nassignee | string | no | The username of the investigation assignee.\nevent_ids | array[integer] | no | The list of IDs for detections in the investigation.\nname | string | yes | The name of the investigation.\nnotes | string | no | Optional notes about the investigation.\nstatus | string | no | The status of the investigation. \u003cbr\u003e**Supported values:** \"open\", \"in_progress\", \"closed\"",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The fields of the new investigation.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/investigation_create_params"
                        }
                    }
                ],
                "operationId": "createInvestigations",
                "tags": [
                    "Investigations"
                ],
                "responses": {
                    "400": {
                        "description": "The specified parameters for the investigation are invalid.",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/investigations/search": {
            "post": {
                "summary": "Search for investigations.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncreation_time | integer | no | Returns investigations that were created after the specified date, expressed in milliseconds since the epoch.\nis_user_created | boolean | no | Returns only investigations that were created manually by a user.\nupdate_time | integer | no | Returns investigations that were updated after the specified date, expressed in milliseconds since the epoch.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The parameters for the investigation.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/investigation_search_params"
                        }
                    }
                ],
                "operationId": "createInvestigationsSearch",
                "tags": [
                    "Investigations"
                ],
                "responses": {
                    "400": {
                        "description": "The search criteria is invalid.",
                        "schema": {
                            "$ref": "#/definitions/invalid_search"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/investigations/{id}": {
            "delete": {
                "summary": "Delete a specific investigation.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The ID of the investigation to delete.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteInvestigationsId",
                "tags": [
                    "Investigations"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific investigation.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the investigation.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getInvestigationsId",
                "tags": [
                    "Investigations"
                ],
                "responses": {
                    "200": {
                        "description": "A single Investigations object",
                        "schema": {
                            "$ref": "#/definitions/Investigations"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update an investigation.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassessment | string | no | The assessment of the investigation. \u003cbr\u003e**Supported values:** \"malicious_true_positive\", \"benign_true_positive\", \"false_positive\", \"undecided\"\nassignee | string | no | The username of the investigation assignee.\nevent_ids | array[integer] | no | The list of IDs for detections in the investigation. If you specify this field, the new list of IDs replaces the existing list.\nname | string | no | The name of the investigation.\nnotes | string | no | Optional notes about the investigation.\nstatus | string | no | The status of the investigation. \u003cbr\u003e**Supported values:** \"open\", \"in_progress\", \"closed\"",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The ID of the investigation to update.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The investigation fields to update.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/investigation_update_params"
                        }
                    }
                ],
                "operationId": "updateInvestigationsId",
                "tags": [
                    "Investigations"
                ],
                "responses": {
                    "204": {
                        "description": "Investigation successfully updated."
                    },
                    "400": {
                        "description": "The specified parameters for the investigation are invalid.",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/jobs": {
            "get": {
                "summary": "Retrieve the status of all jobs.",
                "operationId": "getAllAssignedJobs",
                "tags": [
                    "Jobs"
                ],
                "responses": {
                    "200": {
                        "description": "An array of JobStatus objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/JobStatus"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/jobs/{id}": {
            "get": {
                "summary": "Retrieve the status of a specific job.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the job.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getJobsId",
                "tags": [
                    "Jobs"
                ],
                "responses": {
                    "200": {
                        "description": "A single JobStatus object",
                        "schema": {
                            "$ref": "#/definitions/JobStatus"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/license": {
            "get": {
                "summary": "Retrieve the license applied to this appliance.",
                "operationId": "getLicense",
                "tags": [
                    "License"
                ],
                "responses": {
                    "200": {
                        "description": "A single License object",
                        "schema": {
                            "$ref": "#/definitions/License"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Apply and register a new license to the appliance.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The license text provided to you by ExtraHop Support, including the BEGIN and END lines.",
                        "required": false,
                        "schema": {
                            "type": "string",
                            "description": "The license text provided to you by ExtraHop Support, including the BEGIN and END lines."
                        }
                    }
                ],
                "consumes": [
                    "text/plain"
                ],
                "operationId": "replaceLicense",
                "tags": [
                    "License"
                ],
                "responses": {
                    "204": {
                        "description": "The license was uploaded successfully. If the uploaded license is different from the previous license, a job was created to register the license."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/license/productkey": {
            "get": {
                "summary": "Retrieve the product key applied to this appliance.",
                "operationId": "getLicenseProductkey",
                "tags": [
                    "License"
                ],
                "responses": {
                    "200": {
                        "description": "A single LicenseProductKey object",
                        "schema": {
                            "$ref": "#/definitions/LicenseProductKey"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Apply the specified product key to the appliance and register the license.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nproduct_key | string | yes | Apply the specified product key to the appliance.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified product key to the appliance.",
                        "required": false,
                        "schema": {
                            "$ref": "#/definitions/product_key"
                        }
                    }
                ],
                "operationId": "replaceLicenseProductkey",
                "tags": [
                    "License"
                ],
                "responses": {
                    "204": {
                        "description": "The product key was uploaded successfully. If the uploaded product key is different from the previous key, a job was created to apply the key and register the license."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/metrics": {
            "post": {
                "summary": "Perform a metric query.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncycle | string | yes | The aggregation period for metrics. \u003cbr\u003e**Supported values:** \"auto\", \"1sec\", \"30sec\", \"5min\", \"1hr\", \"24hr\"\nfrom | integer or string | yes | The beginning timestamp for the request. Return only metrics collected after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--42) for supported time units and suffixes.\nmetric_category | string | yes | The group of metrics that are searchable in the metric catalog.\nmetric_specs | array[metric_spec] | yes | An array of metric specification objects.\nobject_ids | array[integer] | yes | The list of numeric values that represent unique identifiers. Unique identifiers can be retrieved through the /networks, /devices, /applications, /vlans, /devicegroups, /activitygroups, and /appliances resources. For system health metrics, specify the ID of the sensor or console and set the object_type parameter to \"system\".\nobject_type | string | yes | Indicates the object type of unique identifiers specified in the object_ids property. \u003cbr\u003e**Supported values:** \"network\", \"device\", \"application\", \"vlan\", \"device_group\", \"system\"\nuntil | integer or string | yes | The ending timestamp for the request. Return only metrics collected before this time. Follows the same time value guidelines as the from parameter.\n metric_spec\n\nname | type | required | description\n-----|------|----------|------------\ncalc_type | string | no | The type of calculation to perform. \u003cbr\u003e**Supported values:** \"mean\", \"percentiles\"\nkey1 | string | no | Filter detail metrics. Detail metrics break down data through keys, which are strings or IP addresses. For example, the metric \"HTTP Requests by Method\" accepts a key1 value of \"GET.\" Keys can also be regular expressions that are delimited with forward slashes (\"/GET/\").\nkey2 | string | no | Enable additional filtering on detail metrics.\nname | string | yes | The field name for the metric. When filtering in the metric catalog on a metric_category, each result is a potential metric_spec name. When a result is selected from the catalog, the \"Metric\" field value is a valid option for this field.\npercentiles | array[integer] | no | The list of percentiles, sorted in ascending order, which should be returned. This parameter is only required if the calc_type parameter is set to \"percentiles\". If the calc_type parameter is set to mean, the percentiles property cannot be set.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The description of the metric request.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/metric_query"
                        }
                    }
                ],
                "operationId": "createMetrics",
                "tags": [
                    "Metrics"
                ],
                "responses": {
                    "200": {
                        "description": "An object that contains the requested metrics.",
                        "schema": {
                            "$ref": "#/definitions/metric_response"
                        }
                    },
                    "400": {
                        "description": "The specified metric query is invalid."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/metrics/next/{xid}": {
            "get": {
                "summary": "Retrieves remaining metrics from a connected sensor for metric queries that return an xid. Repeat request for each sensor.",
                "parameters": [
                    {
                        "name": "xid",
                        "in": "path",
                        "description": "The unique identifier returned by a metric query.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getMetricsNextXid",
                "tags": [
                    "Metrics"
                ],
                "responses": {
                    "200": {
                        "description": "A single metric object. If metrics are not yet available from the attached sensor, the string \"again\" is returned. Wait a few seconds and then try again."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "429": {
                        "description": "Metrics could not be retrieved because there are too many pending requests on an attached sensor."
                    }
                },
                "deprecated": false
            }
        },
        "/metrics/total": {
            "post": {
                "summary": "Perform a metric query for total values.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncycle | string | yes | The aggregation period for metrics. \u003cbr\u003e**Supported values:** \"auto\", \"1sec\", \"30sec\", \"5min\", \"1hr\", \"24hr\"\nfrom | integer or string | yes | The beginning timestamp for the request. Return only metrics collected after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--42) for supported time units and suffixes.\nmetric_category | string | yes | The group of metrics that are searchable in the metric catalog.\nmetric_specs | array[metric_spec] | yes | An array of metric specification objects.\nobject_ids | array[integer] | yes | The list of numeric values that represent unique identifiers. Unique identifiers can be retrieved through the /networks, /devices, /applications, /vlans, /devicegroups, /activitygroups, and /appliances resources. For system health metrics, specify the ID of the sensor or console and set the object_type parameter to \"system\".\nobject_type | string | yes | Indicates the object type of unique identifiers specified in the object_ids property. \u003cbr\u003e**Supported values:** \"network\", \"device\", \"application\", \"vlan\", \"device_group\", \"system\"\nuntil | integer or string | yes | The ending timestamp for the request. Return only metrics collected before this time. Follows the same time value guidelines as the from parameter.\n metric_spec\n\nname | type | required | description\n-----|------|----------|------------\ncalc_type | string | no | The type of calculation to perform. \u003cbr\u003e**Supported values:** \"mean\", \"percentiles\"\nkey1 | string | no | Filter detail metrics. Detail metrics break down data through keys, which are strings or IP addresses. For example, the metric \"HTTP Requests by Method\" accepts a key1 value of \"GET.\" Keys can also be regular expressions that are delimited with forward slashes (\"/GET/\").\nkey2 | string | no | Enable additional filtering on detail metrics.\nname | string | yes | The field name for the metric. When filtering in the metric catalog on a metric_category, each result is a potential metric_spec name. When a result is selected from the catalog, the \"Metric\" field value is a valid option for this field.\npercentiles | array[integer] | no | The list of percentiles, sorted in ascending order, which should be returned. This parameter is only required if the calc_type parameter is set to \"percentiles\". If the calc_type parameter is set to mean, the percentiles property cannot be set.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The description of the metric request.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/metric_query"
                        }
                    }
                ],
                "operationId": "createMetricsTotal",
                "tags": [
                    "Metrics"
                ],
                "responses": {
                    "200": {
                        "description": "An object that contains the requested metrics.",
                        "schema": {
                            "$ref": "#/definitions/metric_response"
                        }
                    },
                    "400": {
                        "description": "The specified metric query is invalid."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/metrics/totalbyobject": {
            "post": {
                "summary": "Perform a metric query for total values that are grouped by object.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncycle | string | yes | The aggregation period for metrics. \u003cbr\u003e**Supported values:** \"auto\", \"1sec\", \"30sec\", \"5min\", \"1hr\", \"24hr\"\nfrom | integer or string | yes | The beginning timestamp for the request. Return only metrics collected after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--42) for supported time units and suffixes.\nmetric_category | string | yes | The group of metrics that are searchable in the metric catalog.\nmetric_specs | array[metric_spec] | yes | An array of metric specification objects.\nobject_ids | array[integer] | yes | The list of numeric values that represent unique identifiers. Unique identifiers can be retrieved through the /networks, /devices, /applications, /vlans, /devicegroups, /activitygroups, and /appliances resources. For system health metrics, specify the ID of the sensor or console and set the object_type parameter to \"system\".\nobject_type | string | yes | Indicates the object type of unique identifiers specified in the object_ids property. \u003cbr\u003e**Supported values:** \"network\", \"device\", \"application\", \"vlan\", \"device_group\", \"system\"\nuntil | integer or string | yes | The ending timestamp for the request. Return only metrics collected before this time. Follows the same time value guidelines as the from parameter.\n metric_spec\n\nname | type | required | description\n-----|------|----------|------------\ncalc_type | string | no | The type of calculation to perform. \u003cbr\u003e**Supported values:** \"mean\", \"percentiles\"\nkey1 | string | no | Filter detail metrics. Detail metrics break down data through keys, which are strings or IP addresses. For example, the metric \"HTTP Requests by Method\" accepts a key1 value of \"GET.\" Keys can also be regular expressions that are delimited with forward slashes (\"/GET/\").\nkey2 | string | no | Enable additional filtering on detail metrics.\nname | string | yes | The field name for the metric. When filtering in the metric catalog on a metric_category, each result is a potential metric_spec name. When a result is selected from the catalog, the \"Metric\" field value is a valid option for this field.\npercentiles | array[integer] | no | The list of percentiles, sorted in ascending order, which should be returned. This parameter is only required if the calc_type parameter is set to \"percentiles\". If the calc_type parameter is set to mean, the percentiles property cannot be set.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The description of the metric request.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/metric_query"
                        }
                    }
                ],
                "operationId": "createMetricsTotalbyobject",
                "tags": [
                    "Metrics"
                ],
                "responses": {
                    "200": {
                        "description": "An object that contains the requested metrics.",
                        "schema": {
                            "$ref": "#/definitions/metric_response"
                        }
                    },
                    "400": {
                        "description": "The specified metric query is invalid."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/networklocalities": {
            "get": {
                "summary": "Retrieve all network locality entries.",
                "operationId": "getAllAssignedNetworklocalities",
                "tags": [
                    "Network Locality Entry"
                ],
                "responses": {
                    "200": {
                        "description": "An array of NetworkLocalityEntry objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/NetworkLocalityEntry"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new network locality entry.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | An optional description of the network locality entry.\nexternal | boolean | yes | Indicates whether the network is internal or external.\nname | string | no | The name of the network locality. If this field is not specified, the network locality is named in the following format: \"locality_ID\", where ID is the unique identifier of the network locality.\nnetwork | string | no | Deprecated. Specify CIDR blocks or IP addresses with the networks field.\nnetworks | array[string] | no | An array of CIDR blocks or IP addresses that define the network locality.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property values to the new network locality entry.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/NetworkLocalityEntry_CREATE"
                        }
                    }
                ],
                "operationId": "createNetworklocalities",
                "tags": [
                    "Network Locality Entry"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The query is invalid."
                    }
                },
                "deprecated": false
            }
        },
        "/networklocalities/{id}": {
            "delete": {
                "summary": "Delete a specific network locality entry.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the network locality entry.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteNetworklocalitiesId",
                "tags": [
                    "Network Locality Entry"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The query is invalid."
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific network locality entry.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the network locality entry.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getNetworklocalitiesId",
                "tags": [
                    "Network Locality Entry"
                ],
                "responses": {
                    "200": {
                        "description": "A single NetworkLocalityEntry object",
                        "schema": {
                            "$ref": "#/definitions/NetworkLocalityEntry"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Apply updates to a specific network locality entry.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | An optional description of the network locality entry.\nexternal | boolean | no | Indicates whether the network is internal or external.\nname | string | no | The name of the network locality.\nnetwork | string | no | Deprecated. Specify CIDR blocks or IP addresses with the networks field.\nnetworks | array[string] | no | An array of CIDR blocks or IP addresses that define the network locality.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to the network locality entry.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/patch_body"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the network locality entry.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateNetworklocalitiesId",
                "tags": [
                    "Network Locality Entry"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The query is invalid."
                    }
                },
                "deprecated": false
            }
        },
        "/networks": {
            "get": {
                "summary": "Retrieve all networks.",
                "operationId": "getAllAssignedNetworks",
                "tags": [
                    "Network"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Network objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Network"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/networks/{id}": {
            "get": {
                "summary": "Retrieve a specific network by ID.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Unique identifier of the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getNetworksId",
                "tags": [
                    "Network"
                ],
                "responses": {
                    "200": {
                        "description": "A single Network object",
                        "schema": {
                            "$ref": "#/definitions/Network"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific network by ID.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | Optional description of the network.\nname | string | yes | Friendly name of the network.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Property value updates to apply to the network.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Network_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Unique identifier of the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateNetworksId",
                "tags": [
                    "Network"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/networks/{id}/alerts": {
            "get": {
                "summary": "Retrieve all alerts assigned to a specific network.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Unique identifier of the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "direct_assignments_only",
                        "in": "query",
                        "description": "Restrict results to only alerts directly assigned to the network.",
                        "required": false,
                        "type": "boolean"
                    }
                ],
                "operationId": "getAllAssignedNetworksIdAlerts",
                "tags": [
                    "Network"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Alert objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Alert"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and/or unassigned a specific network to alerts.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Lists of alert IDs to assign and/or unassign.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Unique identifier of the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsNetworksIdAlerts",
                "tags": [
                    "Network"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/networks/{id}/alerts/{child-id}": {
            "delete": {
                "summary": "Unassign an alert from a specific network.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "Unique identifier of the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Unique identifier of the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignNetworksIdAlertsChildId",
                "tags": [
                    "Network"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign an alert to a specific network.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "Unique identifier of the alert.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Unique identifier of the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignNetworksIdAlertsChildId",
                "tags": [
                    "Network"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/networks/{id}/vlans": {
            "get": {
                "summary": "Retrieve all vlans assigned to a specfic network.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "Unique identifier of the network.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedNetworksIdVlans",
                "tags": [
                    "Network"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Vlan objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Vlan"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/nodes": {
            "get": {
                "summary": "Retrieve all sensors connected to this console.",
                "operationId": "getAllAssignedNodes",
                "tags": [
                    "Node"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Node objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Node"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/nodes/{id}": {
            "get": {
                "summary": "Retrieve a specific sensor that is connected to this console.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The ID of the sensor.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getNodesId",
                "tags": [
                    "Node"
                ],
                "responses": {
                    "200": {
                        "description": "A single Node object",
                        "schema": {
                            "$ref": "#/definitions/Node"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific Discover node that is connected to this console.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nenabled | boolean | yes | Indicates whether the sensor is reporting to the console.\nnickname | string | yes | The friendly name for the sensor.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified updates to the Discover node.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Node_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the Discover node.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateNodesId",
                "tags": [
                    "Node"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/observations/associatedipaddrs": {
            "post": {
                "summary": "Add an observation to create an association between device IP addresses.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nobservations | array[observation] | yes | An array of observations.\nsource | string | no | The source of the observations.\n observation\n\nname | type | required | description\n-----|------|----------|------------\nassociated_ipaddr | string | yes | The associated IP address.\nipaddr | string | yes | The device IP address observed by the sensor or console.\ntimestamp | integer | yes | The time that the observation was created by the source, expressed in milliseconds since the epoch.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The observation parameters.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/manual_observation_body"
                        }
                    }
                ],
                "operationId": "createObservationsAssociatedipaddrs",
                "tags": [
                    "Observations"
                ],
                "responses": {
                    "202": {
                        "description": "Successfully added observations. Some observations might have been ignored if the specified device IP addresses were not observed by the sensor or console."
                    },
                    "400": {
                        "description": "The specified observations are invalid."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets": {
            "get": {
                "summary": "Retrieve all Open Data Stream targets.",
                "operationId": "getAllAssignedOdstargets",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ODS target objects."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/http": {
            "get": {
                "summary": "Retrieve all HTTP Open Data Stream targets.",
                "operationId": "getAllAssignedOdstargetsHttp",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "An array of HTTP ODS target objects."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new HTTP Open Data Stream target.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nadditional_header | string | no | Specifies an additional HTTP header to include in each request. Headers must be specified in the following format: \"\u003ckey\u003e:\u003cvalue\u003e\". For example: \"additional_header\": \"Accept: text/html\".\nauthentication | http_auth | yes | An object that contains HTTP authentication credentials.\nhost | string | yes | The hostname or IP address of the remote HTTP server.\nname | string | yes | The name for the target.\npipeline | boolean | yes | Indicates whether multiple concurrent HTTP connections are enabled, which can improve throughput speed.\nport | integer | yes | The TCP port number of the HTTP server.\nprotocol | string | yes | The protocol to transmit data over. \u003cbr\u003e**Supported values:** \"http\", \"https\"\nskip_cert_verification | boolean | no | Indicates whether to bypass TLS certificate verification for encrypted data. This parameter is valid only if `protocol` is set to `https`.\n http_auth\n\nname | type | required | description\n-----|------|----------|------------\naccess_key | string | no | The access key ID. This option is required for AWS and Azure Storage authentication.\nauth_type | string | yes | The type of HTTP authentication. \u003cbr\u003e**Supported values:** \"none\", \"basic\", \"aws\", \"azure_storage\", \"azure_ad\", \"crowdstrike\"\nclient_id | string | no | The client ID. This option is required for Microsoft Entra ID and Crowdstrike authentication.\nclient_secret | string | no | The client Secret Key. This option is required for Microsoft Entra ID and Crowdstrike authentication.\ngrant_type | string | no | The OAuth 2.0 grant type. This option is required for Microsoft Entra ID authentication. \u003cbr\u003e**Supported values:** \"client\", \"resource_owner\"\npassword | string | no | The password of the user. This option is required if `auth_type` is set to `basic` or if `auth_type` is set to `azure_ad` and `grant_type` is set to `resource_owner`.\nregion | string | no | The name of the AWS region, such as \"us-west-1\". This option is required for AWS authentication.\nresource | string | no | The Microsoft Entra ID resource URI. This option is required for Microsoft Entra ID authentication.\nsecret_key | string | no | The secret access key. This option is required for AWS authentication.\nservice | string | no | The service code of the AWS service, such as \"AmazonEC2\". This option is required for AWS authentication.\ntoken_endpoint | string | no | The Microsoft Entra ID /token  endpoint. For example: \"https://login.microsoftonline.com/\u003ctenant_id\u003e/oauth2/token\". This option is required for Microsoft Entra ID authentication.\nusername | string | no | The name of the user. This option is required if `auth_type` is set to `basic` or if `auth_type` is set to `azure_ad` and `grant_type` is set to `resource_owner`.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http"
                        }
                    }
                ],
                "operationId": "createOdstargetsHttp",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/http/{name}": {
            "delete": {
                "summary": "Delete an HTTP Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteOdstargetsHttpName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific HTTP Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getOdstargetsHttpName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "A single OpenDataStream object",
                        "schema": {
                            "$ref": "#/definitions/OpenDataStream"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/kafka": {
            "get": {
                "summary": "Retrieve all Kafka Open Data Stream targets.",
                "operationId": "getAllAssignedOdstargetsKafka",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Kafka ODS target objects.",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/kafkaODS"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new Kafka Open Data Stream target.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nauthentication | kafka_auth | no | An object that contains Kafka authentication credentials.\nbrokers | array[kafka_brokers] | yes | An array of one or more objects that contain information about Kafka Brokers.\ncompression | string | no | The compression method to apply to transmitted data. \u003cbr\u003e**Supported values:** \"none\", \"gzip\", \"snappy\"\nname | string | yes | The name for the target.\npartition_strategy | string | no | The partitioning method to apply to transmitted data. \u003cbr\u003e**Supported values:** \"hash_key\", \"manual\", \"random\", \"round_robin\"\nprotocol | string | yes | The protocol to transmit data over. \u003cbr\u003e**Supported values:** \"tcp\", \"tls\"\nskip_cert_verification | boolean | no | Indicates whether to bypass TLS certificate verification for encrypted data. This parameter is valid only if protocol is set to tls.\ntls_ca_certs | string | no | The trusted certificates to validate the Kafka server certificate with, in PEM format. Specify this option if your Kafka server certificate has not been signed by a valid Certificate Authority (CA). If this option is not specified, the server certificate is validated with the built-in list of valid CA certificates. This option is valid only if the protocol is TLS.\ntls_client_cert | string | no | The TLS client certificate that is sent to the Kafka server during the TLS handshake. Specify this option if client authentication is enabled on the Kafka server.\ntls_client_key | string | no | The private key of the TLS client certificate specified by the tls_client_cert parameter. Specify this option if client authentication is enabled on the Kafka server.\n kafka_auth\n\nname | type | required | description\n-----|------|----------|------------\nalgorithm | string | yes | The hashing algorithm for SASL authentication. \u003cbr\u003e**Supported values:** \"sha256\", \"sha512\"\nauth_type | string | yes | The type of SASL authentication. \u003cbr\u003e**Supported values:** \"scram\"\npassword | string | yes | The password of the SASL user.\nusername | string | yes | The username of the SASL user.\n\n kafka_brokers\n\nname | type | required | description\n-----|------|----------|------------\nhost | string | yes | The hostname or IP address of the remote Kafka broker.\nport | integer | yes | The TCP port number of the Kafka broker.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/kafka"
                        }
                    }
                ],
                "operationId": "createOdstargetsKafka",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/kafka/{name}": {
            "delete": {
                "summary": "Delete a Kafka Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteOdstargetsKafkaName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific Kafka Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getOdstargetsKafkaName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "A single Kafka ODS target object.",
                        "schema": {
                            "$ref": "#/definitions/kafkaODS"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/mongodb": {
            "get": {
                "summary": "Retrieve all MongoDB Open Data Stream targets.",
                "operationId": "getAllAssignedOdstargetsMongodb",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "An array of MongoDB ODS target objects."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new MongoDB Open Data Stream target.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nauthentication | array[mongodb_auth] | no | An array of objects that contain MongoDB authentication credentials.\nencrypt | boolean | no | Indicates whether data is encrypted with TLS.\nhost | string | yes | The hostname or IP address of the remote MongoDB server.\nname | string | yes | The name for the target.\nport | integer | yes | The TCP port number of the MongoDB server.\nskip_cert_verification | boolean | no | Indicates whether to bypass TLS certificate verification for encrypted data. This parameter is valid only if `encrypt` is set to `true`.\n mongodb_auth\n\nname | type | required | description\n-----|------|----------|------------\ndatabase | string | yes | The name of the MongoDB database.\npassword | string | yes | The password of the user.\nuser | string | yes | The name of the user that has permission to modify the specified database.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/mongodb"
                        }
                    }
                ],
                "operationId": "createOdstargetsMongodb",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/mongodb/{name}": {
            "delete": {
                "summary": "Delete a MongoDB Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteOdstargetsMongodbName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific MongoDB Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getOdstargetsMongodbName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "A single OpenDataStream object",
                        "schema": {
                            "$ref": "#/definitions/OpenDataStream"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/raw": {
            "get": {
                "summary": "Retrieve all Raw Open Data Stream targets.",
                "operationId": "getAllAssignedOdstargetsRaw",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Raw ODS target objects."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new Raw Open Data Stream target.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncompression | boolean | no | Indicates whether gzip compression is applied to transmitted data.\ngzip_threshold_bytes | integer | no | The number of bytes that specifies the threshold for creating a new message. Every 30 seconds, the sensor or console sends messages that exceed the specified size to prevent messages from growing too large. This option is valid only if `compression` is set to `true`.\ngzip_threshold_seconds | integer | no | The number of seconds that specifies the threshold for creating a new message.  Every 30 seconds, the sensor or console sends messages that have been written for more than the specified time period to prevent messages from growing too large. This option is valid only if `compression` is set to `true`.\nhost | string | yes | The hostname or IP address of the remote server.\nname | string | yes | The name for the target.\nport | integer | yes | The TCP or UDP port number of the remote server.\nprotocol | string | yes | The protocol to transmit data over. \u003cbr\u003e**Supported values:** \"tcp\", \"udp\"",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/raw"
                        }
                    }
                ],
                "operationId": "createOdstargetsRaw",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/raw/{name}": {
            "delete": {
                "summary": "Delete a Raw Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteOdstargetsRawName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific Raw Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getOdstargetsRawName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "A single OpenDataStream object",
                        "schema": {
                            "$ref": "#/definitions/OpenDataStream"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/syslog": {
            "get": {
                "summary": "Retrieve all Syslog Open Data Stream targets.",
                "operationId": "getAllAssignedOdstargetsSyslog",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Syslog ODS target objects.",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/syslogODS"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new Syslog Open Data Stream target.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nbatch_min_bytes | integer | no | The minimum number of bytes to send at a time to the syslog server.\nconcurrent_connections | integer | no | The number of concurrent connections to send messages over.\nhost | string | yes | The hostname or IP address of the remote Syslog server.\nlocaltime | boolean | no | Indicates whether timestamps reference the local time zone of the sensor or console. If this parameter is set to false, timestamps reference GMT.\nname | string | yes | The name for the target.\nport | integer | yes | The TCP or UDP port number of the remote Syslog server.\nprotocol | string | yes | The protocol to transmit data over. \u003cbr\u003e**Supported values:** \"tcp\", \"udp\", \"tls\"\nskip_cert_verification | boolean | no | Indicates whether to bypass TLS certificate verification for encrypted data. This parameter is valid only if protocol is set to tls.\ntcp_length_prefix_framing | boolean | no | Indicates whether to prepend the number of bytes in a message to the beginning of the message. If this parameter is set to false, the end of each message is delimited by a trailing newline.\ntls_ca_certs | string | no | The trusted certificates to validate the Syslog server certificate with, in PEM format. Specify this option if your Syslog server certificate has not been signed by a valid Certificate Authority (CA). If this option is not specified, the server certificate is validated with the built-in list of valid CA certificates. This option is valid only if the protocol is TLS and skip_cert_verification is false.\ntls_client_cert | string | no | The TLS client certificate that is sent to the Syslog server during the TLS handshake. Specify this option if client authentication is enabled on the Syslog server.\ntls_client_key | string | no | The private key of the TLS client certificate specified by the tls_client_cert parameter. Specify this option if client authentication is enabled on the Syslog server.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/syslog"
                        }
                    }
                ],
                "operationId": "createOdstargetsSyslog",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/odstargets/syslog/{name}": {
            "delete": {
                "summary": "Delete a Syslog Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteOdstargetsSyslogName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific Syslog Open Data Stream target.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "The name of the target.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getOdstargetsSyslogName",
                "tags": [
                    "Open Data Stream"
                ],
                "responses": {
                    "200": {
                        "description": "A single Syslog ODS target object.",
                        "schema": {
                            "$ref": "#/definitions/syslogODS"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/packets/search": {
            "get": {
                "summary": "Download packets and associated files through a request URL.",
                "parameters": [
                    {
                        "name": "output",
                        "in": "query",
                        "description": "The output format.\n * `pcap` - A PCAP file that contains packets.\n * `keylog_txt` - A keylog text file that contains secrets for decryption.\n * `pcapng` - A PCAPNG file that can contain both packets and secrets for decryption.\n * `zip` - A ZIP file that contains both a PCAP and keylog text file.\n * `extract` - A ZIP file that contains files extracted from packets that matched the query. This option is valid only if you have full access to the NDR module.",
                        "required": false,
                        "type": "string",
                        "enum": [
                            "pcap",
                            "keylog_txt",
                            "pcapng",
                            "zip",
                            "extract"
                        ],
                        "default": "pcap"
                    },
                    {
                        "name": "include_secrets",
                        "in": "query",
                        "description": "Specifies whether to include secrets in the PCAPNG file. This option is valid only if `output` is set to `pcapng`.",
                        "required": false,
                        "type": "boolean"
                    },
                    {
                        "name": "decrypt_files",
                        "in": "query",
                        "description": "Specifies whether to decrypt extracted files with stored secrets. This option is valid only if the `output` parameter is `extract`.",
                        "required": false,
                        "type": "boolean"
                    },
                    {
                        "name": "limit_bytes",
                        "in": "query",
                        "description": "The approximate maximum number of bytes to return. After the ExtraHop system finds packets that match the size specified in the search criteria, the system stops searching for additional packets. However, because the system analyzes multiple packets at a time, the total size of the packets returned might be larger than the specified size. The default unit is bytes, but you can specify other units with a unit suffix. The default value is \"100MB\".\n **Note**: If the output is \"extract\", there is a maximum value for this field. The default maximum is \"100MB\", but the maximum can be modified in the running configuration. If the output is not \"extract\", there is no maximum value.",
                        "required": false,
                        "type": "string",
                        "default": "100MB"
                    },
                    {
                        "name": "limit_search_duration",
                        "in": "query",
                        "description": "The approximate maximum amount of time to perform the packet search. After the specified amount of time has passed, the ExtraHop system stops searching for additional packets. However, the system will extend past the specified time to finish analyzing packets that were being searched before the time expired, and the system analyzes multiple packets at a time. Therefore, the search might last longer than the specified time. The default unit is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes. The default value is \"5m\".\n **Note**: If the output is \"extract\", there is a maximum value for this field. The default maximum is \"5m\", but the maximum can be modified in the running configuration. If the output is not \"extract\", there is no maximum value.",
                        "required": false,
                        "type": "string",
                        "default": "5m"
                    },
                    {
                        "name": "always_return_body",
                        "in": "query",
                        "description": "Specifies the behavior if the query does not match any packets or if the packets matched by the query do not contain any files. If the value is true, the system returns an empty file and a 200 status code. If the value is false, the system returns a 204 status code but does not return a file.",
                        "required": false,
                        "type": "boolean"
                    },
                    {
                        "name": "from",
                        "in": "query",
                        "description": "The beginning timestamp of the time range the search will include, expressed in milliseconds since the epoch. A negative value specifies that the search will begin with packets captured at a time in the past. For example, specify -10m to begin the search with packets captured 10 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes.",
                        "required": true,
                        "type": "string",
                        "default": "-30m"
                    },
                    {
                        "name": "until",
                        "in": "query",
                        "description": "The ending timestamp of the time range the search will include, expressed in milliseconds since the epoch. A 0 value specifies that the search will end with packets captured at the time of the search. A negative value specifies that the search will end with packets captured at a time in the past. For example, specify -5m to end the search with packets captured 5 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "bpf",
                        "in": "query",
                        "description": "The Berkeley Packet Filter (BPF) syntax for the packet search. For more information about BPF syntax, see the [REST API Guide](https://docs.extrahop.com/9.8/bpf-syntax/).",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "ip1",
                        "in": "query",
                        "description": "Returns packets sent to or received by the specified IP address.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "port1",
                        "in": "query",
                        "description": "Returns packets sent from or received on the specified port.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "ip2",
                        "in": "query",
                        "description": "Returns packets sent to or received by the specified IP address.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "port2",
                        "in": "query",
                        "description": "Returns packets sent from or received on the specified port.",
                        "required": false,
                        "type": "string"
                    }
                ],
                "operationId": "getPacketsSearch",
                "tags": [
                    "Packet Search"
                ],
                "responses": {
                    "200": {
                        "description": "File was downloaded."
                    },
                    "204": {
                        "description": "File was not downloaded because always_return_body was false and the query did not match any packets or the packets matched by the query do not contain any files."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "File was not downloaded because no packets are available. The sensor is not connected to a packetstore, and no packets are saved on the sensor."
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Download packets and associated files through a JSON string.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nalways_return_body | boolean | no | Specifies the behavior if the query does not match any packets or if the packets matched by the query do not contain any files. If the value is true, the system returns an empty file and a 200 status code. If the value is false, the system returns a 204 status code but does not return a file.\nbpf | string | no | The Berkeley Packet Filter (BPF) syntax for the packet search. For more information about BPF syntax, see [Filter packets with Berkeley Packet Filter syntax](https://docs.extrahop.com/9.8/bpf-syntax/).\ndecrypt_files | boolean | no | Specifies whether to decrypt extracted files with stored secrets. This option is valid only if the `output` parameter is `extract`.\nfrom | string | yes | The beginning timestamp of the time range the search will include, expressed in milliseconds since the epoch. A negative value specifies that the search will begin with packets captured at a time in the past. For example, specify -10m to begin the search with packets captured 10 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes.\ninclude_secrets | boolean | no | Whether or not to include TLS secrets together with packet data in .pcapng files. Only valid if \"output\" is \"pcapng\".\nip1 | string | no | Returns packets sent to or received by the specified IP address.\nip2 | string | no | Returns packets sent to or received by the specified IP address.\nlimit_bytes | string | no | The approximate maximum number of bytes to return. After the ExtraHop system finds packets that match the size specified in the search criteria, the system stops searching for additional packets. However, because the system analyzes multiple packets at a time, the total size of the packets returned might be larger than the specified size. The default unit is bytes, but you can specify other units with a unit suffix. The default value is \"100MB\". **Note**: If the output is \"extract\", there is a maximum value for this field. The default maximum is \"100MB\", but the maximum can be modified in the running configuration. If the output is not \"extract\", there is no maximum value.\nlimit_search_duration | string | no | The approximate maximum amount of time to perform the packet search. After the specified amount of time has passed, the ExtraHop system stops searching for additional packets. However, the system will extend past the specified time to finish analyzing packets that were being searched before the time expired, and the system analyzes multiple packets at a time. Therefore, the search might last longer than the specified time. The default unit is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes. The default value is \"5m\". **Note**: If the output is \"extract\", there is a maximum value for this field. The default maximum is \"5m\", but the maximum can be modified in the running configuration. If the output is not \"extract\", there is no maximum value.\noutput | string | no | The output format. \u003cbr\u003e**Supported values:** \"pcap\", \"keylog_txt\", \"pcapng\", \"zip\", \"extract\"\nport1 | string | no | Returns packets sent from or received on the specified port.\nport2 | string | no | Returns packets sent from or received on the specified port.\nuntil | string | no | The ending timestamp of the time range the search will include, expressed in milliseconds since the epoch. A 0 value specifies that the search will end with packets captured at the time of the search. A negative value specifies that the search will end with packets captured at a time in the past. For example, specify -5m to end the search with packets captured 5 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The parameters of the packet search.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/packets_search_request"
                        }
                    }
                ],
                "operationId": "createPacketsSearch",
                "tags": [
                    "Packet Search"
                ],
                "responses": {
                    "200": {
                        "description": "File was downloaded."
                    },
                    "204": {
                        "description": "File was not downloaded because always_return_body was false and the query did not match any packets or the packets matched by the query do not contain any files."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "File was not downloaded because no packets are available. The sensor is not connected to a packetstore, and no packets are saved on the sensor."
                    }
                },
                "deprecated": false
            }
        },
        "/pairing/token": {
            "post": {
                "summary": "Generate a token required to connect a sensor to a console or connect an EXA 5300 recordstore to a sensor or console.",
                "operationId": "createPairingToken",
                "tags": [
                    "Pairing"
                ],
                "responses": {
                    "200": {
                        "description": "Successfully generated token."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/records/cursor": {
            "post": {
                "summary": "Retrieve records starting at a specified cursor. In RevealX Enterprise, this operation is only supported if records are stored on an ExtraHop recordstore (such as the EXA 5300) or on CrowdStrike LogScale. In RevealX 360, this operation is only supported for systems that have a cloud-based recordstore with Premium Investigation.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncursor | string | yes | The unique identifier of the cursor that specifies the next page of results in the query.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The cursor ID that specifies the next page of results in the query.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/fetch_cursor_body"
                        }
                    },
                    {
                        "name": "context_ttl",
                        "in": "query",
                        "description": "The amount of time to keep the search context active, expressed in milliseconds. After the specified time elapses, the cursor becomes invalid, and you can no longer retrieve additional records from the search. Specify this parameter to extend the previously specified search context.",
                        "required": false,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "createRecordsCursor",
                "tags": [
                    "Record Log"
                ],
                "responses": {
                    "200": {
                        "description": "The request was successful.",
                        "schema": {
                            "$ref": "#/definitions/record_response"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The license on the EXA is invalid or the EXA cannot connect to the license server.",
                        "schema": {
                            "$ref": "#/definitions/license_errors"
                        }
                    },
                    "404": {
                        "description": "Requested cursor failed to resolve."
                    },
                    "422": {
                        "description": "The query is invalid."
                    }
                },
                "deprecated": false
            }
        },
        "/records/cursor/{cursor}": {
            "get": {
                "summary": "Deprecated. Replaced by the POST /records/cursor operation.",
                "parameters": [
                    {
                        "name": "cursor",
                        "in": "path",
                        "description": "The cursor ID.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "context_ttl",
                        "in": "query",
                        "description": "The amount of time to keep the search context active, expressed in milliseconds.",
                        "required": false,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getRecordsCursorCursor",
                "tags": [
                    "Record Log"
                ],
                "responses": {
                    "200": {
                        "description": "The request was successful.",
                        "schema": {
                            "$ref": "#/definitions/record_response"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The license on the EXA is invalid or the EXA cannot connect to the license server.",
                        "schema": {
                            "$ref": "#/definitions/license_errors"
                        }
                    },
                    "404": {
                        "description": "Requested cursor failed to resolve."
                    },
                    "422": {
                        "description": "The query is invalid."
                    }
                },
                "deprecated": false
            }
        },
        "/records/search": {
            "post": {
                "summary": "Perform a record log query.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncontext_ttl | integer | no | The amount of time to keep the search context active. The default unit is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--54) for supported time units and suffixes. In RevealX Enterprise, this field is only valid if records are stored on an ExtraHop recordstore (such as an EXA 5300) or on CrowdStrike LogScale. In RevealX 360, this field is only valid for systems that have a cloud-based recordstore with Premium Investigation. In both RevealX Enterprise with CrowdStrike LogScale and RevealX 360 with Premium Investigation, this field is invalid if the sort or offset fields are specified.\nfilter | filter | no | The object containing the parameters that specify the filter criteria. The parameters are defined under the filter section below. If no filter values are provided, the query returns all records that match the time range and any specified record formats.\nfrom | integer | yes | The beginning timestamp of the time range the query will search, expressed in milliseconds since the epoch. A negative value specifies that the search will begin with records created at a time in the past. For example, specify -600000ms to begin the search with records created 10 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--54) for supported time units and suffixes.\nlimit | integer | no | The maximum number of records returned by the query. The maximum value cannot exceed 10000. The default value is 100.\noffset | integer | no | The number of records to skip in the query results. The query will return records starting from the offset value. This parameter is often combined with the limit and sort parameters. The default value is 0. For ExtraHop recordstores, the maximum value is 10,000; to retrieve records returned after the first 10,000, see POST /records/cursor/. For third-party recordstores, there is no maximum value.\nsort | array[sort_item] | no | The list of one or more sort objects that specify sort priorities. The returned records are sorted in the order the objects are listed. The parameters are defined under the sort_item section below. If no sort_item values are provided, records are sorted by timestamp in descending order.\ntypes | array[string] | no | An array of one or more record formats. The query returns only records that match the specified formats. If no value is specified, the query returns records of any type. Valid values for this field are displayed in the Record Type field on the Record Formats page. For example: \"~cifs\".\nuntil | integer | no | The ending timestamp of the time range the query will search, expressed in milliseconds since the epoch. A 0 value specifies that the search will end with records created at the time of the request. A negative value specifies that the search will end with records created at a time in the past. For example, specify -300000ms to end the search with records created 5 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--54) for supported time units and suffixes.\n filter\n\nname | type | required | description\n-----|------|----------|------------\nfield | string | no | The name of the field in the record to be filtered. The query compares the contents of the field parameter to the value of the operand parameter. If the specified field name is \".any\", the union of all field values will be searched. If the specified field name is \".ipaddr\" or \".port\", the client, server, sender, and receiver roles are included in the search. Field names are located in record formats that can be viewed in the ExtraHop system.\noperand | object or string or integer | no | The value that the query attempts to match. The query compares the value of the operand to the contents of the field parameter and applies the compare method specified by the operator parameter. You can explicitly specify the operand data type as described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#operand-values-in-record-queries).\noperator | string | yes | The compare method applied when matching the operand value against the field contents. All filter objects require an operator. \u003cbr\u003e**Supported values:** \"\u003e\", \"\u003c\", \"\u003c=\", \"\u003e=\", \"=\", \"!=\", \"startswith\", \"~\", \"!~\", \"and\", \"or\", \"not\", \"exists\", \"not_exists\", \"in\", \"not_in\"\nrules | array[filter] | no | The list of one or more filter objects within a single filter object. Filter objects can be embedded recursively. Only \"and\", \"or\", and \"not\" operators are allowed for this parameter.\n\n sort_item\n\nname | type | required | description\n-----|------|----------|------------\ndirection | string | no | The order in which returned records are sorted. The default order is descending. After all other sorting criteria are applied, or if no sorting criteria was specified, the default order is descending by timestamp. \u003cbr\u003e**Supported values:** \"asc\", \"desc\"\nfield | string | no | The field name that returned records are sorted by.\n",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The record log query.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/record_query"
                        }
                    }
                ],
                "operationId": "createRecordsSearch",
                "tags": [
                    "Record Log"
                ],
                "responses": {
                    "200": {
                        "description": "The request was successful.",
                        "schema": {
                            "$ref": "#/definitions/record_response"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The license on the EXA is invalid or the EXA cannot connect to the license server.",
                        "schema": {
                            "$ref": "#/definitions/license_errors"
                        }
                    },
                    "422": {
                        "description": "The query is invalid."
                    },
                    "502": {
                        "description": "The recordstore returned an error."
                    },
                    "504": {
                        "description": "The recordstore did not respond."
                    }
                },
                "deprecated": false
            }
        },
        "/runningconfig": {
            "get": {
                "summary": "Retrieve the current running configuration file.",
                "parameters": [
                    {
                        "name": "section",
                        "in": "query",
                        "description": "(Optional) The specific section of the running configuration file that you want to retrieve.",
                        "required": false,
                        "type": "string"
                    }
                ],
                "operationId": "getRunningconfig",
                "tags": [
                    "Running Config"
                ],
                "responses": {
                    "200": {
                        "description": "A single RunningConfig object",
                        "schema": {
                            "$ref": "#/definitions/RunningConfig"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Replace the current running configuration file. Configuration file changes are not automatically saved.",
                "description": "You can manually save changes to the running configuration file through `POST /runningconfig/save`. Unsaved changes are lost when the appliance reboots.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The running configuration file.",
                        "required": false,
                        "schema": {
                            "type": "string",
                            "description": "The running configuration file."
                        }
                    }
                ],
                "operationId": "replaceRunningconfig",
                "tags": [
                    "Running Config"
                ],
                "responses": {
                    "204": {
                        "description": "The running configuration file was uploaded successfully. If the uploaded config file is different from the previous file, a job was created to replace the previous file.",
                        "headers": {
                            "location": {
                                "description": "The relative URL that you can retrieve the status of the job from.",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/runningconfig/save": {
            "post": {
                "summary": "Save the current changes to the running configuration file.",
                "operationId": "createRunningconfigSave",
                "tags": [
                    "Running Config"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/runningconfig/saved": {
            "get": {
                "summary": "Retrieve the saved running configuration file.",
                "operationId": "getRunningconfigSaved",
                "tags": [
                    "Running Config"
                ],
                "responses": {
                    "200": {
                        "description": "A single RunningConfig object",
                        "schema": {
                            "$ref": "#/definitions/RunningConfig"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/software": {
            "get": {
                "summary": "Retrieve software observed by the ExtraHop system.",
                "parameters": [
                    {
                        "name": "software_type",
                        "in": "query",
                        "description": "The type of software.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "name",
                        "in": "query",
                        "description": "The name of the software.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "version",
                        "in": "query",
                        "description": "The version of the software.",
                        "required": false,
                        "type": "string"
                    }
                ],
                "operationId": "getAllAssignedSoftware",
                "tags": [
                    "Software"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Software objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Software"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/software/{id}": {
            "get": {
                "summary": "Retrieve software observed by the ExtraHop system by ID.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the software.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getSoftwareId",
                "tags": [
                    "Software"
                ],
                "responses": {
                    "200": {
                        "description": "A single Software object",
                        "schema": {
                            "$ref": "#/definitions/Software"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/ssldecryptkeys": {
            "get": {
                "summary": "Retrieve all SSL decryption keys.",
                "operationId": "getAllAssignedSsldecryptkeys",
                "tags": [
                    "SSL Decrypt Key"
                ],
                "responses": {
                    "200": {
                        "description": "An array of SSLDecryptKey objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/SSLDecryptKey"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new SSL decryption key.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncertificate | string | yes | The SSL certificate associated with this decryption key.\nenabled | boolean | yes | Indicate whether this SSL decryption key is active.\nname | string | yes | The friendly name for the SSL decryption key.\nprivate_key | string | yes | The SSL private key that decrypts traffic.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Set the specified property values on the new SSL decryption key.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/new_ssl_key"
                        }
                    }
                ],
                "operationId": "createSsldecryptkeys",
                "tags": [
                    "SSL Decrypt Key"
                ],
                "responses": {
                    "400": {
                        "description": "This appliance is not a sensor. The operation is only supported on sensors."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "Certificate is already associated with an SSL decryption key."
                    }
                },
                "deprecated": false
            }
        },
        "/ssldecryptkeys/{id}": {
            "delete": {
                "summary": "Remove an SSL key from the sensor.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The hexadecimal representation of the SHA-1 hash of the SSL decryption key. The string must not include delimiters.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteSsldecryptkeysId",
                "tags": [
                    "SSL Decrypt Key"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve an SSL PEM and metadata.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The hexadecimal representation of the SHA-1 hash of the SSL decryption key. The string must not include delimiters.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getSsldecryptkeysId",
                "tags": [
                    "SSL Decrypt Key"
                ],
                "responses": {
                    "200": {
                        "description": "A single SSLDecryptKey object",
                        "schema": {
                            "$ref": "#/definitions/SSLDecryptKey"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update an existing SSL decryption key.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nenabled | boolean | yes | Indicates whether the SSL decryption key is active.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property updates to the SSL decryption key.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/SSLDecryptKey_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The hexadecimal representation of the SHA-1 hash of the SSL decryption key. The string must not include delimiters.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "updateSsldecryptkeysId",
                "tags": [
                    "SSL Decrypt Key"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/ssldecryptkeys/{id}/protocols": {
            "get": {
                "summary": "Retrieve all protocols assigned to an SSL decryption key.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The hexadecimal representation of the SHA-1 hash of the SSL decryption key. The string must not include delimiters.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getAllAssignedSsldecryptkeysIdProtocols",
                "tags": [
                    "SSL Decrypt Key"
                ],
                "responses": {
                    "200": {
                        "description": "An array of SSLDecryptKeyProtocol objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/SSLDecryptKeyProtocol"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Add a protocol for an ssl decryption key.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nport | integer | yes | The port in which to listen for traffic.\nprotocol | string | yes | The name of the protocol, in lowercase.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The body of the protocol.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/SSLDecryptKeyProtocol_CREATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the SSL decrypt key.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "createSsldecryptkeysIdProtocols",
                "tags": [
                    "SSL Decrypt Key"
                ],
                "responses": {
                    "400": {
                        "description": "The specified protocol is already assigned to this port."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "The specified protocol is invalid."
                    }
                },
                "deprecated": false
            }
        },
        "/ssldecryptkeys/{id}/protocols/{protocol}": {
            "delete": {
                "summary": "Delete a protocol from an SSL decryption key.",
                "parameters": [
                    {
                        "name": "protocol",
                        "in": "path",
                        "description": "The name of the protocol, in lowercase.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The hexadecimal representation of the SHA-1 hash of the SSL decryption key. The string must not include delimiters.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "port",
                        "in": "query",
                        "description": "Remove only the protocols that are assigned on this port.",
                        "required": false,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteSsldecryptkeysIdProtocolsProtocol",
                "tags": [
                    "SSL Decrypt Key"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "The specified protocol has not been added to the given SSL decryption key or the key does not exist."
                    }
                },
                "deprecated": false
            }
        },
        "/supportpacks": {
            "get": {
                "summary": "Retrieve metadata about all support packs.",
                "operationId": "getAllAssignedSupportpacks",
                "tags": [
                    "Support Pack"
                ],
                "responses": {
                    "200": {
                        "description": "An array of SupportPack objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/SupportPack"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Upload and run a support pack.",
                "parameters": [
                    {
                        "name": "file",
                        "in": "formData",
                        "description": "The filename for the support pack.",
                        "required": true,
                        "type": "file",
                        "format": "file"
                    }
                ],
                "consumes": [
                    "multipart/form-data"
                ],
                "operationId": "createSupportpacks",
                "tags": [
                    "Support Pack"
                ],
                "responses": {
                    "202": {
                        "description": "The support pack was successfully uploaded and is now running on the system. The ID for the running script is provided in the Location header of the response. Send a GET request to /supportpacks/queue/{id} to view the status of the script."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/supportpacks/execute": {
            "post": {
                "summary": "Run the default support pack.",
                "operationId": "createSupportpacksExecute",
                "tags": [
                    "Support Pack"
                ],
                "responses": {
                    "202": {
                        "description": "The support pack script is now running on the system. The ID for the running script is provided in the Location header of the response. Send a GET request to /supportpacks/queue/{id} to view the status of the script."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/supportpacks/queue/{id}": {
            "get": {
                "summary": "Check on the status of an in-progress, running support pack.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the running support pack.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getSupportpacksQueueId",
                "tags": [
                    "Support Pack"
                ],
                "responses": {
                    "200": {
                        "description": "A single SupportPack object",
                        "schema": {
                            "$ref": "#/definitions/SupportPack"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/supportpacks/{filename}": {
            "get": {
                "summary": "Download an existing support pack by filename.",
                "description": "Retrieve a support pack by file name from the appliance. This request is intended for modeling only and will not successfully complete in the ExtraHop API Explorer. On a successful request outside of the API Explorer, a tar.gz file is downloaded.",
                "parameters": [
                    {
                        "name": "filename",
                        "in": "path",
                        "description": "The name of the support pack to download.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/x-gzip"
                ],
                "operationId": "getSupportpacksFilename",
                "tags": [
                    "Support Pack"
                ],
                "responses": {
                    "200": {
                        "description": "Successful request"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/tags": {
            "get": {
                "summary": "Retrieve all tags.",
                "operationId": "getAllAssignedTags",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Tag objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Tag"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new tag.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nname | string | yes | The string value for the tag.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property values to the new tag.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Tag_CREATE"
                        }
                    }
                ],
                "operationId": "createTags",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The specified tag name already exists."
                    }
                },
                "deprecated": false
            }
        },
        "/tags/{id}": {
            "delete": {
                "summary": "Delete a specific tag.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteTagsId",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific tag.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getTagsId",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "200": {
                        "description": "A single Tag object",
                        "schema": {
                            "$ref": "#/definitions/Tag"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Apply updates to a specific tag.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nname | string | yes | The string value for the tag.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to the tag.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Tag_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateTagsId",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/tags/{id}/devices": {
            "get": {
                "summary": "Retrieve all devices assigned to a specific tag.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedTagsIdDevices",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Device objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Device"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific tag to devices.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Lists of unique identifies for device to assign and unassign.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsTagsIdDevices",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/tags/{id}/devices/{child-id}": {
            "delete": {
                "summary": "Unassign a device from a specific tag.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignTagsIdDevicesChildId",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a device to a specific tag.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "the unique identifier for the tag.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignTagsIdDevicesChildId",
                "tags": [
                    "Tag"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/threatcollections": {
            "get": {
                "summary": "Retrieve metadata about all threat collections.",
                "operationId": "getAllAssignedThreatcollections",
                "tags": [
                    "Threat Collection"
                ],
                "responses": {
                    "200": {
                        "description": "An array of ThreatCollection objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/ThreatCollection"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new threat collection.",
                "description": "Note: We recommend that you do not manually upload STIX files through the REST API. Instead, [configure the ExtraHop system to retrieve threat collections from a TAXII server](https://docs.extrahop.com/9.8/threat-upload/#add-a-taxii-feed).",
                "parameters": [
                    {
                        "name": "user_key",
                        "in": "formData",
                        "description": "The user-supplied identifier for the threat collection. If this parameter is not specified, the threat collection name is set for this value, without spaces or punctuation.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "name",
                        "in": "formData",
                        "description": "The name for the threat collection.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "file",
                        "in": "formData",
                        "description": "The filename for the threat collection.",
                        "required": true,
                        "type": "file",
                        "format": "file"
                    }
                ],
                "consumes": [
                    "multipart/form-data"
                ],
                "operationId": "createThreatcollections",
                "tags": [
                    "Threat Collection"
                ],
                "responses": {
                    "204": {
                        "description": "Successfully created threat collection."
                    },
                    "400": {
                        "description": "The threat collection name or ID is not unique."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "The selected file does not contain any new threat intelligence data."
                    }
                },
                "deprecated": false
            }
        },
        "/threatcollections/{id}": {
            "delete": {
                "summary": "Delete a threat collection.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the threat collection.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteThreatcollectionsId",
                "tags": [
                    "Threat Collection"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/threatcollections/{id}/observables": {
            "get": {
                "summary": "Retrieve the number of STIX Observables loaded from a threat collection.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the threat collection.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getAllAssignedThreatcollectionsIdObservables",
                "tags": [
                    "Threat Collection"
                ],
                "responses": {
                    "200": {
                        "description": "The number of STIX Observables loaded from the threat collection file."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/threatcollections/~{userKey}": {
            "put": {
                "summary": "Upload a new threat collection, replacing any existing threat collection of the same source.",
                "description": "Note: We recommend that you do not manually upload STIX files through the REST API. Instead, [configure the ExtraHop system to retrieve threat collections from a TAXII server](https://docs.extrahop.com/9.8/threat-upload/#add-a-taxii-feed).",
                "parameters": [
                    {
                        "name": "userKey",
                        "in": "path",
                        "description": "The user-supplied identifier for the threat collection.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "name",
                        "in": "formData",
                        "description": "The name for the threat collection.",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "file",
                        "in": "formData",
                        "description": "The filename for the threat collection.",
                        "required": false,
                        "type": "file",
                        "format": "file"
                    }
                ],
                "consumes": [
                    "multipart/form-data"
                ],
                "operationId": "replaceThreatcollections~userKey",
                "tags": [
                    "Threat Collection"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/triggers": {
            "get": {
                "summary": "Retrieve all triggers.",
                "description": "For more information about the hints object, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#advanced-trigger-options).",
                "operationId": "getAllAssignedTriggers",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Trigger objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Trigger"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new trigger.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\napply_all | boolean | yes | Indicates whether the trigger applies to all relevant resources.\nauthor | string | no | The name of the creator of the trigger.\ndebug | boolean | yes | Indicates whether debug statements are printed for the trigger.\ndescription | string | no | An optional description of the trigger.\ndisabled | boolean | yes | Indicates whether the trigger can run.\nevent | string | no | Deprecated. Replaced by the events field.\nevents | array[string] | yes | The list of events on which the trigger runs, expressed as a JSON array.\nhints | object | no | Options that are based on selected trigger events. For more information about the hints object, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#advanced-trigger-options).\nname | string | yes | The friendly name for the trigger.\nscript | string | yes | The JavaScript content of the trigger.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The property values for the new trigger.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Trigger_CREATE"
                        }
                    }
                ],
                "operationId": "createTriggers",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "201": {
                        "description": "Request was successful and object created",
                        "headers": {
                            "location": {
                                "description": "Relative URL of created resource",
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/triggers/externaldata": {
            "post": {
                "summary": "Execute EXTERNAL_DATA event triggers.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nbody | object | no | The data to send to triggers through the EXTERNAL_DATA event. This data can be accessed in the trigger with the 'ExternalData.body' property.\ntype | string | no | A string identifier that describes the data contained in the body parameter. For example, you could specify 'phantom-data' for data sent from the Phantom SOAR platform.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The object containing the data to send to triggers through the EXTERNAL_DATA event.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/triggers_external_data"
                        }
                    }
                ],
                "operationId": "createTriggersExternaldata",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "The specified value for the name field already exists."
                    }
                },
                "deprecated": false
            }
        },
        "/triggers/{id}": {
            "delete": {
                "summary": "Delete a specific trigger.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "deleteTriggersId",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific trigger by unique identifier.",
                "description": "For more information about the hints object, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#advanced-trigger-options).",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getTriggersId",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "200": {
                        "description": "A single Trigger object",
                        "schema": {
                            "$ref": "#/definitions/Trigger"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update an existing trigger.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\napply_all | boolean | yes | Indicates whether the trigger applies to all relevant resources.\nauthor | string | no | The name of the creator of the trigger.\ndebug | boolean | yes | Indicates whether debug statements are printed for the trigger.\ndescription | string | no | An optional description of the trigger.\ndisabled | boolean | yes | Indicates whether the trigger can run.\nevent | string | no | Deprecated. Replaced by the events field.\nevents | array[string] | yes | The list of events on which the trigger runs, expressed as a JSON array.\nhints | object | no | Options that are based on selected trigger events. For more information about the hints object, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#advanced-trigger-options).\nname | string | yes | The friendly name for the trigger.\nscript | string | yes | The JavaScript content of the trigger.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The property value updates for the trigger.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Trigger_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateTriggersId",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/triggers/{id}/devicegroups": {
            "get": {
                "summary": "Retrieve all device groups that are assigned to a specific trigger.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedTriggersIdDevicegroups",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "200": {
                        "description": "An array of DeviceGroup objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceGroup"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific trigger to device groups.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "A list of unique identifiers for device groups that are assigned and unassigned to a trigger.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsTriggersIdDevicegroups",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/triggers/{id}/devicegroups/{child-id}": {
            "delete": {
                "summary": "Unassign a device group from a specific trigger.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignTriggersIdDevicegroupsChildId",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a device group to a specific trigger.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device group.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignTriggersIdDevicegroupsChildId",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/triggers/{id}/devices": {
            "get": {
                "summary": "Retrieve all devices that are assigned to a specific trigger.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getAllAssignedTriggersIdDevices",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Device objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Device"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign and unassign a specific trigger to devices.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "A list of unique identifiers for devices that are assigned and unassigned to a trigger.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "manageAssignmentsTriggersIdDevices",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "204": {
                        "description": "Assignments successfully modified"
                    },
                    "207": {
                        "description": "Updates partially successful, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "422": {
                        "description": "All updates failed, see message for more details",
                        "schema": {
                            "$ref": "#/definitions/partialsuccess"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/triggers/{id}/devices/{child-id}": {
            "delete": {
                "summary": "Unassign a device from a specific trigger.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignTriggersIdDevicesChildId",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Assign a device to a specific trigger.",
                "parameters": [
                    {
                        "name": "child-id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the trigger.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignTriggersIdDevicesChildId",
                "tags": [
                    "Trigger"
                ],
                "responses": {
                    "204": {
                        "description": "Assignment successfully modified"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/usergroups": {
            "get": {
                "summary": "Retrieve all user groups.",
                "operationId": "getAllAssignedUsergroups",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "200": {
                        "description": "An array of UserGroup objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/UserGroup"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new user group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nenabled | boolean | no | Indicates whether the user group is enabled.\nname | string | yes | The name for the user group.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The properties of the user group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/UserGroup_CREATE"
                        }
                    }
                ],
                "operationId": "createUsergroups",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "201": {
                        "description": "Successfully created the user group."
                    },
                    "400": {
                        "description": "The specified parameters for the user group are invalid.",
                        "schema": {
                            "$ref": "#/definitions/usergroup_bad_request"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "The specified user group name already exists.",
                        "schema": {
                            "$ref": "#/definitions/usergroup_bad_request"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/usergroups/refresh": {
            "post": {
                "summary": "Query LDAP for the most recent user memberships for all remote user groups.",
                "operationId": "createUsergroupsRefresh",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "204": {
                        "description": "A successful request."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/usergroups/{id}": {
            "delete": {
                "summary": "Delete a specific user group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the user group.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteUsergroupsId",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "204": {
                        "description": "Successfully deleted the user group."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "The specified user group was not found.",
                        "schema": {
                            "$ref": "#/definitions/usergroup_bad_request"
                        }
                    },
                    "422": {
                        "description": "You cannot delete remote user groups.",
                        "schema": {
                            "$ref": "#/definitions/usergroup_bad_request"
                        }
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific user group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the user group.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getUsergroupsId",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "200": {
                        "description": "A single UserGroup object",
                        "schema": {
                            "$ref": "#/definitions/UserGroup"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific user group.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nenabled | boolean | no | Indicates whether the user group is enabled.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The property value updates for the specific user group.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/UserGroup_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the user group.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "updateUsergroupsId",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/usergroups/{id}/associations": {
            "delete": {
                "summary": "Delete all dashboard sharing associations with a specific user group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the user group.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "deleteUsergroupsIdAssociations",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "204": {
                        "description": "A successful request."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/usergroups/{id}/members": {
            "get": {
                "summary": "Retrieve all members of a specific user group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the user group.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getAllAssignedUsergroupsIdMembers",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "200": {
                        "description": "An array of UserGroupMember objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/UserGroupMember"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Assign or unassign users to a user group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the user group.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "An object that specifies which users to asssign or unassign. Each key must be a username and each value must be either \"member\" or null.  For example {\"Alice\": \"member\", \"Bob\": null} assigns Alice to the group and unassigns Bob from the group.",
                        "required": true,
                        "schema": {
                            "type": "string",
                            "description": "An object that specifies which users to asssign or unassign. Each key must be a username and each value must be either \"member\" or null.  For example {\"Alice\": \"member\", \"Bob\": null} assigns Alice to the group and unassigns Bob from the group."
                        }
                    }
                ],
                "operationId": "updateUsergroupsIdMembers",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "put": {
                "summary": "Replace all the users assigned to the user group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the user group.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "description": "An object that specifies which users are assigned to the group. Each key must be a username and each value must be \"member\".  For example {\"Alice\": \"member\", \"Bob\": \"member\"} assigns Alice and Bob as the only members of the group.",
                        "required": true,
                        "schema": {
                            "type": "string",
                            "description": "An object that specifies which users are assigned to the group. Each key must be a username and each value must be \"member\".  For example {\"Alice\": \"member\", \"Bob\": \"member\"} assigns Alice and Bob as the only members of the group."
                        }
                    }
                ],
                "operationId": "replaceUsergroupsIdMembers",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/usergroups/{id}/refresh": {
            "post": {
                "summary": "Query LDAP for the most recent user membership of a specific remote user group.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the user group.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "createUsergroupsIdRefresh",
                "tags": [
                    "User Group"
                ],
                "responses": {
                    "204": {
                        "description": "A successful request."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/users": {
            "get": {
                "summary": "Retrieve all users.",
                "operationId": "getAllAssignedUsers",
                "tags": [
                    "User"
                ],
                "responses": {
                    "200": {
                        "description": "An array of User objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/User"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Create a new user.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ncreate_apikey | boolean | no | Generate and return a new API key for the created user.\neh_account_team | boolean | no | Indicates an ExtraHop Account Team user that accesses the ExtraHop system through ExtraHop Cloud Services.\nenabled | boolean | no | Indicates whether the user can login to the ExtraHop system.\ngranted_roles | object | no | The privileges for the user. Supported permission levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#privilege-levels).\nname | string | yes | The friendly name for the user.\npassword | string | yes | The password for the user. Passwords must meet the requirements configured in the Administration settings.\ntype | string | no | The authentication method used by this user to log in. \u003cbr\u003e**Supported values:** \"local\", \"remote\"\nusername | string | yes | The login name for the user.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The user account settings.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user_create_with_pw"
                        }
                    }
                ],
                "operationId": "createUsers",
                "tags": [
                    "User"
                ],
                "responses": {
                    "201": {
                        "description": "Resource successfully created.",
                        "schema": {
                            "$ref": "#/definitions/user_create_response"
                        }
                    },
                    "400": {
                        "description": "The specified parameters for the user are invalid.",
                        "schema": {
                            "$ref": "#/definitions/user_create_bad_request"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "The username is not available."
                    },
                    "422": {
                        "description": "The username and/or password do not meet policy requirements."
                    }
                },
                "deprecated": false
            }
        },
        "/users/{username}": {
            "delete": {
                "summary": "Delete a specific user.",
                "parameters": [
                    {
                        "name": "username",
                        "in": "path",
                        "description": "The name of the user.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "dest_user",
                        "in": "query",
                        "description": "The user that customizations are transferred to. If this parameter is specified, all dashboards, collections, and activity maps owned by the deleted user are transferred to this user.",
                        "required": false,
                        "type": "string"
                    }
                ],
                "operationId": "deleteUsersUsername",
                "tags": [
                    "User"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully deleted."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The user does not have permission to delete other users."
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "405": {
                        "description": "Cannot delete the user that owns the key used to send the request."
                    }
                },
                "deprecated": false
            },
            "get": {
                "summary": "Retrieve a specific user.",
                "parameters": [
                    {
                        "name": "username",
                        "in": "path",
                        "description": "The name of the user.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getUsersUsername",
                "tags": [
                    "User"
                ],
                "responses": {
                    "200": {
                        "description": "A single User object",
                        "schema": {
                            "$ref": "#/definitions/User"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update settings for a specific user.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nenabled | boolean | no | Indicates whether the user can login to the ExtraHop system.\ngranted_roles | object | no | The privileges for the user. Supported permission levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#privilege-levels).\nname | string | no | The friendly name for the user.\npassword | string | no | The password for the user. Passwords must meet the requirements configured in the Administration settings.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "The user account settings.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user_update_with_pw"
                        }
                    },
                    {
                        "name": "username",
                        "in": "path",
                        "description": "The name of the user.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "updateUsersUsername",
                "tags": [
                    "User"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "403": {
                        "description": "The requesting user does not have permission to change the passwords of other users."
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "The user does not have permission to modify the enabled or name properties of their account."
                    },
                    "422": {
                        "description": "Cannot update a password for a non-local user."
                    }
                },
                "deprecated": false
            }
        },
        "/users/{username}/apikeys": {
            "get": {
                "summary": "Retrieve all API keys for a specific user.",
                "parameters": [
                    {
                        "name": "username",
                        "in": "path",
                        "description": "The name of the user.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getAllAssignedUsersUsernameApikeys",
                "tags": [
                    "User"
                ],
                "responses": {
                    "200": {
                        "description": "An array of APIKey objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/APIKey"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/users/{username}/apikeys/{keyid}": {
            "get": {
                "summary": "Deprecated. Replaced by the GET /apikeys/{keyid} operation.",
                "parameters": [
                    {
                        "name": "keyid",
                        "in": "path",
                        "description": "The ID of the API key.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "username",
                        "in": "path",
                        "description": "The name of the user.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "operationId": "getUsersUsernameApikeysKeyid",
                "tags": [
                    "User"
                ],
                "responses": {
                    "301": {
                        "description": "Requested API key successfully found."
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "The requested API key does not exist for the specified user."
                    }
                },
                "deprecated": false
            }
        },
        "/vlans": {
            "get": {
                "summary": "Retrieve all VLANs.",
                "operationId": "getAllAssignedVlans",
                "tags": [
                    "Vlan"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Vlan objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Vlan"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/vlans/{id}": {
            "get": {
                "summary": "Retrieve a specific VLAN.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the VLAN.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "getVlansId",
                "tags": [
                    "Vlan"
                ],
                "responses": {
                    "200": {
                        "description": "A single Vlan object",
                        "schema": {
                            "$ref": "#/definitions/Vlan"
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "patch": {
                "summary": "Update a specific VLAN.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\ndescription | string | no | An optional description for the VLAN.\nname | string | no | The friendly name for the VLAN.",
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "description": "Apply the specified property value updates to the VLAN.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/Vlan_UPDATE"
                        }
                    },
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the VLAN.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "updateVlansId",
                "tags": [
                    "Vlan"
                ],
                "responses": {
                    "204": {
                        "description": "Resource successfully updated"
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            }
        },
        "/watchlist/device/{id}": {
            "delete": {
                "summary": "Remove a device from the watchlist.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "unassignWatchlistDeviceId",
                "tags": [
                    "Watchlist"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "You cannot update a sensor watchlist from a console when the analysis priorities are managed by the sensor."
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Add a device to the watchlist.",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "description": "The unique identifier for the device.",
                        "required": true,
                        "type": "integer",
                        "format": "int64"
                    }
                ],
                "operationId": "assignWatchlistDeviceId",
                "tags": [
                    "Watchlist"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "You cannot update a sensor watchlist from a console when the analysis priorities are managed by the sensor."
                    }
                },
                "deprecated": false
            }
        },
        "/watchlist/devices": {
            "get": {
                "summary": "Retrieve all devices that are in the watchlist.",
                "operationId": "getAllAssignedWatchlistDevices",
                "tags": [
                    "Watchlist"
                ],
                "responses": {
                    "200": {
                        "description": "An array of Device objects",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Device"
                            }
                        }
                    },
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    }
                },
                "deprecated": false
            },
            "post": {
                "summary": "Add or remove devices from the watchlist.",
                "description": "\n\n# Body Parameters\n\nname | type | required | description\n-----|------|----------|------------\nassign | array[integer] | no | IDs of resources to assign\nunassign | array[integer] | no | IDs of resources to unassign",
                "parameters": [
                    {
                        "name": "assignments",
                        "in": "body",
                        "description": "A list of devices to add to or remove from the watchlist.",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/assignment"
                        }
                    }
                ],
                "operationId": "manageAssignmentsWatchlistDevices",
                "tags": [
                    "Watchlist"
                ],
                "responses": {
                    "401": {
                        "description": "API key is missing or invalid",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "402": {
                        "description": "The EULA has not been accepted for this appliance",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "404": {
                        "description": "Requested resource could not be found",
                        "schema": {
                            "$ref": "#/definitions/error"
                        }
                    },
                    "409": {
                        "description": "You cannot update a sensor watchlist from a console when the analysis priorities are managed by the sensor."
                    }
                },
                "deprecated": false
            }
        }
    },
    "definitions": {
        "int": {
            "type": "integer",
            "format": "int64"
        },
        "APIKey": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description for the API key."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the API key."
                },
                "key": {
                    "type": "string",
                    "description": "The last 4 digits of the API key."
                },
                "time_added": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp when the API key was created. The timestamp is expressed in milliseconds since the epoch."
                },
                "user_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Deprecated. Replaced by the username field."
                },
                "username": {
                    "type": "string",
                    "description": "The username associated with the API key."
                }
            },
            "required": [
                "id",
                "key"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "key",
                "user_id",
                "description",
                "username",
                "time_added"
            ],
            "x-unsettable": [
                "id",
                "key",
                "user_id",
                "description",
                "username",
                "time_added"
            ]
        },
        "ActivityMap": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description for the activity map."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the activity map."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp of the most recent update to the activity map, expressed in milliseconds since the epoch."
                },
                "mode": {
                    "type": "string",
                    "default": "2dforce",
                    "description": "The layout of the activity map. Supported values are \"2dforce\" and \"3dforce\"."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the activity map."
                },
                "owner": {
                    "type": "string",
                    "description": "The user that owns the activity map."
                },
                "rights": {
                    "type": "array",
                    "format": "Rights",
                    "items": {
                        "type": "string"
                    },
                    "enum": [
                        "view",
                        "edit",
                        "transfer",
                        "delete",
                        "share"
                    ],
                    "description": "The permissions the current user has for the activity map."
                },
                "short_code": {
                    "type": "string",
                    "description": "The unique short code that is global to all activity maps."
                },
                "show_alert_status": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether to show the alert status for devices on the activity map. If enabled, the color of each device on the map represents the most severe alert level associated with the device."
                },
                "walks": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/walk"
                    },
                    "description": "The list of one or more walk objects. A walk is the path of traffic composed of one or more steps. Each walk begins with one or more origin devices and expands to connections to peer devices that are based on protocol activity. Each expansion from the origin is a step. The contents of the object are defined in the \"walk\" section below."
                },
                "weighting": {
                    "type": "string",
                    "default": "bytes",
                    "description": "The metric value that determines how activity is weighted between devices. Supported element values are \"bytes\", \"connections\", and \"turns\"."
                }
            },
            "required": [
                "id",
                "name",
                "walks"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "mod_time",
                "rights"
            ],
            "x-unsettable": [
                "id",
                "owner",
                "mod_time",
                "rights"
            ]
        },
        "ActivityMapSharing": {
            "properties": {
                "anyone": {
                    "type": "string",
                    "description": "The activity map permission level of all local or remote users in the sensor or console. Supported permission levels are \"viewer\" and \"null\"."
                },
                "groups": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "All of the user groups and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the sensor or console, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard."
                },
                "users": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "All of the users and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard."
                }
            },
            "required": [
                "users",
                "groups"
            ],
            "type": "object"
        },
        "ActivityMapSharing_REPLACE": {
            "properties": {
                "anyone": {
                    "type": "string",
                    "description": "The activity map permission level of all local or remote users in the sensor or console. Supported permission levels are \"viewer\" and \"null\"."
                },
                "groups": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "All of the user groups and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the sensor or console, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard."
                },
                "users": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "All of the users and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard."
                }
            },
            "required": [
                "users",
                "groups"
            ],
            "type": "object"
        },
        "ActivityMapSharing_UPDATE": {
            "properties": {
                "anyone": {
                    "type": "string",
                    "description": "The activity map permission level of all local or remote users in the sensor or console. Supported permission levels are \"viewer\" and \"null\"."
                },
                "groups": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "All of the user groups and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the sensor or console, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard."
                },
                "users": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "All of the users and their permission levels for the shared activity map. Supported permission levels are \"editor\", \"viewer\", and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard."
                }
            },
            "required": [
                "users",
                "groups"
            ],
            "type": "object"
        },
        "ActivityMap_CREATE": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description for the activity map."
                },
                "mode": {
                    "type": "string",
                    "default": "2dforce",
                    "description": "The layout of the activity map. Supported values are \"2dforce\" and \"3dforce\"."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the activity map."
                },
                "short_code": {
                    "type": "string",
                    "description": "The unique short code that is global to all activity maps."
                },
                "show_alert_status": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether to show the alert status for devices on the activity map. If enabled, the color of each device on the map represents the most severe alert level associated with the device."
                },
                "walks": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/walk"
                    },
                    "description": "The list of one or more walk objects. A walk is the path of traffic composed of one or more steps. Each walk begins with one or more origin devices and expands to connections to peer devices that are based on protocol activity. Each expansion from the origin is a step. The contents of the object are defined in the \"walk\" section below."
                },
                "weighting": {
                    "type": "string",
                    "default": "bytes",
                    "description": "The metric value that determines how activity is weighted between devices. Supported element values are \"bytes\", \"connections\", and \"turns\"."
                }
            },
            "required": [
                "name",
                "walks"
            ],
            "type": "object"
        },
        "ActivityMap_UPDATE": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description for the activity map."
                },
                "mode": {
                    "type": "string",
                    "default": "2dforce",
                    "description": "The layout of the activity map. Supported values are \"2dforce\" and \"3dforce\"."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the activity map."
                },
                "owner": {
                    "type": "string",
                    "description": "The user that owns the activity map."
                },
                "short_code": {
                    "type": "string",
                    "description": "The unique short code that is global to all activity maps."
                },
                "show_alert_status": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether to show the alert status for devices on the activity map. If enabled, the color of each device on the map represents the most severe alert level associated with the device."
                },
                "walks": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/walk"
                    },
                    "description": "The list of one or more walk objects. A walk is the path of traffic composed of one or more steps. Each walk begins with one or more origin devices and expands to connections to peer devices that are based on protocol activity. Each expansion from the origin is a step. The contents of the object are defined in the \"walk\" section below."
                },
                "weighting": {
                    "type": "string",
                    "default": "bytes",
                    "description": "The metric value that determines how activity is weighted between devices. Supported element values are \"bytes\", \"connections\", and \"turns\"."
                }
            },
            "required": [
                "name",
                "walks"
            ],
            "type": "object",
            "x-unsettable": [
                "owner"
            ]
        },
        "Alert": {
            "properties": {
                "apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the alert is assigned to all available data sources."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the user that created the alert."
                },
                "categories": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of one or more detection categories. An alert is generated only if a detection is identified in the specified categories. Only applicable to detection alerts."
                },
                "cc": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of email addresses, not included in an email group, to receive notifications."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the alert."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the alert is disabled."
                },
                "field_name": {
                    "type": "string",
                    "description": "The name of the monitored metric. Only applicable to threshold alerts."
                },
                "field_name2": {
                    "type": "string",
                    "description": "The second monitored metric when applying a ratio. Only applicable to threshold alerts."
                },
                "field_op": {
                    "type": "string",
                    "enum": [
                        "/",
                        "null"
                    ],
                    "description": "The type of comparison between the field_name and field_name2 fields when applying a ratio. Only applicable to threshold alerts."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the alert."
                },
                "interval_length": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        30,
                        60,
                        120,
                        300,
                        600,
                        900,
                        1200,
                        1800
                    ],
                    "default": 30,
                    "description": "The length of the alert interval, expressed in seconds.  Only applicable to threshold alerts."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The unique, friendly name for the alert."
                },
                "notify_snmp": {
                    "type": "boolean",
                    "default": true,
                    "description": "Indicates whether to send an SNMP trap when an alert is generated."
                },
                "object_type": {
                    "type": "string",
                    "enum": [
                        "application",
                        "device"
                    ],
                    "description": "The type of metric source monitored by the alert configuration. Only applicable to detection alerts."
                },
                "operand": {
                    "type": "string",
                    "description": "The value to compare against alert conditions. The compare method is specified by the value of the operator field. Only applicable to threshold alerts."
                },
                "operator": {
                    "type": "string",
                    "enum": [
                        "==",
                        "\u003e",
                        "\u003c",
                        "\u003e=",
                        "\u003c="
                    ],
                    "description": "The logical operator applied when comparing the value of the operand field to alert conditions. Only applicable to threshold alerts."
                },
                "param": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The first alert parameter, which is either a key pattern or a data point.  Only applicable to threshold alerts."
                },
                "param2": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The second alert parameter, which is either a key pattern or a data point. Only applicable to threshold alerts."
                },
                "protocols": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of monitored protocols. Only applicable to detection alerts."
                },
                "refire_interval": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        300,
                        600,
                        900,
                        1800,
                        3600,
                        7200,
                        14400
                    ],
                    "description": "The time interval in which alert conditions are monitored, expressed in seconds."
                },
                "severity": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    "default": 3,
                    "description": "The severity level of the alert, which is displayed in the Alert History, email notifications, and SNMP traps. Severity levels 0-2 require immediate attention. Severity levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#alert-severity-levels)."
                },
                "stat_name": {
                    "type": "string",
                    "description": "The statistic name for the alert. Only applicable to threshold alerts."
                },
                "type": {
                    "type": "string",
                    "enum": [
                        "threshold"
                    ],
                    "default": "threshold",
                    "description": "The type of alert."
                },
                "units": {
                    "type": "string",
                    "enum": [
                        "none",
                        "period",
                        "1 sec",
                        "1 min",
                        "1 hr"
                    ],
                    "default": "none",
                    "description": "The interval in which to evaluate the alert condition. Only applicable to threshold alerts."
                }
            },
            "required": [
                "id",
                "mod_time",
                "name",
                "apply_all",
                "type"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "mod_time"
            ],
            "x-unsettable": [
                "id",
                "mod_time"
            ]
        },
        "AlertAdditionalStat": {
            "properties": {
                "alert_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the alert."
                },
                "field_name": {
                    "type": "string",
                    "description": "The name of the field."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the additional alert statistic."
                },
                "param": {
                    "type": "string",
                    "description": "The parameter associated with this statistic."
                },
                "stat_name": {
                    "type": "string",
                    "description": "The name of the statistic."
                }
            },
            "required": [
                "id",
                "stat_name",
                "field_name",
                "alert_id"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "stat_name",
                "field_name",
                "alert_id",
                "param"
            ],
            "x-unsettable": [
                "id",
                "stat_name",
                "field_name",
                "alert_id",
                "param"
            ]
        },
        "Alert_CREATE": {
            "properties": {
                "apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the alert is assigned to all available data sources."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the user that created the alert."
                },
                "categories": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of one or more detection categories. An alert is generated only if a detection is identified in the specified categories. Only applicable to detection alerts."
                },
                "cc": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of email addresses, not included in an email group, to receive notifications."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the alert."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the alert is disabled."
                },
                "field_name": {
                    "type": "string",
                    "description": "The name of the monitored metric. Only applicable to threshold alerts."
                },
                "field_name2": {
                    "type": "string",
                    "description": "The second monitored metric when applying a ratio. Only applicable to threshold alerts."
                },
                "field_op": {
                    "type": "string",
                    "enum": [
                        "/",
                        "null"
                    ],
                    "description": "The type of comparison between the field_name and field_name2 fields when applying a ratio. Only applicable to threshold alerts."
                },
                "interval_length": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        30,
                        60,
                        120,
                        300,
                        600,
                        900,
                        1200,
                        1800
                    ],
                    "default": 30,
                    "description": "The length of the alert interval, expressed in seconds.  Only applicable to threshold alerts."
                },
                "name": {
                    "type": "string",
                    "description": "The unique, friendly name for the alert."
                },
                "notify_snmp": {
                    "type": "boolean",
                    "default": true,
                    "description": "Indicates whether to send an SNMP trap when an alert is generated."
                },
                "object_type": {
                    "type": "string",
                    "enum": [
                        "application",
                        "device"
                    ],
                    "description": "The type of metric source monitored by the alert configuration. Only applicable to detection alerts."
                },
                "operand": {
                    "type": "string",
                    "description": "The value to compare against alert conditions. The compare method is specified by the value of the operator field. Only applicable to threshold alerts."
                },
                "operator": {
                    "type": "string",
                    "enum": [
                        "==",
                        "\u003e",
                        "\u003c",
                        "\u003e=",
                        "\u003c="
                    ],
                    "description": "The logical operator applied when comparing the value of the operand field to alert conditions. Only applicable to threshold alerts."
                },
                "param": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The first alert parameter, which is either a key pattern or a data point.  Only applicable to threshold alerts."
                },
                "param2": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The second alert parameter, which is either a key pattern or a data point. Only applicable to threshold alerts."
                },
                "protocols": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of monitored protocols. Only applicable to detection alerts."
                },
                "refire_interval": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        300,
                        600,
                        900,
                        1800,
                        3600,
                        7200,
                        14400
                    ],
                    "description": "The time interval in which alert conditions are monitored, expressed in seconds."
                },
                "severity": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    "default": 3,
                    "description": "The severity level of the alert, which is displayed in the Alert History, email notifications, and SNMP traps. Severity levels 0-2 require immediate attention. Severity levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#alert-severity-levels)."
                },
                "stat_name": {
                    "type": "string",
                    "description": "The statistic name for the alert. Only applicable to threshold alerts."
                },
                "type": {
                    "type": "string",
                    "enum": [
                        "threshold"
                    ],
                    "default": "threshold",
                    "description": "The type of alert."
                },
                "units": {
                    "type": "string",
                    "enum": [
                        "none",
                        "period",
                        "1 sec",
                        "1 min",
                        "1 hr"
                    ],
                    "default": "none",
                    "description": "The interval in which to evaluate the alert condition. Only applicable to threshold alerts."
                }
            },
            "required": [
                "name",
                "apply_all",
                "type"
            ],
            "type": "object"
        },
        "Alert_UPDATE": {
            "properties": {
                "apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the alert is assigned to all available data sources."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the user that created the alert."
                },
                "categories": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of one or more detection categories. An alert is generated only if a detection is identified in the specified categories. Only applicable to detection alerts."
                },
                "cc": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of email addresses, not included in an email group, to receive notifications."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the alert."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the alert is disabled."
                },
                "field_name": {
                    "type": "string",
                    "description": "The name of the monitored metric. Only applicable to threshold alerts."
                },
                "field_name2": {
                    "type": "string",
                    "description": "The second monitored metric when applying a ratio. Only applicable to threshold alerts."
                },
                "field_op": {
                    "type": "string",
                    "enum": [
                        "/",
                        "null"
                    ],
                    "description": "The type of comparison between the field_name and field_name2 fields when applying a ratio. Only applicable to threshold alerts."
                },
                "interval_length": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        30,
                        60,
                        120,
                        300,
                        600,
                        900,
                        1200,
                        1800
                    ],
                    "default": 30,
                    "description": "The length of the alert interval, expressed in seconds.  Only applicable to threshold alerts."
                },
                "name": {
                    "type": "string",
                    "description": "The unique, friendly name for the alert."
                },
                "notify_snmp": {
                    "type": "boolean",
                    "default": true,
                    "description": "Indicates whether to send an SNMP trap when an alert is generated."
                },
                "object_type": {
                    "type": "string",
                    "enum": [
                        "application",
                        "device"
                    ],
                    "description": "The type of metric source monitored by the alert configuration. Only applicable to detection alerts."
                },
                "operand": {
                    "type": "string",
                    "description": "The value to compare against alert conditions. The compare method is specified by the value of the operator field. Only applicable to threshold alerts."
                },
                "operator": {
                    "type": "string",
                    "enum": [
                        "==",
                        "\u003e",
                        "\u003c",
                        "\u003e=",
                        "\u003c="
                    ],
                    "description": "The logical operator applied when comparing the value of the operand field to alert conditions. Only applicable to threshold alerts."
                },
                "param": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The first alert parameter, which is either a key pattern or a data point.  Only applicable to threshold alerts."
                },
                "param2": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The second alert parameter, which is either a key pattern or a data point. Only applicable to threshold alerts."
                },
                "protocols": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of monitored protocols. Only applicable to detection alerts."
                },
                "refire_interval": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        300,
                        600,
                        900,
                        1800,
                        3600,
                        7200,
                        14400
                    ],
                    "description": "The time interval in which alert conditions are monitored, expressed in seconds."
                },
                "severity": {
                    "type": "integer",
                    "format": "int64",
                    "enum": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    "default": 3,
                    "description": "The severity level of the alert, which is displayed in the Alert History, email notifications, and SNMP traps. Severity levels 0-2 require immediate attention. Severity levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#alert-severity-levels)."
                },
                "stat_name": {
                    "type": "string",
                    "description": "The statistic name for the alert. Only applicable to threshold alerts."
                },
                "type": {
                    "type": "string",
                    "enum": [
                        "threshold"
                    ],
                    "default": "threshold",
                    "description": "The type of alert."
                },
                "units": {
                    "type": "string",
                    "enum": [
                        "none",
                        "period",
                        "1 sec",
                        "1 min",
                        "1 hr"
                    ],
                    "default": "none",
                    "description": "The interval in which to evaluate the alert condition. Only applicable to threshold alerts."
                }
            },
            "required": [
                "name",
                "apply_all",
                "type"
            ],
            "type": "object"
        },
        "AnalysisPriority": {
            "properties": {},
            "type": "object"
        },
        "Appliance": {
            "properties": {
                "add_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp that the connection to the remote appliance was added, expressed in milliseconds since the epoch."
                },
                "advanced_analysis_capacity": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The maximum number of devices that can be in Advanced Analysis on the appliance, which is determined by your license."
                },
                "analysis_levels_managed": {
                    "type": "boolean",
                    "description": "Whether or not this appliance manages the analysis levels for this node."
                },
                "connection_type": {
                    "type": "string",
                    "enum": [
                        "tunneled",
                        "direct",
                        "local",
                        "cloud_switchboard"
                    ],
                    "description": "The type of connection to the appliance."
                },
                "data_access": {
                    "type": "boolean",
                    "description": "Indicates whether data can be shared between the local and remote appliances."
                },
                "display_name": {
                    "type": "string",
                    "description": "The display name of the appliance. If a nickname is specified, the display name is the nickname. Otherwise, the display name is the appliance hostname."
                },
                "fingerprint": {
                    "type": "string",
                    "description": "The fingerprint of the remote appliance."
                },
                "firmware_version": {
                    "type": "string",
                    "description": "The current firmware version of the remote appliance."
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname of the remote appliance."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the remote appliance."
                },
                "license_platform": {
                    "type": "string",
                    "description": "The platform specified in the license."
                },
                "license_status": {
                    "type": "string",
                    "enum": [
                        "Unknown",
                        "Nominal",
                        "Invalid",
                        "Self Destruct",
                        "Disconnected",
                        "Pre-Expired",
                        "Pre-Disconnected"
                    ],
                    "description": "The license status of the remote appliance."
                },
                "licensed_features": {
                    "type": "object",
                    "format": "json",
                    "description": "An object that specifies which features are licensed on the appliance."
                },
                "licensed_modules": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of modules specified in the license."
                },
                "managed_by_local": {
                    "type": "boolean",
                    "description": "Indicates whether the remote appliance is managed by the local appliance."
                },
                "manages_local": {
                    "type": "boolean",
                    "description": "Indicates whether the remote appliance manages the local appliance."
                },
                "nickname": {
                    "type": "string",
                    "description": "The nickname for the appliance"
                },
                "platform": {
                    "type": "string",
                    "enum": [
                        "command",
                        "discover",
                        "trace",
                        "explore",
                        "unknown"
                    ],
                    "description": "The platform type of the remote appliance."
                },
                "status_message": {
                    "type": "string",
                    "description": "The status message for the appliance."
                },
                "sync_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp of the most recent sync between the local and remote appliances, expressed in seconds since the epoch."
                },
                "total_capacity": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The total number of devices that can be discovered on the appliance, which is determined by your license."
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the remote appliance."
                }
            },
            "required": [
                "id",
                "uuid",
                "hostname",
                "platform",
                "connection_type",
                "advanced_analysis_capacity",
                "total_capacity",
                "analysis_levels_managed",
                "nickname",
                "display_name"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "uuid",
                "hostname",
                "platform",
                "firmware_version",
                "license_status",
                "licensed_features",
                "license_platform",
                "licensed_modules",
                "status_message",
                "connection_type",
                "manages_local",
                "managed_by_local",
                "data_access",
                "fingerprint",
                "add_time",
                "sync_time",
                "advanced_analysis_capacity",
                "total_capacity",
                "analysis_levels_managed",
                "nickname",
                "display_name"
            ],
            "x-unsettable": [
                "id",
                "uuid",
                "hostname",
                "platform",
                "firmware_version",
                "license_status",
                "licensed_features",
                "license_platform",
                "licensed_modules",
                "status_message",
                "connection_type",
                "manages_local",
                "managed_by_local",
                "data_access",
                "fingerprint",
                "add_time",
                "sync_time",
                "advanced_analysis_capacity",
                "total_capacity",
                "analysis_levels_managed",
                "nickname",
                "display_name"
            ]
        },
        "ApplianceApplianceConnectDisconnect": {
            "properties": {},
            "type": "object"
        },
        "ApplianceCloudServices": {
            "properties": {
                "connection_status": {
                    "type": "string",
                    "enum": [
                        "connected",
                        "reconnecting",
                        "disconnected",
                        "not_licensed"
                    ],
                    "description": "The status of the connection to ExtraHop Cloud Services."
                },
                "connection_status_color": {
                    "type": "string",
                    "enum": [
                        "green",
                        "yellow",
                        "red"
                    ],
                    "description": "The color that represents the status of the connection to ExtraHop Cloud Services."
                },
                "enabled_services": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ExtraHop cloud-based services that are enabled on the specified appliance."
                },
                "last_active_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The most recent time that ExtraHop Cloud Services retrieved metric information from the appliance, expressed as milliseconds since the epoch."
                },
                "last_analyzed_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The most recent time that ExtraHop Cloud Services analyzed metric information from the appliance, expressed as milliseconds since the epoch."
                }
            },
            "required": [
                "enabled_services",
                "connection_status"
            ],
            "type": "object",
            "x-uneditable": [
                "enabled_services",
                "connection_status",
                "connection_status_color",
                "last_active_time",
                "last_analyzed_time"
            ],
            "x-unsettable": [
                "enabled_services",
                "connection_status",
                "connection_status_color",
                "last_active_time",
                "last_analyzed_time"
            ]
        },
        "ApplianceProductKey": {
            "properties": {
                "product_key": {
                    "type": "string",
                    "description": "The product key of the specified appliance."
                }
            },
            "type": "object",
            "x-uneditable": [
                "product_key"
            ],
            "x-unsettable": [
                "product_key"
            ]
        },
        "Application": {
            "properties": {
                "criteria": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/criteria"
                    },
                    "description": "An array of protocol and source criteria associated with the application. The contents of this array are defined in the 'criteria' section below."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the application."
                },
                "discovery_id": {
                    "type": "string",
                    "description": "The unique identifier for the application, which is displayed on the application page in the ExtraHop system."
                },
                "display_name": {
                    "type": "string",
                    "description": "The friendly name for the application."
                },
                "extrahop_id": {
                    "type": "string",
                    "description": "Deprecated. Replaced by the discovery_id field."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the application in a metric query."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update, expressed in milliseconds since the epoch."
                },
                "node_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the sensor that this application is associated with. The identifier can be retrieved through the GET /appliances operation. This field is valid only on a console."
                },
                "user_mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update from the user, expressed in milliseconds since the epoch."
                }
            },
            "required": [
                "mod_time",
                "user_mod_time",
                "id",
                "extrahop_id",
                "discovery_id",
                "display_name"
            ],
            "type": "object",
            "x-uneditable": [
                "mod_time",
                "user_mod_time",
                "node_id",
                "id",
                "extrahop_id",
                "discovery_id"
            ],
            "x-unsettable": [
                "mod_time",
                "user_mod_time",
                "id",
                "extrahop_id"
            ]
        },
        "ApplicationActivity": {
            "properties": {
                "application_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the connected application."
                },
                "from_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp marking the beginning of the activity, expressed in milliseconds since the epoch."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the activity."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp of the most recent update, expressed in milliseconds since the epoch."
                },
                "stat_name": {
                    "type": "string",
                    "description": "The name of the statistic that was active."
                },
                "until_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp marking the end of the activity, expressed in milliseconds since the epoch."
                }
            },
            "required": [
                "id",
                "from_time",
                "until_time",
                "mod_time",
                "application_id",
                "stat_name"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "from_time",
                "until_time",
                "mod_time",
                "application_id",
                "stat_name"
            ],
            "x-unsettable": [
                "id",
                "from_time",
                "until_time",
                "mod_time",
                "application_id",
                "stat_name"
            ]
        },
        "Application_CREATE": {
            "properties": {
                "criteria": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/criteria"
                    },
                    "description": "An array of protocol and source criteria associated with the application. The contents of this array are defined in the 'criteria' section below."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the application."
                },
                "discovery_id": {
                    "type": "string",
                    "description": "The unique identifier for the application, which is displayed on the application page in the ExtraHop system."
                },
                "display_name": {
                    "type": "string",
                    "description": "The friendly name for the application."
                },
                "node_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the sensor that this application is associated with. The identifier can be retrieved through the GET /appliances operation. This field is valid only on a console."
                }
            },
            "required": [
                "discovery_id",
                "display_name"
            ],
            "type": "object",
            "x-uneditable": [
                "node_id",
                "discovery_id"
            ]
        },
        "Application_UPDATE": {
            "properties": {
                "criteria": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/criteria"
                    },
                    "description": "An array of protocol and source criteria associated with the application. The contents of this array are defined in the 'criteria' section below."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the application."
                },
                "display_name": {
                    "type": "string",
                    "description": "The friendly name for the application."
                }
            },
            "required": [
                "display_name"
            ],
            "type": "object"
        },
        "AuditLog": {
            "properties": {
                "body": {
                    "type": "object",
                    "format": "json",
                    "description": "The contents of the audit log. Log messages are displayed in descending chronological order."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the audit log."
                },
                "occur_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp when the audit log was created, expressed in milliseconds since the epoch."
                },
                "time": {
                    "type": "string",
                    "description": "Deprecated. Replaced by the occur_time field."
                }
            },
            "required": [
                "id",
                "time",
                "body"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "time",
                "occur_time",
                "body"
            ],
            "x-unsettable": [
                "id",
                "time",
                "occur_time",
                "body"
            ]
        },
        "Auth": {
            "properties": {},
            "type": "object"
        },
        "AuthIdentityProvider": {
            "properties": {
                "auto_provision_users": {
                    "type": "boolean",
                    "description": "Indicates whether a user can be created on the ExtraHop system from the identity provider."
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether authentication through the identity provider is enabled on the ExtraHop system."
                },
                "entity_id": {
                    "type": "string",
                    "description": "The SAML 2.0 entityID."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the identity provider."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the identity provider."
                },
                "signing_certificate": {
                    "type": "string",
                    "description": "The SAML 2.0 X.509 signing certificate in PEM format."
                },
                "sso_url": {
                    "type": "string",
                    "description": "The SAML 2.0 Single Sign-On (SSO) URL."
                },
                "type": {
                    "type": "string",
                    "enum": [
                        "saml"
                    ],
                    "description": "The type of identity provider."
                }
            },
            "required": [
                "name",
                "enabled",
                "type",
                "auto_provision_users"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "type"
            ],
            "x-unsettable": [
                "id"
            ]
        },
        "AuthIdentityProviderSamlAttributeMap": {
            "properties": {
                "detectionsaccesslevel": {
                    "format": "detectionsaccesslevel_map",
                    "$ref": "#/definitions/detectionsaccesslevel_map",
                    "description": "Deprecated. Replaced by the ndrlevel field."
                },
                "ndrlevel": {
                    "format": "ndrlevel_map",
                    "$ref": "#/definitions/ndrlevel_map",
                    "description": "An object that maps a SAML attribute to NDR privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels)."
                },
                "npmlevel": {
                    "format": "npmlevel_map",
                    "$ref": "#/definitions/npmlevel_map",
                    "description": "An object that maps a SAML attribute to NPM privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels)."
                },
                "packetslevel": {
                    "format": "packetslevel_map",
                    "$ref": "#/definitions/packetslevel_map",
                    "description": "An object that maps a SAML attribute to packet privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels)."
                },
                "writelevel": {
                    "format": "writelevel_map",
                    "$ref": "#/definitions/writelevel_map",
                    "description": "An object that maps a SAML attribute to write privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels)."
                }
            },
            "type": "object",
            "x-unsettable": [
                "ndrlevel",
                "npmlevel",
                "writelevel",
                "packetslevel",
                "detectionsaccesslevel"
            ]
        },
        "AuthIdentityProviderSamlAttributeMap_UPDATE": {
            "properties": {
                "detectionsaccesslevel": {
                    "format": "detectionsaccesslevel_map",
                    "$ref": "#/definitions/detectionsaccesslevel_map",
                    "description": "Deprecated. Replaced by the ndrlevel field."
                },
                "ndrlevel": {
                    "format": "ndrlevel_map",
                    "$ref": "#/definitions/ndrlevel_map",
                    "description": "An object that maps a SAML attribute to NDR privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels)."
                },
                "npmlevel": {
                    "format": "npmlevel_map",
                    "$ref": "#/definitions/npmlevel_map",
                    "description": "An object that maps a SAML attribute to NPM privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels)."
                },
                "packetslevel": {
                    "format": "packetslevel_map",
                    "$ref": "#/definitions/packetslevel_map",
                    "description": "An object that maps a SAML attribute to packet privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels)."
                },
                "writelevel": {
                    "format": "writelevel_map",
                    "$ref": "#/definitions/writelevel_map",
                    "description": "An object that maps a SAML attribute to write privileges. For more information about user privileges, see [Users and user groups](https://docs.extrahop.com/9.8/users-overview/#privilege-levels)."
                }
            },
            "type": "object",
            "x-unsettable": [
                "ndrlevel",
                "npmlevel",
                "writelevel",
                "packetslevel",
                "detectionsaccesslevel"
            ]
        },
        "AuthIdentityProvider_CREATE": {
            "properties": {
                "auto_provision_users": {
                    "type": "boolean",
                    "description": "Indicates whether a user can be created on the ExtraHop system from the identity provider."
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether authentication through the identity provider is enabled on the ExtraHop system."
                },
                "entity_id": {
                    "type": "string",
                    "description": "The SAML 2.0 entityID."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the identity provider."
                },
                "signing_certificate": {
                    "type": "string",
                    "description": "The SAML 2.0 X.509 signing certificate in PEM format."
                },
                "sso_url": {
                    "type": "string",
                    "description": "The SAML 2.0 Single Sign-On (SSO) URL."
                },
                "type": {
                    "type": "string",
                    "enum": [
                        "saml"
                    ],
                    "description": "The type of identity provider."
                }
            },
            "required": [
                "name",
                "enabled",
                "type",
                "auto_provision_users"
            ],
            "type": "object",
            "x-uneditable": [
                "type"
            ]
        },
        "AuthIdentityProvider_UPDATE": {
            "properties": {
                "auto_provision_users": {
                    "type": "boolean",
                    "description": "Indicates whether a user can be created on the ExtraHop system from the identity provider."
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether authentication through the identity provider is enabled on the ExtraHop system."
                },
                "entity_id": {
                    "type": "string",
                    "description": "The SAML 2.0 entityID."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the identity provider."
                },
                "signing_certificate": {
                    "type": "string",
                    "description": "The SAML 2.0 X.509 signing certificate in PEM format."
                },
                "sso_url": {
                    "type": "string",
                    "description": "The SAML 2.0 Single Sign-On (SSO) URL."
                }
            },
            "required": [
                "name",
                "enabled",
                "auto_provision_users"
            ],
            "type": "object"
        },
        "AuthSAML": {
            "properties": {
                "acs_url": {
                    "type": "string",
                    "description": "The SAML 2.0 assertion consumer service (ACS) URL. Sometimes called the single sign-on (SSO) URL."
                },
                "entity_id": {
                    "type": "string",
                    "description": "The SAML 2.0 entityID (also known as Audience Restriction) for this ExtraHop system."
                },
                "xml": {
                    "type": "string",
                    "description": "The full SAML 2.0 security provider (SP) metadata in XML format."
                }
            },
            "required": [
                "entity_id",
                "acs_url"
            ],
            "type": "object",
            "x-uneditable": [
                "entity_id",
                "acs_url",
                "xml"
            ],
            "x-unsettable": [
                "entity_id",
                "acs_url",
                "xml"
            ]
        },
        "Bundle": {
            "properties": {
                "built_in": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the bundle is a default bundle."
                },
                "created_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time when the bundle was created, expressed in milliseconds since the epoch."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the bundle."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the bundle."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the bundle."
                }
            },
            "required": [
                "mod_time",
                "id",
                "name",
                "created_time",
                "built_in"
            ],
            "type": "object",
            "x-uneditable": [
                "mod_time",
                "id",
                "created_time",
                "built_in"
            ],
            "x-unsettable": [
                "mod_time",
                "id",
                "created_time",
                "built_in"
            ]
        },
        "Cloud": {
            "properties": {
                "cloud_token": {
                    "type": "string",
                    "description": "The token you generated from RevealX 360."
                },
                "nickname": {
                    "type": "string",
                    "description": "A nickname to easily identify the sensor."
                }
            },
            "required": [
                "cloud_token",
                "nickname"
            ],
            "type": "object"
        },
        "Cloud_CREATE": {
            "properties": {
                "cloud_token": {
                    "type": "string",
                    "description": "The token you generated from RevealX 360."
                },
                "nickname": {
                    "type": "string",
                    "description": "A nickname to easily identify the sensor."
                }
            },
            "required": [
                "cloud_token",
                "nickname"
            ],
            "type": "object"
        },
        "CustomDevice": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The name of the custom device creator."
                },
                "criteria": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/CustomDeviceCriterion"
                    },
                    "description": "An array of custom device criteria for this device. If this field is specified with the PATCH method, all previously specified criteria are deleted."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the custom device."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the custom device is inactive."
                },
                "extrahop_id": {
                    "type": "string",
                    "description": "A unique identifier for the custom device. If this field is not specified, an ID is generated from the custom device name. The ID cannot contain spaces and cannot be changed after the custom device is saved."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the custom device."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the custom device."
                }
            },
            "required": [
                "id",
                "mod_time",
                "name",
                "disabled"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "mod_time",
                "extrahop_id"
            ],
            "x-unsettable": [
                "id",
                "mod_time"
            ]
        },
        "CustomDeviceCriterion": {
            "properties": {
                "dst_port_max": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The maximum destination port boundary to match the custom device to. Supported values: 1-65535."
                },
                "dst_port_min": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The lower destination port boundary to match the custom device to. Supported values: 1-65535."
                },
                "ipaddr": {
                    "type": "string",
                    "format": "string",
                    "description": "The IP address to match the custom device to."
                },
                "ipaddr_direction": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "any",
                        "dst",
                        "src"
                    ],
                    "default": "any",
                    "description": "The direction of traffic to match the ipaddr address to. The criteria determines which direction of traffic to or from the ipaddr address is matched."
                },
                "ipaddr_peer": {
                    "type": "string",
                    "format": "string",
                    "description": "The IP address that the ipadder address is communicating with to match the custom device to. If specified, this parameter limits the traffic matched by the custom device. For example, if ipaddr_direction is \"src\", the custom device only matches traffic to the ipaddr_peer address from the ipaddr address. This parameter is only valid if ipaddr is specified and ipaddr_direction is not \"any\"."
                },
                "src_port_max": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The maximum source port boundary to match the custom device to. Supported values: 1-65535."
                },
                "src_port_min": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The lower source port boundary to match the custom device to. Supported values: 1-65535."
                },
                "vlan_max": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The maximum VLAN boundary to match the custom device to."
                },
                "vlan_min": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The lower VLAN boundary to match the custom device to."
                }
            },
            "type": "object"
        },
        "CustomDevice_CREATE": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The name of the custom device creator."
                },
                "criteria": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/CustomDeviceCriterion"
                    },
                    "description": "An array of custom device criteria for this device. If this field is specified with the PATCH method, all previously specified criteria are deleted."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the custom device."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the custom device is inactive."
                },
                "extrahop_id": {
                    "type": "string",
                    "description": "A unique identifier for the custom device. If this field is not specified, an ID is generated from the custom device name. The ID cannot contain spaces and cannot be changed after the custom device is saved."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the custom device."
                }
            },
            "required": [
                "name",
                "disabled"
            ],
            "type": "object",
            "x-uneditable": [
                "extrahop_id"
            ]
        },
        "CustomDevice_UPDATE": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The name of the custom device creator."
                },
                "criteria": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/CustomDeviceCriterion"
                    },
                    "description": "An array of custom device criteria for this device. If this field is specified with the PATCH method, all previously specified criteria are deleted."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the custom device."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the custom device is inactive."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the custom device."
                }
            },
            "required": [
                "name",
                "disabled"
            ],
            "type": "object"
        },
        "Customization": {
            "properties": {
                "auto": {
                    "type": "boolean",
                    "description": "Indicates whether the backup file was automatically created."
                },
                "create_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp that the backup or customization file was created, expressed as milliseconds since the epoch."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the backup file."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the backup file."
                },
                "recovered": {
                    "type": "boolean",
                    "description": "Indicates whether this is a recovery from an incomplete backup."
                }
            },
            "required": [
                "id",
                "name",
                "create_time",
                "auto"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "create_time",
                "auto",
                "recovered"
            ],
            "x-unsettable": [
                "id",
                "create_time",
                "auto",
                "recovered"
            ]
        },
        "Dashboard": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The name specified as the dashboard creator."
                },
                "comment": {
                    "type": "string",
                    "description": "The description for the dashboard."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the dashboard."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp of the most recent update to the dashboard. The timestamp is expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the dashboard."
                },
                "owner": {
                    "type": "string",
                    "description": "The username of the dashboard owner."
                },
                "rights": {
                    "type": "array",
                    "format": "Rights",
                    "items": {
                        "type": "string"
                    },
                    "enum": [
                        "view",
                        "edit",
                        "transfer",
                        "delete",
                        "share"
                    ],
                    "description": "The dashboard permissions for the current user."
                },
                "short_code": {
                    "type": "string",
                    "description": "The short code provided in the URL to directly navigate to the dashboard."
                },
                "type": {
                    "type": "string",
                    "default": "summary_dashboard",
                    "description": "The type of dashboard."
                }
            },
            "required": [
                "id",
                "mod_time"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "comment",
                "mod_time",
                "author",
                "name",
                "type",
                "short_code",
                "rights"
            ],
            "x-unsettable": [
                "id",
                "mod_time",
                "type",
                "short_code",
                "rights"
            ]
        },
        "DashboardSharing": {
            "properties": {
                "anyone": {
                    "type": "string",
                    "enum": [
                        "viewer",
                        "null"
                    ],
                    "description": "The dashboard permission level of all local or remote users in the ExtraHop system."
                },
                "groups": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The IDs and permission levels of all user groups that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the ExtraHop system, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard."
                },
                "users": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The usernames and permission levels of all users that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard."
                }
            },
            "required": [
                "users",
                "groups"
            ],
            "type": "object"
        },
        "DashboardSharing_REPLACE": {
            "properties": {
                "anyone": {
                    "type": "string",
                    "enum": [
                        "viewer",
                        "null"
                    ],
                    "description": "The dashboard permission level of all local or remote users in the ExtraHop system."
                },
                "groups": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The IDs and permission levels of all user groups that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the ExtraHop system, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard."
                },
                "users": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The usernames and permission levels of all users that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard."
                }
            },
            "required": [
                "users",
                "groups"
            ],
            "type": "object"
        },
        "DashboardSharing_UPDATE": {
            "properties": {
                "anyone": {
                    "type": "string",
                    "enum": [
                        "viewer",
                        "null"
                    ],
                    "description": "The dashboard permission level of all local or remote users in the ExtraHop system."
                },
                "groups": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The IDs and permission levels of all user groups that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". You must prepend \"local.\" or \"remote.\" to the group name to indicate whether the user group was created locally on the ExtraHop system, or if the user group was imported from a remote authentication provider. For example, specifying {\"remote.group1@example.com\": \"viewer\", \"local.group2@example.com\": \"editor\"} enables a remote user group named \"group1@example.com\" to view the dashboard and a local group named \"group2@example.com\" to edit the dashboard."
                },
                "users": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The usernames and permission levels of all users that the dashboard is shared with. Supported permission levels are \"editor\", \"viewer\" and \"null\". For example, specifying {\"user1@example.com\": \"viewer\", \"user2@example.com\": \"editor\"} enables a user named \"user1@example.com\" to view the dashboard and \"user2@example.com\" to edit the dashboard."
                }
            },
            "required": [
                "users",
                "groups"
            ],
            "type": "object"
        },
        "Dashboard_UPDATE": {
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "The username of the dashboard owner."
                }
            },
            "type": "object"
        },
        "Detections": {
            "properties": {
                "appliance_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "If called on a Command appliance or RevealX 360, returns the ID of the connected sensor that the detection occurred on. If called on a sensor, returns 0."
                },
                "assignee": {
                    "type": "string",
                    "description": "The assignee of the detection or the ticket associated with the detection."
                },
                "categories": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of categories the detection belongs to."
                },
                "create_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the detection was created, expressed in milliseconds since the epoch. For sensors, this is the time that the detection was generated on the sensor. If the detection was generated by the ExtraHop Machine Learning Service, this time is typically after the start time because machine learning algorithms analyze historical data to generate detections. For consoles, this is the time that the detection was first synchronized to the console."
                },
                "description": {
                    "type": "string",
                    "description": "The description of the detection."
                },
                "end_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the detection ended, expressed in milliseconds since the epoch."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the detection."
                },
                "is_user_created": {
                    "type": "boolean",
                    "description": "Indicates whether the detection format was created by a user on the ExtraHop system."
                },
                "mitre_tactics": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/detection_mitre_category"
                    },
                    "description": "A list of MITRE tactics associated with the detection."
                },
                "mitre_techniques": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/detection_mitre_category"
                    },
                    "description": "A list of MITRE techniques associated with the detection."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the detection was last updated. Note that this includes anytime that the detection is modified. For example, when a detection is synchronized from a sensor to a console, the mod_time for the detection on the console is changed, but the mod_time for the detection on the sensor stays the same."
                },
                "participants": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/detection_participant"
                    },
                    "description": "A list of devices and applications associated with the detection."
                },
                "properties": {
                    "type": "object",
                    "format": "json",
                    "description": "The properties of the detection."
                },
                "recommended": {
                    "type": "boolean",
                    "description": "Indicates whether the detection is recommended for triage. This field is returned only on a console."
                },
                "recommended_factors": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of recommendation factors, which indicate why the detection is recommended for triage. This field is returned only on a console."
                },
                "resolution": {
                    "type": "string",
                    "enum": [
                        "action_taken",
                        "no_action_taken"
                    ],
                    "description": "The resolution of the detection or the ticket associated with the detection."
                },
                "risk_score": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The risk score of the detection."
                },
                "start_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the detection started, expressed in milliseconds since the epoch. This time is determined by when the event that caused the detection occurred. If the detection was generated by the ExtraHop Machine Learning Service, this field might reference a time before the detection was available in the ExtraHop system because machine learning algorithms analyze historical data to generate detections."
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "new",
                        "in_progress",
                        "closed",
                        "acknowledged"
                    ],
                    "description": "The status of the detection or the ticket associated with the detection. If the value is null, the status displayed in the ExtraHop system is Open. The value \"new\" can only be specified through the REST API when [third party ticket tracking is enabled](https://docs.extrahop.com/9.8/detections-configure-ticket-tracking/#configure-third-party-ticket-tracking-for-detections)."
                },
                "ticket_id": {
                    "type": "string",
                    "description": "The ID of the ticket associated with the detection."
                },
                "ticket_url": {
                    "type": "string",
                    "description": "The URL for the related ticket."
                },
                "title": {
                    "type": "string",
                    "description": "The title of the detection."
                },
                "type": {
                    "type": "string",
                    "description": "The type of the detection. Although detection types are unique across built-in formats, and detection types are unique across custom formats, a built-in and custom format can share the same detection type."
                },
                "update_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the event that caused the last update to the detection occurred. If the detection was generated by the ExtraHop Machine Learning Service, this field might reference a time before the detection was available in the ExtraHop system because machine learning algorithms analyze historical data to generate detections."
                },
                "url": {
                    "type": "string",
                    "description": "The URL for the detection. Follow this link to view the detection in the ExtraHop system."
                }
            },
            "required": [
                "id",
                "start_time",
                "title",
                "appliance_id",
                "participants",
                "mitre_tactics",
                "mitre_techniques",
                "type",
                "properties",
                "is_user_created",
                "recommended",
                "recommended_factors",
                "url"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "start_time",
                "update_time",
                "mod_time",
                "create_time",
                "end_time",
                "title",
                "description",
                "appliance_id",
                "categories",
                "risk_score",
                "ticket_url",
                "participants",
                "mitre_tactics",
                "mitre_techniques",
                "type",
                "properties",
                "is_user_created",
                "recommended",
                "recommended_factors",
                "url"
            ],
            "x-unsettable": [
                "id",
                "start_time",
                "update_time",
                "mod_time",
                "create_time",
                "end_time",
                "title",
                "description",
                "appliance_id",
                "categories",
                "risk_score",
                "ticket_id",
                "assignee",
                "status",
                "resolution",
                "ticket_url",
                "participants",
                "mitre_tactics",
                "mitre_techniques",
                "type",
                "properties",
                "is_user_created",
                "recommended",
                "recommended_factors",
                "url"
            ]
        },
        "DetectionsFormats": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The author of the detection format."
                },
                "categories": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of categories the detection belongs to. For POST and PATCH operations, specify a list with a single string. You cannot specify more than one category for custom detection formats. The \"perf\" or \"sec\" category is automatically added to all detection formats."
                },
                "display_name": {
                    "type": "string",
                    "description": "The display name of the detection type that appears on the Detections page in the ExtraHop system."
                },
                "is_user_created": {
                    "type": "boolean",
                    "description": "Indicates whether the detection format was created by a user on the ExtraHop system."
                },
                "last_updated": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The last time that the detection type was updated, expressed in milliseconds since the epoch."
                },
                "mitre_categories": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of the MITRE techniques associated with the detection."
                },
                "properties": {
                    "type": "object",
                    "format": "json",
                    "description": "An object that specifies the name and description of each detection property."
                },
                "released": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The first time that the detection type was released to all sensors, expressed in milliseconds since the epoch."
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "active",
                        "inactive",
                        "in_review"
                    ],
                    "description": "The release status of the detection type."
                },
                "type": {
                    "type": "string",
                    "description": "A string identifier for the detection type. The string can only contain letters, numbers, and underscores. Although detection types are unique across built-in formats, and detection types are unique across custom formats, a built-in and custom format can share the same detection type."
                }
            },
            "required": [
                "type",
                "display_name",
                "is_user_created",
                "properties"
            ],
            "type": "object",
            "x-uneditable": [
                "type",
                "is_user_created",
                "properties",
                "status",
                "released",
                "last_updated"
            ],
            "x-unsettable": [
                "is_user_created",
                "properties",
                "status",
                "released",
                "last_updated"
            ]
        },
        "DetectionsFormats_CREATE": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The author of the detection format."
                },
                "categories": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of categories the detection belongs to. For POST and PATCH operations, specify a list with a single string. You cannot specify more than one category for custom detection formats. The \"perf\" or \"sec\" category is automatically added to all detection formats."
                },
                "display_name": {
                    "type": "string",
                    "description": "The display name of the detection type that appears on the Detections page in the ExtraHop system."
                },
                "mitre_categories": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of the MITRE techniques associated with the detection."
                },
                "type": {
                    "type": "string",
                    "description": "A string identifier for the detection type. The string can only contain letters, numbers, and underscores. Although detection types are unique across built-in formats, and detection types are unique across custom formats, a built-in and custom format can share the same detection type."
                }
            },
            "required": [
                "type",
                "display_name"
            ],
            "type": "object",
            "x-uneditable": [
                "type"
            ]
        },
        "DetectionsFormats_UPDATE": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The author of the detection format."
                },
                "categories": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of categories the detection belongs to. For POST and PATCH operations, specify a list with a single string. You cannot specify more than one category for custom detection formats. The \"perf\" or \"sec\" category is automatically added to all detection formats."
                },
                "display_name": {
                    "type": "string",
                    "description": "The display name of the detection type that appears on the Detections page in the ExtraHop system."
                },
                "mitre_categories": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of the MITRE techniques associated with the detection."
                }
            },
            "required": [
                "display_name"
            ],
            "type": "object"
        },
        "DetectionsHidingRules": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The author of the tuning rule."
                },
                "create_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the tuning rule was created, expressed in milliseconds since the epoch."
                },
                "description": {
                    "type": "string",
                    "description": "The description of the tuning rule."
                },
                "detection_type": {
                    "type": "string",
                    "description": "The type of detection that this tuning rule applies to. View a list of valid fields for \"type\" by running the GET /detections/formats operation. Specify \"all_performance\" or \"all_security\" to apply the rule to all performance or all security detections."
                },
                "detections_hidden": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of detections currently hidden by this rule."
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether the tuning rule is enabled."
                },
                "expiration": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the tuning rule expires, expressed in milliseconds since the epoch. A value of null or 0 indicates that the rule does not expire."
                },
                "hide_past_detections": {
                    "type": "boolean",
                    "default": true,
                    "description": "Deprecated. All tuning rules now hide past detections that the rule applies to."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the tuning rule."
                },
                "offender": {
                    "format": "detection_hiding_participant",
                    "$ref": "#/definitions/detection_hiding_participant",
                    "description": "The offender that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any offender."
                },
                "participants_hidden": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of participants currently hidden by this rule."
                },
                "properties": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/detection_property_filter"
                    },
                    "description": "The filter criteria for detection properties."
                },
                "victim": {
                    "format": "detection_hiding_participant",
                    "$ref": "#/definitions/detection_hiding_participant",
                    "description": "The victim that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any victim."
                }
            },
            "required": [
                "offender",
                "victim",
                "expiration",
                "detection_type"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "enabled",
                "offender",
                "victim",
                "author",
                "create_time",
                "expiration",
                "detections_hidden",
                "participants_hidden",
                "description",
                "detection_type",
                "hide_past_detections"
            ],
            "x-unsettable": [
                "id",
                "enabled",
                "author",
                "create_time",
                "detections_hidden",
                "participants_hidden",
                "hide_past_detections"
            ]
        },
        "DetectionsHidingRules_CREATE": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the tuning rule."
                },
                "detection_type": {
                    "type": "string",
                    "description": "The type of detection that this tuning rule applies to. View a list of valid fields for \"type\" by running the GET /detections/formats operation. Specify \"all_performance\" or \"all_security\" to apply the rule to all performance or all security detections."
                },
                "expiration": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the tuning rule expires, expressed in milliseconds since the epoch. A value of null or 0 indicates that the rule does not expire."
                },
                "offender": {
                    "format": "detection_hiding_participant",
                    "$ref": "#/definitions/detection_hiding_participant",
                    "description": "The offender that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any offender."
                },
                "properties": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/detection_property_filter"
                    },
                    "description": "The filter criteria for detection properties."
                },
                "victim": {
                    "format": "detection_hiding_participant",
                    "$ref": "#/definitions/detection_hiding_participant",
                    "description": "The victim that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any victim."
                }
            },
            "required": [
                "offender",
                "victim",
                "expiration",
                "detection_type"
            ],
            "type": "object",
            "x-uneditable": [
                "offender",
                "victim",
                "expiration",
                "description",
                "detection_type"
            ]
        },
        "DetectionsNotes": {
            "properties": {
                "author": {
                    "type": "string",
                    "description": "The user that most recently updated the note."
                },
                "note": {
                    "type": "string",
                    "description": "The note associated with the detection."
                },
                "update_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the note was most recently updated, expressed in milliseconds since the epoch."
                }
            },
            "type": "object",
            "x-uneditable": [
                "author",
                "update_time"
            ],
            "x-unsettable": [
                "author",
                "update_time"
            ]
        },
        "DetectionsNotes_REPLACE": {
            "properties": {
                "note": {
                    "type": "string",
                    "description": "The note associated with the detection."
                }
            },
            "type": "object"
        },
        "Device": {
            "properties": {
                "activity": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The activity for the device."
                },
                "analysis": {
                    "type": "string",
                    "description": "The analysis level of the device."
                },
                "analysis_level": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Deprecated. Replaced by the analysis field."
                },
                "auto_role": {
                    "type": "string",
                    "description": "The role automatically detected by the ExtraHop."
                },
                "cdp_name": {
                    "type": "string",
                    "description": "The Cisco Discovery Protocol name for this device."
                },
                "cloud_account": {
                    "type": "string",
                    "description": "The cloud account that this device is associated with. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "cloud_instance_description": {
                    "type": "string",
                    "description": "The description of the device defined by the cloud service provider. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "cloud_instance_id": {
                    "type": "string",
                    "description": "The cloud instance ID of the device."
                },
                "cloud_instance_name": {
                    "type": "string",
                    "description": "The cloud instance name of the device. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "cloud_instance_type": {
                    "type": "string",
                    "description": "The cloud instance type of the device. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "critical": {
                    "type": "boolean",
                    "description": "Indicates whether the device is specified as high value."
                },
                "custom_criticality": {
                    "type": "string",
                    "enum": [
                        "critical",
                        "not_critical",
                        ""
                    ],
                    "description": "Indicates whether a user manually specified the device as high value or not high value. An empty string indicates that the high value setting is automatically determined by the ExtraHop system."
                },
                "custom_make": {
                    "type": "string",
                    "description": "The manually specified make for a device."
                },
                "custom_model": {
                    "type": "string",
                    "description": "The manually specified model for a device."
                },
                "custom_name": {
                    "type": "string",
                    "description": "The friendly name for this device."
                },
                "custom_type": {
                    "type": "string",
                    "enum": [
                        "attack_simulator",
                        "db_server",
                        "dhcp_server",
                        "dns_server",
                        "domain_controller",
                        "file_server",
                        "firewall",
                        "gateway",
                        "http_server",
                        "ip_camera",
                        "load_balancer",
                        "medical_device",
                        "mobile_device",
                        "nat_gateway",
                        "other",
                        "pc",
                        "printer",
                        "scanner",
                        "voip_phone",
                        "vpn_gateway",
                        "web_proxy",
                        "wifi_ap",
                        ""
                    ],
                    "description": "Updates the device role."
                },
                "default_name": {
                    "type": "string",
                    "description": "The default name for this device."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the device."
                },
                "device_class": {
                    "type": "string",
                    "description": "The class of this device."
                },
                "dhcp_name": {
                    "type": "string",
                    "description": "The DHCP name for this device."
                },
                "discover_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time when the device was first discovered on the network, expressed in milliseconds since the epoch."
                },
                "discovery_id": {
                    "type": "string",
                    "description": "The unique identifier for the device, which is displayed as part of the device URL in the ExtraHop system."
                },
                "display_name": {
                    "type": "string",
                    "description": "The display name chosen based on the running configuration settings."
                },
                "dns_name": {
                    "type": "string",
                    "description": "The DNS name for this device."
                },
                "extrahop_id": {
                    "type": "string",
                    "description": "Deprecated. Replaced by the discover_id field."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the device, which is displayed as the API ID on the device page in the ExtraHop system."
                },
                "ipaddr4": {
                    "type": "string",
                    "description": "The IPv4 address for this device."
                },
                "ipaddr6": {
                    "type": "string",
                    "description": "The IPv6 address for this device."
                },
                "is_l3": {
                    "type": "boolean",
                    "description": "Indicates whether the device is an L3 device."
                },
                "last_seen_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The last time that the ExtraHop system observed packets sent to or from the specified device, expressed in milliseconds since the epoch. If the system observed activity for the device less than five minutes ago, the value is null."
                },
                "macaddr": {
                    "type": "string",
                    "description": "The MAC address for this device."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update, expressed in milliseconds since the epoch."
                },
                "model": {
                    "type": "string",
                    "description": "The ID of the automatically identified make and model for the device."
                },
                "model_override": {
                    "type": "string",
                    "description": "The ID of the manually specified make and model for the device. If the manually specified make and model of the device is not in the list of built-in make and models on the ExtraHop system, the value is 'Custom'. If the custom make and custom model have not been specified, the value is null."
                },
                "netbios_name": {
                    "type": "string",
                    "description": "The NetBios name for this device."
                },
                "node_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the Discover node this device is associated with."
                },
                "on_watchlist": {
                    "type": "boolean",
                    "description": "Indicates whether the device is on the watchlist."
                },
                "parent_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the parent device object."
                },
                "role": {
                    "type": "string",
                    "description": "The role of the device."
                },
                "subnet_id": {
                    "type": "string",
                    "description": "The identifier of the subnet that this device is on. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "user_mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update made by the user, expressed in milliseconds since the epoch."
                },
                "vendor": {
                    "type": "string",
                    "description": "The name of the vendor who created this device."
                },
                "vlanid": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the VLAN this device is associated with."
                },
                "vpc_id": {
                    "type": "string",
                    "description": "The VPC that this device is in. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                }
            },
            "required": [
                "mod_time",
                "id",
                "extrahop_id",
                "discovery_id",
                "user_mod_time",
                "discover_time",
                "vlanid",
                "is_l3",
                "cdp_name",
                "dhcp_name",
                "netbios_name",
                "dns_name",
                "custom_type",
                "auto_role",
                "analysis_level",
                "analysis",
                "role",
                "on_watchlist"
            ],
            "type": "object",
            "x-uneditable": [
                "mod_time",
                "node_id",
                "id",
                "extrahop_id",
                "discovery_id",
                "display_name",
                "user_mod_time",
                "discover_time",
                "vlanid",
                "parent_id",
                "macaddr",
                "is_l3",
                "ipaddr4",
                "ipaddr6",
                "device_class",
                "default_name",
                "cdp_name",
                "dhcp_name",
                "netbios_name",
                "dns_name",
                "auto_role",
                "analysis_level",
                "analysis",
                "role",
                "on_watchlist",
                "last_seen_time",
                "activity",
                "model",
                "model_override",
                "critical"
            ],
            "x-unsettable": [
                "mod_time",
                "node_id",
                "id",
                "extrahop_id",
                "discovery_id",
                "display_name",
                "user_mod_time",
                "discover_time",
                "vlanid",
                "parent_id",
                "macaddr",
                "vendor",
                "is_l3",
                "ipaddr4",
                "ipaddr6",
                "device_class",
                "default_name",
                "cdp_name",
                "dhcp_name",
                "netbios_name",
                "dns_name",
                "auto_role",
                "analysis_level",
                "analysis",
                "role",
                "on_watchlist",
                "last_seen_time",
                "activity",
                "model",
                "model_override",
                "critical"
            ]
        },
        "DeviceActivity": {
            "properties": {
                "device_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the connected device."
                },
                "from_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp that marks the beginning of the activity."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the activity."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp of the most recent update."
                },
                "stat_name": {
                    "type": "string",
                    "description": "The name of the statistic with activity."
                },
                "until_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp that marks the end of the activity."
                }
            },
            "required": [
                "id",
                "from_time",
                "until_time",
                "mod_time",
                "device_id",
                "stat_name"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "from_time",
                "until_time",
                "mod_time",
                "device_id",
                "stat_name"
            ],
            "x-unsettable": [
                "id",
                "from_time",
                "until_time",
                "mod_time",
                "device_id",
                "stat_name"
            ]
        },
        "DeviceDNSNameObservation": {
            "properties": {},
            "type": "object"
        },
        "DeviceGroup": {
            "properties": {
                "built_in": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the device group was created by a user on the ExtraHop system."
                },
                "description": {
                    "type": "string",
                    "default": "",
                    "description": "An optional description of the device group."
                },
                "dynamic": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the device group is dynamic."
                },
                "editors": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of users that can edit the device group."
                },
                "field": {
                    "type": "string",
                    "enum": [
                        "any",
                        "name",
                        "ip address",
                        "mac address",
                        "vendor",
                        "type",
                        "tag",
                        "vlan",
                        "activity",
                        "node",
                        "discover time"
                    ],
                    "description": "Deprecated. Replaced by the filter parameter."
                },
                "filter": {
                    "type": "object",
                    "format": "json",
                    "description": "Specify the filter criteria for search results."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the device group."
                },
                "include_custom_devices": {
                    "type": "boolean",
                    "default": true,
                    "description": "Deprecated. Replaced by the filter parameter."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the device group."
                },
                "value": {
                    "type": "string",
                    "description": "Deprecated. Replaced by the filter parameter."
                }
            },
            "required": [
                "id",
                "name",
                "built_in"
            ],
            "type": "object",
            "x-uneditable": [
                "mod_time",
                "id",
                "built_in",
                "dynamic"
            ],
            "x-unsettable": [
                "mod_time",
                "id",
                "built_in"
            ]
        },
        "DeviceIPAddressObservation": {
            "properties": {},
            "type": "object"
        },
        "Device_UPDATE": {
            "properties": {
                "cloud_account": {
                    "type": "string",
                    "description": "The cloud account that this device is associated with. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "cloud_instance_description": {
                    "type": "string",
                    "description": "The description of the device defined by the cloud service provider. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "cloud_instance_id": {
                    "type": "string",
                    "description": "The cloud instance ID of the device."
                },
                "cloud_instance_name": {
                    "type": "string",
                    "description": "The cloud instance name of the device. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "cloud_instance_type": {
                    "type": "string",
                    "description": "The cloud instance type of the device. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "custom_criticality": {
                    "type": "string",
                    "enum": [
                        "critical",
                        "not_critical",
                        ""
                    ],
                    "description": "Indicates whether a user manually specified the device as high value or not high value. An empty string indicates that the high value setting is automatically determined by the ExtraHop system."
                },
                "custom_make": {
                    "type": "string",
                    "description": "The manually specified make for a device."
                },
                "custom_model": {
                    "type": "string",
                    "description": "The manually specified model for a device."
                },
                "custom_name": {
                    "type": "string",
                    "description": "The friendly name for this device."
                },
                "custom_type": {
                    "type": "string",
                    "enum": [
                        "attack_simulator",
                        "db_server",
                        "dhcp_server",
                        "dns_server",
                        "domain_controller",
                        "file_server",
                        "firewall",
                        "gateway",
                        "http_server",
                        "ip_camera",
                        "load_balancer",
                        "medical_device",
                        "mobile_device",
                        "nat_gateway",
                        "other",
                        "pc",
                        "printer",
                        "scanner",
                        "voip_phone",
                        "vpn_gateway",
                        "web_proxy",
                        "wifi_ap",
                        ""
                    ],
                    "description": "Updates the device role."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the device."
                },
                "subnet_id": {
                    "type": "string",
                    "description": "The identifier of the subnet that this device is on. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                },
                "vendor": {
                    "type": "string",
                    "description": "The name of the vendor who created this device."
                },
                "vpc_id": {
                    "type": "string",
                    "description": "The VPC that this device is in. If you configure this device property from a console, the device property on connected sensors gets overwritten."
                }
            },
            "required": [
                "custom_type"
            ],
            "type": "object",
            "x-unsettable": [
                "vendor"
            ]
        },
        "EmailGroup": {
            "properties": {
                "email_addresses": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of email addresses in the email group."
                },
                "group_name": {
                    "type": "string",
                    "description": "The friendly name for the email group."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the email group."
                },
                "system_notifications": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether that the group should receive system notifications."
                }
            },
            "required": [
                "id",
                "group_name",
                "email_addresses",
                "system_notifications"
            ],
            "type": "object",
            "x-uneditable": [
                "id"
            ],
            "x-unsettable": [
                "id"
            ]
        },
        "EmailGroup_CREATE": {
            "properties": {
                "email_addresses": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of email addresses in the email group."
                },
                "group_name": {
                    "type": "string",
                    "description": "The friendly name for the email group."
                },
                "system_notifications": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether that the group should receive system notifications."
                }
            },
            "required": [
                "group_name",
                "email_addresses",
                "system_notifications"
            ],
            "type": "object"
        },
        "EmailGroup_UPDATE": {
            "properties": {
                "email_addresses": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of email addresses in the email group."
                },
                "group_name": {
                    "type": "string",
                    "description": "The friendly name for the email group."
                },
                "system_notifications": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether that the group should receive system notifications."
                }
            },
            "required": [
                "group_name",
                "email_addresses",
                "system_notifications"
            ],
            "type": "object"
        },
        "ExclusionInterval": {
            "properties": {
                "alert_apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether this exclusion interval should be applied to all alerts."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the creator of the exclusion interval."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the exclusion interval."
                },
                "end": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The end of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the exclusion interval."
                },
                "interval_type": {
                    "type": "string",
                    "enum": [
                        "onetime",
                        "weekly",
                        "daily"
                    ],
                    "default": "onetime",
                    "description": "The time window when the exclusion interval was evaluated."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the exclusion interval."
                },
                "start": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The start of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions."
                },
                "trend_apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether this exclusion interval should be applied to all trends."
                }
            },
            "required": [
                "id",
                "mod_time",
                "name",
                "interval_type",
                "start",
                "end",
                "alert_apply_all",
                "trend_apply_all"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "mod_time"
            ],
            "x-unsettable": [
                "id",
                "mod_time"
            ]
        },
        "ExclusionInterval_CREATE": {
            "properties": {
                "alert_apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether this exclusion interval should be applied to all alerts."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the creator of the exclusion interval."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the exclusion interval."
                },
                "end": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The end of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions."
                },
                "interval_type": {
                    "type": "string",
                    "enum": [
                        "onetime",
                        "weekly",
                        "daily"
                    ],
                    "default": "onetime",
                    "description": "The time window when the exclusion interval was evaluated."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the exclusion interval."
                },
                "start": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The start of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions."
                },
                "trend_apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether this exclusion interval should be applied to all trends."
                }
            },
            "required": [
                "name",
                "interval_type",
                "start",
                "end",
                "alert_apply_all",
                "trend_apply_all"
            ],
            "type": "object"
        },
        "ExclusionInterval_UPDATE": {
            "properties": {
                "alert_apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether this exclusion interval should be applied to all alerts."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the creator of the exclusion interval."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the exclusion interval."
                },
                "end": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The end of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions."
                },
                "interval_type": {
                    "type": "string",
                    "enum": [
                        "onetime",
                        "weekly",
                        "daily"
                    ],
                    "default": "onetime",
                    "description": "The time window when the exclusion interval was evaluated."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the exclusion interval."
                },
                "start": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The start of the exclusion interval time range, expressed in seconds. This value is relative to the epoch for onetime exclusions, relative to midnight for daily exclusions, and relative to Monday at midnight for weekly exclusions."
                },
                "trend_apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether this exclusion interval should be applied to all trends."
                }
            },
            "required": [
                "name",
                "interval_type",
                "start",
                "end",
                "alert_apply_all",
                "trend_apply_all"
            ],
            "type": "object"
        },
        "ExtraHop": {
            "properties": {},
            "type": "object"
        },
        "ExtraHopCloudResources": {
            "properties": {},
            "type": "object"
        },
        "ExtraHopFirmwareCloudDownload": {
            "properties": {},
            "type": "object"
        },
        "ExtraHopFirmwareRelease": {
            "properties": {
                "current_release": {
                    "type": "boolean",
                    "description": "Indicates whether the release is running on the appliance."
                },
                "release": {
                    "type": "string",
                    "description": "The release number."
                },
                "versions": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of firmware versions that you can upgrade the appliance to."
                }
            },
            "required": [
                "release",
                "versions",
                "current_release"
            ],
            "type": "object",
            "x-uneditable": [
                "release",
                "versions",
                "current_release"
            ],
            "x-unsettable": [
                "release",
                "versions",
                "current_release"
            ]
        },
        "ExtraHopFlowlogs": {
            "properties": {},
            "type": "object"
        },
        "ExtraHopProcess": {
            "properties": {
                "can_restart": {
                    "type": "boolean",
                    "description": "Indicates whether the process can be restarted through the ExtraHop REST API."
                },
                "cpu": {
                    "type": "number",
                    "format": "float",
                    "description": "The percentage of CPU consumed by the process."
                },
                "cpu_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The total CPU time consumed by the process, expressed in seconds."
                },
                "mem_percent": {
                    "type": "number",
                    "format": "float",
                    "description": "The percentage of memory consumed by the process."
                },
                "mem_res": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The resident size of the process, expressed in kilobytes."
                },
                "mem_virt": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The virtual size of the process, expressed in kilobytes."
                },
                "process": {
                    "type": "string",
                    "description": "The name for the process."
                },
                "start_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp when the process started. The timestamp is expressed in milliseconds since the epoch."
                }
            },
            "required": [
                "start_time",
                "process",
                "cpu",
                "mem_percent",
                "mem_virt",
                "mem_res",
                "cpu_time",
                "can_restart"
            ],
            "type": "object",
            "x-uneditable": [
                "start_time",
                "process",
                "cpu",
                "mem_percent",
                "mem_virt",
                "mem_res",
                "cpu_time",
                "can_restart"
            ],
            "x-unsettable": [
                "start_time",
                "process",
                "cpu",
                "mem_percent",
                "mem_virt",
                "mem_res",
                "cpu_time",
                "can_restart"
            ]
        },
        "ExtraHopRollback": {
            "properties": {},
            "type": "object"
        },
        "Investigations": {
            "properties": {
                "assessment": {
                    "type": "string",
                    "enum": [
                        "malicious_true_positive",
                        "benign_true_positive",
                        "false_positive",
                        "undecided"
                    ],
                    "description": "The assessment of the investigation."
                },
                "assignee": {
                    "type": "string",
                    "description": "The username of the investigation assignee."
                },
                "created_by": {
                    "type": "string",
                    "description": "The username of the user that created the investigation. For recommended investigations, the value is \"ExtraHop\"."
                },
                "creation_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the investigation was created, expressed in milliseconds since the epoch."
                },
                "description": {
                    "type": "string",
                    "description": "A description of the recommended investigation. The value is null if the investigation was created manually by a user."
                },
                "detections": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "$ref": "#/definitions/int"
                    },
                    "description": "A list of IDs of the detections in the investigation."
                },
                "end_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The update_time of the last detection that caused an update to the recommended investigation, expressed in milliseconds since the epoch. The value is null if the investigation was created manually by a user."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the investigation."
                },
                "investigation_types": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of recommended investigation types that this investigation belongs to. If the investigation is created manually by a user, the value is null."
                },
                "is_user_created": {
                    "type": "boolean",
                    "description": "Indicates whether the investigation is manually created by a user or if the investigation is a recommended investigation automatically created by the ExtraHop system."
                },
                "last_interaction_by": {
                    "type": "string",
                    "description": "The username of the user that last updated this investigation."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the investigation."
                },
                "notes": {
                    "type": "string",
                    "description": "Optional notes about the investigation."
                },
                "start_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the recommended investigation started, expressed in milliseconds since the epoch. This time is determined by the start_time of the earliest detection in the investigation. The value is null if the investigation was created manually by a user."
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "open",
                        "in_progress",
                        "closed"
                    ],
                    "description": "The status of the investigation."
                },
                "update_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The last time that the investigation was updated, expressed in milliseconds since the epoch. This time is determined either by the update_time of the last detection that caused an update to the investigation or by the last time that a user manually updated the investigation."
                },
                "url": {
                    "type": "string",
                    "description": "The URL for the investigation. Follow this link to view the investigation in the ExtraHop system."
                }
            },
            "required": [
                "id",
                "start_time",
                "name",
                "is_user_created"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "start_time",
                "end_time",
                "update_time",
                "creation_time",
                "name",
                "description",
                "notes",
                "investigation_types",
                "detections",
                "last_interaction_by",
                "created_by",
                "assignee",
                "url",
                "is_user_created"
            ],
            "x-unsettable": [
                "id",
                "start_time",
                "end_time",
                "update_time",
                "creation_time",
                "name",
                "description",
                "notes",
                "investigation_types",
                "detections",
                "last_interaction_by",
                "created_by",
                "assignee",
                "status",
                "assessment",
                "url",
                "is_user_created"
            ]
        },
        "JobStatus": {
            "properties": {
                "details": {
                    "type": "string",
                    "description": "Details about the status of the job."
                },
                "id": {
                    "type": "string",
                    "description": "The unique identifier for the job."
                },
                "remote_jobs": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/remote_job"
                    },
                    "description": "A list of jobs created on remote appliances."
                },
                "status": {
                    "type": "string",
                    "description": "The status of the job."
                },
                "step_description": {
                    "type": "string",
                    "description": "A description of the step that the job is currently performing."
                },
                "step_number": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of the step that the job is currently performing."
                },
                "total_steps": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The total number of steps in the job."
                },
                "type": {
                    "type": "string",
                    "description": "The optional job type. For a list of all job types, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#job-types)."
                }
            },
            "required": [
                "id",
                "status"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "status",
                "type",
                "details",
                "step_number",
                "total_steps",
                "step_description",
                "remote_jobs"
            ],
            "x-unsettable": [
                "id",
                "status",
                "type",
                "details",
                "step_number",
                "total_steps",
                "step_description",
                "remote_jobs"
            ]
        },
        "License": {
            "properties": {
                "dossier": {
                    "type": "string",
                    "description": "The system-generated identifier for the license."
                },
                "edition": {
                    "type": "string",
                    "description": "The license edition for this appliance."
                },
                "expires_at": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time when the license is no longer valid, expressed in milliseconds since the epoch."
                },
                "expires_in": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of milliseconds until the license is no longer valid."
                },
                "modules": {
                    "type": "object",
                    "format": "json",
                    "description": "The key:value pairs where the key is the name of a protocol (such as \"cifs\" or \"dhcp\") and the value is true or false."
                },
                "options": {
                    "type": "object",
                    "format": "json",
                    "description": "The key:value pairs where the key is a configuration option (such as \"triggers\" or \"ssl_decryption\") and the value is either true or false, or a number (such as \"50\" for an option like \"device_safety_limit\")."
                },
                "platform": {
                    "type": "string",
                    "description": "The model number for the appliance."
                },
                "product_key": {
                    "type": "string",
                    "description": "The product key that is applied to this appliance."
                },
                "serial": {
                    "type": "string",
                    "description": "The serial number for the physical appliance."
                }
            },
            "required": [
                "dossier",
                "serial",
                "product_key",
                "platform",
                "edition",
                "options",
                "modules"
            ],
            "type": "object",
            "x-uneditable": [
                "dossier",
                "serial",
                "product_key",
                "platform",
                "edition",
                "expires_at",
                "expires_in",
                "options",
                "modules"
            ],
            "x-unsettable": [
                "dossier",
                "serial",
                "product_key",
                "platform",
                "edition",
                "expires_at",
                "expires_in",
                "options",
                "modules"
            ]
        },
        "LicenseProductKey": {
            "properties": {
                "product_key": {
                    "type": "string",
                    "description": "Retrieve the product key that is applied to this appliance."
                }
            },
            "required": [
                "product_key"
            ],
            "type": "object"
        },
        "Metric": {
            "properties": {},
            "type": "object"
        },
        "Network": {
            "properties": {
                "appliance_uuid": {
                    "type": "string",
                    "description": "The universal unique identifier of the sensor associated with the network."
                },
                "description": {
                    "type": "string",
                    "description": "Optional description of the network."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Unique identifier of the network."
                },
                "idle": {
                    "type": "boolean",
                    "description": "Indicate that there is a problem with the capture."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Time of most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the network."
                },
                "node_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier of the sensor associated with the network."
                }
            },
            "required": [
                "mod_time",
                "id",
                "name",
                "idle"
            ],
            "type": "object",
            "x-uneditable": [
                "mod_time",
                "id",
                "node_id",
                "appliance_uuid",
                "idle"
            ],
            "x-unsettable": [
                "mod_time",
                "id",
                "node_id",
                "appliance_uuid",
                "idle"
            ]
        },
        "NetworkLocalityEntry": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network locality entry."
                },
                "external": {
                    "type": "boolean",
                    "description": "Indicates whether the network is internal or external."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the network locality entry."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Time of most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network locality. If this field is not specified, the network locality is named in the following format: \"locality_ID\", where ID is the unique identifier of the network locality."
                },
                "network": {
                    "type": "string",
                    "description": "Deprecated. Specify CIDR blocks or IP addresses with the networks field."
                },
                "networks": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of CIDR blocks or IP addresses that define the network locality."
                }
            },
            "required": [
                "id",
                "mod_time",
                "external"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "mod_time"
            ],
            "x-unsettable": [
                "id",
                "mod_time"
            ]
        },
        "NetworkLocalityEntry_CREATE": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description of the network locality entry."
                },
                "external": {
                    "type": "boolean",
                    "description": "Indicates whether the network is internal or external."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network locality. If this field is not specified, the network locality is named in the following format: \"locality_ID\", where ID is the unique identifier of the network locality."
                },
                "network": {
                    "type": "string",
                    "description": "Deprecated. Specify CIDR blocks or IP addresses with the networks field."
                },
                "networks": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of CIDR blocks or IP addresses that define the network locality."
                }
            },
            "required": [
                "external"
            ],
            "type": "object"
        },
        "Network_UPDATE": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Optional description of the network."
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the network."
                }
            },
            "required": [
                "name"
            ],
            "type": "object"
        },
        "Node": {
            "properties": {
                "add_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time the sensor was added to the console, expressed in milliseconds since the epoch."
                },
                "display_name": {
                    "type": "string",
                    "description": "The friendly name of the sensor."
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether the sensor is reporting to the console."
                },
                "firmware_version": {
                    "type": "string",
                    "description": "The version of the ExtraHop firmware currently running on the sensor."
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname of the sensor."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the sensor."
                },
                "license_status": {
                    "type": "string",
                    "description": "Verifies whether the sensor has a valid ExtraHop license."
                },
                "nickname": {
                    "type": "string",
                    "description": "The friendly name for the sensor."
                },
                "ntp_sync": {
                    "type": "boolean",
                    "description": "Indicates whether the time is in sync between the sensor and the console."
                },
                "product_key": {
                    "type": "string",
                    "description": "The product key that is applied to the sensor."
                },
                "status_code": {
                    "type": "string",
                    "description": "The status code of the sensor, expressed as a string."
                },
                "status_message": {
                    "type": "string",
                    "description": "The status message for the sensor."
                },
                "time_added": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Deprecated. Replaced by the add_time field."
                },
                "time_offset": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The difference in time between the sensor and the console, expressed in seconds."
                },
                "uuid": {
                    "type": "string",
                    "description": "The universal unique identifier of the sensor."
                }
            },
            "required": [
                "id",
                "hostname",
                "display_name",
                "status_code",
                "license_status",
                "product_key",
                "ntp_sync",
                "time_offset",
                "nickname",
                "enabled"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "hostname",
                "display_name",
                "time_added",
                "add_time",
                "status_code",
                "status_message",
                "firmware_version",
                "license_status",
                "product_key",
                "ntp_sync",
                "time_offset",
                "uuid"
            ],
            "x-unsettable": [
                "id",
                "hostname",
                "display_name",
                "time_added",
                "add_time",
                "status_code",
                "status_message",
                "firmware_version",
                "license_status",
                "product_key",
                "ntp_sync",
                "time_offset",
                "uuid"
            ]
        },
        "Node_UPDATE": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether the sensor is reporting to the console."
                },
                "nickname": {
                    "type": "string",
                    "description": "The friendly name for the sensor."
                }
            },
            "required": [
                "nickname",
                "enabled"
            ],
            "type": "object"
        },
        "Observations": {
            "properties": {},
            "type": "object"
        },
        "OpenDataStream": {
            "properties": {},
            "type": "object"
        },
        "PacketSearch": {
            "properties": {},
            "type": "object"
        },
        "RecordLog": {
            "properties": {},
            "type": "object"
        },
        "RunningConfig": {
            "properties": {},
            "additionalProperties": {
                "type": "object"
            },
            "type": "object"
        },
        "SSLDecryptKey": {
            "properties": {
                "cert_pem": {
                    "type": "string",
                    "description": "The contents of the public certificate PEM file."
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Indicates whether the SSL decryption key is active."
                },
                "id": {
                    "type": "string",
                    "description": "The hexadecimal representation of the SHA-1 hash of the SSL decryption key. The string contains no delimiters."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the SSL decryption key."
                }
            },
            "required": [
                "id",
                "name",
                "enabled",
                "cert_pem"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "name",
                "cert_pem"
            ],
            "x-unsettable": [
                "id"
            ]
        },
        "SSLDecryptKeyProtocol": {
            "properties": {
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The port in which to listen for traffic."
                },
                "protocol": {
                    "type": "string",
                    "description": "The name of the protocol, in lowercase."
                }
            },
            "required": [
                "protocol",
                "port"
            ],
            "type": "object",
            "x-uneditable": [
                "protocol",
                "port"
            ]
        },
        "SSLDecryptKeyProtocol_CREATE": {
            "properties": {
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The port in which to listen for traffic."
                },
                "protocol": {
                    "type": "string",
                    "description": "The name of the protocol, in lowercase."
                }
            },
            "required": [
                "protocol",
                "port"
            ],
            "type": "object",
            "x-uneditable": [
                "protocol",
                "port"
            ]
        },
        "SSLDecryptKey_UPDATE": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Indicates whether the SSL decryption key is active."
                }
            },
            "required": [
                "enabled"
            ],
            "type": "object"
        },
        "Software": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Deprecated. This field was never populated."
                },
                "id": {
                    "type": "string",
                    "description": "The unique identifier for the software."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the software."
                },
                "software_type": {
                    "type": "string",
                    "enum": [
                        "OS"
                    ],
                    "description": "The type of software."
                },
                "version": {
                    "type": "string",
                    "description": "The version of the software."
                }
            },
            "required": [
                "software_type",
                "name",
                "version",
                "id"
            ],
            "type": "object",
            "x-uneditable": [
                "software_type",
                "name",
                "version",
                "description",
                "id"
            ],
            "x-unsettable": [
                "software_type",
                "name",
                "version",
                "description",
                "id"
            ]
        },
        "SupportPack": {
            "properties": {
                "created_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time the support pack was created, expressed in milliseconds since the epoch."
                },
                "filename": {
                    "type": "string",
                    "description": "The name of the support pack file."
                },
                "size": {
                    "type": "string",
                    "description": "The disk size of the support pack gzip file."
                }
            },
            "required": [
                "filename",
                "size",
                "created_time"
            ],
            "type": "object",
            "x-uneditable": [
                "filename",
                "size",
                "created_time"
            ],
            "x-unsettable": [
                "filename",
                "size",
                "created_time"
            ]
        },
        "Tag": {
            "properties": {
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the tag."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Time of most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The string value for the tag."
                }
            },
            "required": [
                "mod_time",
                "id",
                "name"
            ],
            "type": "object",
            "x-uneditable": [
                "mod_time",
                "id"
            ],
            "x-unsettable": [
                "mod_time",
                "id"
            ]
        },
        "Tag_CREATE": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The string value for the tag."
                }
            },
            "required": [
                "name"
            ],
            "type": "object"
        },
        "Tag_UPDATE": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The string value for the tag."
                }
            },
            "required": [
                "name"
            ],
            "type": "object"
        },
        "ThreatCollection": {
            "properties": {
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the threat collection."
                },
                "last_updated": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp of the most recent update to the threat collection, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The unique name for the threat collection."
                },
                "observables": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of STIX Observables loaded from the threat collection."
                },
                "user_key": {
                    "type": "string",
                    "description": "The user-supplied unique identifier for the threat collection."
                }
            },
            "required": [
                "name",
                "observables",
                "id"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "observables",
                "id",
                "user_key",
                "last_updated"
            ],
            "x-unsettable": [
                "name",
                "observables",
                "id",
                "user_key",
                "last_updated"
            ]
        },
        "Trigger": {
            "properties": {
                "apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the trigger applies to all relevant resources."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the creator of the trigger."
                },
                "debug": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether debug statements are printed for the trigger."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the trigger."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the trigger can run."
                },
                "event": {
                    "type": "string",
                    "description": "Deprecated. Replaced by the events field."
                },
                "events": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of events on which the trigger runs, expressed as a JSON array."
                },
                "hints": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "Options that are based on selected trigger events. For more information about the hints object, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#advanced-trigger-options)."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the trigger."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of the most recent update, expressed as milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the trigger."
                },
                "script": {
                    "type": "string",
                    "description": "The JavaScript content of the trigger."
                }
            },
            "required": [
                "mod_time",
                "id",
                "name",
                "script",
                "events",
                "disabled",
                "debug",
                "apply_all"
            ],
            "type": "object",
            "x-uneditable": [
                "mod_time",
                "id"
            ],
            "x-unsettable": [
                "mod_time",
                "id"
            ]
        },
        "Trigger_CREATE": {
            "properties": {
                "apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the trigger applies to all relevant resources."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the creator of the trigger."
                },
                "debug": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether debug statements are printed for the trigger."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the trigger."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the trigger can run."
                },
                "event": {
                    "type": "string",
                    "description": "Deprecated. Replaced by the events field."
                },
                "events": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of events on which the trigger runs, expressed as a JSON array."
                },
                "hints": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "Options that are based on selected trigger events. For more information about the hints object, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#advanced-trigger-options)."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the trigger."
                },
                "script": {
                    "type": "string",
                    "description": "The JavaScript content of the trigger."
                }
            },
            "required": [
                "name",
                "script",
                "events",
                "disabled",
                "debug",
                "apply_all"
            ],
            "type": "object"
        },
        "Trigger_UPDATE": {
            "properties": {
                "apply_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the trigger applies to all relevant resources."
                },
                "author": {
                    "type": "string",
                    "description": "The name of the creator of the trigger."
                },
                "debug": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether debug statements are printed for the trigger."
                },
                "description": {
                    "type": "string",
                    "description": "An optional description of the trigger."
                },
                "disabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates whether the trigger can run."
                },
                "event": {
                    "type": "string",
                    "description": "Deprecated. Replaced by the events field."
                },
                "events": {
                    "type": "array",
                    "format": "pq_array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of events on which the trigger runs, expressed as a JSON array."
                },
                "hints": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "Options that are based on selected trigger events. For more information about the hints object, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#advanced-trigger-options)."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the trigger."
                },
                "script": {
                    "type": "string",
                    "description": "The JavaScript content of the trigger."
                }
            },
            "required": [
                "name",
                "script",
                "events",
                "disabled",
                "debug",
                "apply_all"
            ],
            "type": "object"
        },
        "User": {
            "properties": {
                "date_joined": {
                    "type": "string",
                    "description": "The timestamp when the user account was created. The timestamp is expressed in milliseconds since the epoch."
                },
                "effective_roles": {
                    "type": "object",
                    "format": "json",
                    "default": {
                        "write": "limited"
                    },
                    "description": "The permission level for the user determined by the granted role and permissions received outside of the granted role, such as through a user group. Supported permission levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#privilege-levels)."
                },
                "eh_account_team": {
                    "type": "boolean",
                    "default": false,
                    "description": "Indicates an ExtraHop Account Team user that accesses the ExtraHop system through ExtraHop Cloud Services."
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether the user is able to login to the ExtraHop system."
                },
                "granted_roles": {
                    "type": "object",
                    "format": "json",
                    "default": {},
                    "description": "The permission level explicitly granted to the user. Supported permission levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#privilege-levels)."
                },
                "last_ui_login_time": {
                    "type": "string",
                    "description": "The timestamp when the user last logged into the ExtraHop system. The timestamp is expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "A friendly name for the user."
                },
                "type": {
                    "type": "string",
                    "default": "local",
                    "description": "The type of user. Supported values are \"local\" and \"remote\"."
                },
                "username": {
                    "type": "string",
                    "description": "The login name for the user."
                }
            },
            "required": [
                "username",
                "date_joined",
                "enabled",
                "name",
                "type"
            ],
            "type": "object",
            "x-uneditable": [
                "username",
                "date_joined",
                "last_ui_login_time",
                "type",
                "effective_roles",
                "eh_account_team"
            ],
            "x-unsettable": [
                "date_joined",
                "last_ui_login_time",
                "type",
                "effective_roles"
            ]
        },
        "UserGroup": {
            "properties": {
                "display_name": {
                    "type": "string",
                    "description": "The display name for the user group."
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Indicates whether the user group is enabled."
                },
                "id": {
                    "type": "string",
                    "description": "The unique identifier for the user group."
                },
                "is_remote": {
                    "type": "boolean",
                    "description": "Indicates whether the user group is local or remote."
                },
                "last_sync_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp when the user group membership list was last refreshed. The timestamp is expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The name for the user group."
                },
                "rights": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The user group permissions for the current user."
                }
            },
            "required": [
                "id",
                "name"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "name",
                "is_remote",
                "display_name",
                "last_sync_time",
                "rights"
            ],
            "x-unsettable": [
                "id",
                "is_remote",
                "display_name",
                "last_sync_time",
                "rights"
            ]
        },
        "UserGroupMember": {
            "properties": {
                "users": {
                    "type": "object",
                    "format": "json",
                    "description": "The set of members and their roles in the user group."
                }
            },
            "required": [
                "users"
            ],
            "type": "object",
            "x-uneditable": [
                "users"
            ],
            "x-unsettable": [
                "users"
            ]
        },
        "UserGroupUserGroup": {
            "properties": {},
            "type": "object"
        },
        "UserGroup_CREATE": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Indicates whether the user group is enabled."
                },
                "name": {
                    "type": "string",
                    "description": "The name for the user group."
                }
            },
            "required": [
                "name"
            ],
            "type": "object",
            "x-uneditable": [
                "name"
            ]
        },
        "UserGroup_UPDATE": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Indicates whether the user group is enabled."
                }
            },
            "type": "object"
        },
        "Vlan": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description for the VLAN."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the VLAN."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time of most recent update, expressed in milliseconds since the epoch."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the VLAN."
                },
                "network_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the network that the VLAN is associated with."
                },
                "node_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the Command cluster that the VLAN is associated with."
                },
                "vlanid": {
                    "type": "integer",
                    "format": "int64",
                    "description": "An 802.1Q identifier for the VLAN."
                }
            },
            "required": [
                "mod_time",
                "id",
                "vlanid"
            ],
            "type": "object",
            "x-uneditable": [
                "mod_time",
                "network_id",
                "node_id",
                "id",
                "vlanid"
            ],
            "x-unsettable": [
                "mod_time",
                "network_id",
                "node_id",
                "id",
                "vlanid"
            ]
        },
        "Vlan_UPDATE": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional description for the VLAN."
                },
                "name": {
                    "type": "string",
                    "description": "The friendly name for the VLAN."
                }
            },
            "type": "object"
        },
        "Watchlist": {
            "properties": {},
            "type": "object"
        },
        "analysis_priority_config": {
            "properties": {
                "advanced_rules": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/analysis_priority_rule"
                    },
                    "description": "The Advanced Analysis priority rules for a device group."
                },
                "autofill_advanced": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether to automatically place devices in Advanced Analysis until capacity is reached. Devices in the advanced_rules list are prioritized, followed by devices in the standard_rules list, and then by the discovery time for the device. The capacity for Advanced Analysis is determined by the ExtraHop system license."
                },
                "autofill_standard": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether to automatically place devices in Standard Analysis until total capacity is reached. Devices in the standard_rules list are prioritized, followed by the discovery time for the device. The total capacity is determined by the ExtraHop system license."
                },
                "standard_rules": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/analysis_priority_rule"
                    },
                    "description": "The Standard Analysis priority rules for a device group."
                }
            },
            "required": [
                "autofill_advanced",
                "autofill_standard"
            ],
            "type": "object",
            "x-uneditable": [
                "is_in_effect"
            ],
            "x-unsettable": [
                "is_in_effect"
            ]
        },
        "analysis_priority_rule": {
            "properties": {
                "description": {
                    "type": "string",
                    "format": "string",
                    "description": "The description for analysis priority rules."
                },
                "object_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the group."
                },
                "type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "device_group"
                    ],
                    "description": "The type of group the analysis priority rules apply to."
                }
            },
            "required": [
                "type",
                "object_id"
            ],
            "type": "object"
        },
        "apikey_response": {
            "properties": {
                "apikey": {
                    "type": "string",
                    "format": "string",
                    "description": "The entire API key generated by the setup user."
                }
            },
            "required": [
                "apikey"
            ],
            "type": "object",
            "x-uneditable": [
                "apikey"
            ],
            "x-unsettable": [
                "apikey"
            ]
        },
        "appliance_action": {
            "properties": {
                "action": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "unenroll"
                    ],
                    "description": "Specify the action to modify ExtraHop Cloud Services settings."
                }
            },
            "required": [
                "action"
            ],
            "type": "object",
            "x-uneditable": [
                "action"
            ]
        },
        "appliance_versions": {
            "properties": {
                "system_ids": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The unique identifiers of the appliances that can be upgraded to this firmware version."
                },
                "version": {
                    "type": "string",
                    "format": "string",
                    "description": "The firmware version."
                }
            },
            "type": "object",
            "x-uneditable": [
                "version",
                "system_ids"
            ],
            "x-unsettable": [
                "version",
                "system_ids"
            ]
        },
        "assignment": {
            "properties": {
                "assign": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "IDs of resources to assign"
                },
                "unassign": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "IDs of resources to unassign"
                }
            }
        },
        "backup_name": {
            "properties": {
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "A unique name for the backup file."
                }
            },
            "required": [
                "name"
            ],
            "type": "object"
        },
        "bad_certificate_signing_request": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The parameters for the SSL certificate signing request are invalid."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "bad_ticket_tracking_request": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "bundle_apply": {
            "properties": {
                "include_assignments": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether object assignments should be restored with the bundle."
                },
                "node_ids": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of unique identifiers for the sensors on which to apply the bundle. This field is valid only on a console."
                },
                "policy": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "overwrite",
                        "skip"
                    ],
                    "description": "Indicates whether conflicting objects should be overwritten or skipped."
                }
            },
            "required": [
                "policy",
                "include_assignments",
                "node_ids"
            ],
            "type": "object"
        },
        "capture_state_parameters": {
            "properties": {
                "capture_state": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "live",
                        "upload",
                        "dj",
                        "dj_combined"
                    ],
                    "description": "The capture state of the appliance."
                }
            },
            "required": [
                "capture_state"
            ],
            "type": "object",
            "x-uneditable": [
                "capture_state"
            ]
        },
        "certificate_signing_request": {
            "properties": {
                "pem": {
                    "type": "string",
                    "format": "string",
                    "description": "The SSL certificate signing request in PKCS#10 PEM format."
                }
            },
            "required": [
                "pem"
            ],
            "type": "object",
            "x-uneditable": [
                "pem"
            ],
            "x-unsettable": [
                "pem"
            ]
        },
        "certificate_signing_request_parameters": {
            "properties": {
                "subject": {
                    "format": "certificate_subject",
                    "$ref": "#/definitions/certificate_subject",
                    "description": "The subject of the SSL certificate. For a list of certificate subject fields, see below."
                },
                "subject_alternative_names": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/subject_alternative_name"
                    },
                    "description": "A list of names that the certificate applies to, such as {\"type\": \"dns\", \"name\": \"www.example.com\"}."
                }
            },
            "required": [
                "subject_alternative_names",
                "subject"
            ],
            "type": "object",
            "x-uneditable": [
                "subject_alternative_names",
                "subject"
            ]
        },
        "certificate_subject": {
            "properties": {
                "common_name": {
                    "type": "string",
                    "format": "string",
                    "description": "The subject common name (CN)."
                },
                "country_code": {
                    "type": "string",
                    "format": "string",
                    "description": "The subject country (C)."
                },
                "email_address": {
                    "type": "string",
                    "format": "string",
                    "description": "The subject e-mail address (emailAddress)."
                },
                "locality_name": {
                    "type": "string",
                    "format": "string",
                    "description": "The subject locality (L)."
                },
                "organization_name": {
                    "type": "string",
                    "format": "string",
                    "description": "The subject organization (O)."
                },
                "organizational_unit_name": {
                    "type": "string",
                    "format": "string",
                    "description": "The subject organizational unit (OU)."
                },
                "state_or_province_name": {
                    "type": "string",
                    "format": "string",
                    "description": "The subject state or province (ST)."
                }
            },
            "required": [
                "common_name"
            ],
            "type": "object",
            "x-uneditable": [
                "common_name",
                "country_code",
                "state_or_province_name",
                "locality_name",
                "organization_name",
                "organizational_unit_name",
                "email_address"
            ]
        },
        "cluster_state_exa_only": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "cluster_state_parameters": {
            "properties": {
                "ingest_enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether record ingest is enabled for the Explore cluster."
                },
                "replication_policy": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The replication level that determines how many copies of each record are stored."
                }
            },
            "type": "object"
        },
        "connect_appliance": {
            "properties": {
                "data_access": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether data can be shared between the local and remote appliances."
                },
                "fingerprint": {
                    "type": "string",
                    "format": "string",
                    "description": "The fingerprint of the remote appliance. If you are connecting a console to an EXA or ExtraHop packetsore, this field is required. Otherwise, to bypass fingerprint verification, specify 'insecure_skip_verification'. Note that bypassing verification can allow for man-in-the-middle attacks."
                },
                "host": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname of the remote appliance."
                },
                "local_nickname_for_remote": {
                    "type": "string",
                    "format": "string",
                    "description": "The nickname for the local appliance, referred to by the remote appliance."
                },
                "managed_by_local": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether the remote appliance is managed by the local appliance. If you are connecting a console to a sensor, this field is not required because console always manage connected sensors."
                },
                "manages_local": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether the remote appliance manages the local appliance."
                },
                "product_key": {
                    "type": "string",
                    "format": "string",
                    "description": "The product key for the remote appliance. If this parameter is specified, the remote appliance is licensed with the product key. This parameter is invalid when the remote_pairing_token parameter is specified."
                },
                "remote_appliance_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "command",
                        "explore",
                        "discover",
                        "trace"
                    ],
                    "description": "The type of appliance for the new connection."
                },
                "remote_nickname_for_local": {
                    "type": "string",
                    "format": "string",
                    "description": "The nickname for the remote appliance, referred to by the local appliance. If you are connecting a sensor to any other appliance, this field is required."
                },
                "remote_pairing_token": {
                    "type": "string",
                    "format": "string",
                    "description": "The token generated on the target sensor or EXA 5300 recordstore. You must specify this parameter to authenticate to the target sensor or recordstore. This parameter is not valid if you are connecting to an ExtraHop packetstore or EXA 5200 recordstore."
                },
                "remote_setup_password": {
                    "type": "string",
                    "format": "string",
                    "description": "The password for the setup user account on the target EXA or ExtraHop packetstore. This parameter is not required if the remote appliance is a node in an Explore cluster already connected to the console. This parameter is not valid if the remote appliance is a sensor."
                },
                "reset_configuration": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether to reset the configuration of the remote appliance."
                }
            },
            "required": [
                "host",
                "remote_appliance_type",
                "data_access"
            ],
            "type": "object",
            "x-uneditable": [
                "host",
                "remote_setup_password",
                "remote_pairing_token",
                "fingerprint",
                "reset_configuration",
                "remote_nickname_for_local",
                "local_nickname_for_remote",
                "remote_appliance_type",
                "manages_local",
                "managed_by_local",
                "data_access",
                "product_key"
            ]
        },
        "criteria": {
            "properties": {
                "protocol_default": {
                    "type": "string",
                    "format": "string",
                    "description": "The default protocols monitored by the application. Supported values are 'any' and 'none'."
                },
                "protocols": {
                    "type": "object",
                    "format": "json",
                    "description": "The list of one or more protocol and role mappings associated with the application. The application only collects metrics from the specified protocols. The format of each protocol is {'protocol':'role'}. Example: {'http': 'server'}. Supported role values are 'client', 'server', 'any', or 'none'."
                },
                "sources": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/source"
                    },
                    "description": "An array containing one or more metric sources associated with the application. The application only collects metrics from the specified sources. The contents of this array are defined in the 'source' section below."
                }
            },
            "required": [
                "protocol_default",
                "sources"
            ],
            "type": "object"
        },
        "customization_status": {
            "properties": {
                "did_last_succeed": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether the most recent backup succeeded."
                },
                "last_attempt_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp of the most recent backup, expressed in milliseconds since the epoch."
                },
                "last_success_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The timestamp of the most recent backup that was successful, expressed in milliseconds since the epoch."
                }
            },
            "required": [
                "did_last_succeed",
                "last_attempt_time",
                "last_success_time"
            ],
            "type": "object",
            "x-uneditable": [
                "did_last_succeed",
                "last_attempt_time",
                "last_success_time"
            ],
            "x-unsettable": [
                "did_last_succeed",
                "last_attempt_time",
                "last_success_time"
            ]
        },
        "detection_access_params": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether detections access settings are enabled. When enabled, administrators can restrict detections access for specified users. You cannot disable detections access settings after the settings are enabled."
                }
            },
            "required": [
                "enabled"
            ],
            "type": "object"
        },
        "detection_hiding_participant": {
            "properties": {
                "object_hostname": {
                    "type": [
                        "array",
                        "string"
                    ],
                    "format": "any",
                    "description": "The hostname of a participant. You can specify a single hostname in a string or multiple hostnames in an array. This option is valid only if the object_type is \"hostname\"."
                },
                "object_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The ID for the device, device group, or network locality. This option is valid only if the object_type is \"device\", \"device_group\", or \"network_locality\"."
                },
                "object_locality": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "internal",
                        "external"
                    ],
                    "description": "The network locality type of the participant. Specify either \"external\" or \"internal\". This option is valid only if the object_type is \"locality_type\"."
                },
                "object_scanner": {
                    "type": [
                        "string",
                        "array"
                    ],
                    "format": "any",
                    "description": "The name of an external scanning service. You can specify a single service in a string or multiple values in an array. You can also specify \"Any\" to select any scanning service. This option is valid only if the object_type is \"scanner_service\"."
                },
                "object_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "device",
                        "device_group",
                        "ipaddr",
                        "locality_type",
                        "network_locality",
                        "hostname",
                        "scanner_service"
                    ],
                    "description": "The type of participant."
                },
                "object_value": {
                    "type": [
                        "array",
                        "string"
                    ],
                    "format": "any",
                    "description": "The IP address or CIDR block of the participant. You can specify a single address or block in a string or multiple addresses or blocks in an array. This option is valid only if the object_type is \"ipaddr\"."
                }
            },
            "required": [
                "object_type"
            ],
            "type": "object"
        },
        "detection_hiding_update_params": {
            "properties": {
                "description": {
                    "type": "string",
                    "format": "string",
                    "description": "The description of the tuning rule."
                },
                "enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether the tuning rule is enabled."
                },
                "expiration": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the tuning rule expires, expressed in milliseconds since the epoch. A value of null or 0 indicates that the rule does not expire."
                },
                "offender": {
                    "format": "detection_hiding_participant",
                    "$ref": "#/definitions/detection_hiding_participant",
                    "description": "The offender that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any offender."
                },
                "properties": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/detection_property_filter"
                    },
                    "description": "The filter criteria for detection properties."
                },
                "victim": {
                    "format": "detection_hiding_participant",
                    "$ref": "#/definitions/detection_hiding_participant",
                    "description": "The victim that this tuning rule applies to. Specify a detection_hiding_participant object to apply the rule to a specific victim, or specify \"Any\" to apply the rule to any victim."
                }
            },
            "type": "object",
            "x-unsettable": [
                "enabled",
                "expiration",
                "description",
                "offender",
                "victim",
                "properties"
            ]
        },
        "detection_mitre_category": {
            "properties": {
                "id": {
                    "type": "string",
                    "format": "string",
                    "description": "The ID of the MITRE technique or tactic."
                },
                "legacy_ids": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of the MITRE technique prior to the introduction of sub-techniques."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the MITRE technique or tactic."
                },
                "url": {
                    "type": "string",
                    "format": "string",
                    "description": "The web address of the technique or tactic on the MITRE website."
                }
            },
            "required": [
                "id",
                "name",
                "url",
                "legacy_ids"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "name",
                "url",
                "legacy_ids"
            ],
            "x-unsettable": [
                "id",
                "name",
                "url",
                "legacy_ids"
            ]
        },
        "detection_participant": {
            "properties": {
                "external": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether the participant is an external endpoint."
                },
                "hostname": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname that corresponds to the IP address or device associated with the detection. This field is not included for all participants."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Participant identifier."
                },
                "object_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The ID for the device or application associated with the detection. This field is sometimes included for IP address participants. If the field is included for an IP address participant, the object_id is the ID of the gateway device associated with the IP address."
                },
                "object_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "device",
                        "application",
                        "ipaddr"
                    ],
                    "description": "The type of participant."
                },
                "object_value": {
                    "type": "string",
                    "format": "string",
                    "description": "The IP address for the participant associated with the detection. This field is sometimes included for device participants. If this field is included for a device participant, the object_value is the IP address of the device at the time the detection occurred."
                },
                "origins": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The origin IP addresses associated with the participant through the REST API."
                },
                "role": {
                    "type": "string",
                    "format": "string",
                    "description": "The role of the device or application in the detection."
                },
                "usernames": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The usernames associated with the participant through the REST API."
                }
            },
            "required": [
                "id",
                "object_type"
            ],
            "type": "object",
            "x-uneditable": [
                "id"
            ],
            "x-unsettable": [
                "id"
            ]
        },
        "detection_property_filter": {
            "properties": {
                "operand": {
                    "type": [
                        "string",
                        "integer",
                        "object"
                    ],
                    "format": "any",
                    "description": "The value that the filter attempts to match. The filter compares the value of the operand to the value of the detection property and applies the compare method specified by the operator parameter. You can specify the operand as a string, integer, or object. For more information, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#operand-values-for-detection-property-tuning-rules)."
                },
                "operator": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "=",
                        "!=",
                        "~",
                        "!~",
                        "in"
                    ],
                    "description": "The compare method applied when matching the operand value against the detection property value."
                },
                "property": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the property to filter."
                }
            },
            "required": [
                "property",
                "operator"
            ],
            "type": "object"
        },
        "detection_search_filter": {
            "properties": {
                "assignee": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Returns detections assigned to the specified user. Specify \".none\" to search for unassigned detections or specify \".me\" to search for detections assigned to the authenticated user."
                },
                "categories": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Return detections from the specified categories."
                },
                "category": {
                    "type": "string",
                    "format": "string",
                    "description": "Deprecated. Replaced by the categories field."
                },
                "recommended": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Returns detections recommended for triage. This field is valid only on a console."
                },
                "resolution": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "enum": [
                        "action_taken",
                        "no_action_taken"
                    ],
                    "description": "Returns detections for tickets with the specified resolution. Specify \".none\" to search for detections without resolutions."
                },
                "risk_score_min": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Returns detections with risk scores greater than or equal to the specified value."
                },
                "status": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "enum": [
                        "new",
                        "in_progress",
                        "closed",
                        "acknowledged"
                    ],
                    "description": "Returns detections with the specified status. To search for detections with a null status, which is displayed in the ExtraHop system as Open, specify \".none\". You can only change the status of a detection to \"new\" through the REST API when [third party ticket tracking is enabled](https://docs.extrahop.com/9.8/detections-configure-ticket-tracking/#configure-third-party-ticket-tracking-for-detections)."
                },
                "ticket_id": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Returns detections that are associated with the specified tickets. Specify \".none\" to search for detections that are not associated with tickets."
                },
                "types": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Returns detections with the specified types."
                }
            },
            "type": "object",
            "x-uneditable": [
                "category",
                "categories",
                "assignee",
                "ticket_id",
                "status",
                "resolution",
                "types",
                "risk_score_min",
                "recommended"
            ]
        },
        "detection_search_params": {
            "properties": {
                "create_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Returns detections that were created after the specified date, expressed in milliseconds since the epoch. For sensors, this returns detections that were generated after the specified date. For consoles, this returns detections that were first synchronized to the console after the specified date."
                },
                "filter": {
                    "format": "detection_search_filter",
                    "$ref": "#/definitions/detection_search_filter",
                    "description": "Detection-specific filters."
                },
                "from": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Returns detections that occurred after the specified date, expressed in milliseconds since the epoch. Detections that started before the specified date are returned if the detection was ongoing at that time."
                },
                "id_only": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Returns only the IDs of the detections."
                },
                "limit": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Returns no more than the specified number of detections."
                },
                "mod_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Returns detections that were updated after the specified date, expressed in milliseconds since the epoch."
                },
                "offset": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of detections to skip for pagination."
                },
                "sort": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/detection_search_sort"
                    },
                    "description": "Sorts returned detections by the specified fields. By default, detections are sorted by most recent update time and then ID in ascending order."
                },
                "until": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Return detections that ended before the specified date, expressed in milliseconds since the epoch."
                },
                "update_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Returns detections related to events that occurred after the specified date, expressed in milliseconds since the epoch. Note that the ExtraHop Machine Learning Service analyzes historical data to generate detections, and so there is a time delay between when the events that cause those detections occur and when the detections are generated. If you search for detections in the same update_time window multiple times, the later search might return detections that were not returned by the earlier search."
                }
            },
            "type": "object",
            "x-uneditable": [
                "filter",
                "from",
                "limit",
                "offset",
                "sort",
                "until",
                "update_time",
                "mod_time",
                "create_time",
                "id_only"
            ]
        },
        "detection_search_sort": {
            "properties": {
                "direction": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "asc",
                        "desc"
                    ],
                    "default": "asc",
                    "description": "The order in which returned detections are sorted."
                },
                "field": {
                    "type": "string",
                    "format": "string",
                    "description": "The field to sort detections by."
                }
            },
            "required": [
                "field"
            ],
            "type": "object",
            "x-uneditable": [
                "direction",
                "field"
            ]
        },
        "detection_update_params": {
            "properties": {
                "assignee": {
                    "type": "string",
                    "format": "string",
                    "description": "The assignee of the detection or the ticket associated with the detection."
                },
                "participants": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/detection_update_participant_params"
                    },
                    "description": "A list of devices and applications associated with the detection. You can modify specific fields for a participant, but you cannot add new participants to a detection."
                },
                "resolution": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "action_taken",
                        "no_action_taken"
                    ],
                    "description": "The resolution of the detection or the ticket associated with the detection."
                },
                "status": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "new",
                        "in_progress",
                        "closed",
                        "acknowledged"
                    ],
                    "description": "The status of the detection or the ticket associated with the detection. If the value is null, the status displayed in the ExtraHop system is Open. The value \"new\" can only be specified through the REST API when [third party ticket tracking is enabled](https://docs.extrahop.com/9.8/detections-configure-ticket-tracking/#configure-third-party-ticket-tracking-for-detections)."
                },
                "ticket_id": {
                    "type": "string",
                    "format": "string",
                    "description": "The ID of the ticket associated with the detection."
                }
            },
            "required": [
                "ticket_id"
            ],
            "type": "object",
            "x-unsettable": [
                "ticket_id",
                "assignee",
                "status",
                "resolution",
                "participants"
            ]
        },
        "detection_update_participant_params": {
            "properties": {
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The ID of the participant associated with the detection."
                },
                "origins": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The origin IP addresses associated with the participant through the REST API."
                },
                "usernames": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The usernames associated with the participant through the REST API."
                }
            },
            "required": [
                "id"
            ],
            "type": "object",
            "x-unsettable": [
                "id",
                "usernames",
                "origins"
            ]
        },
        "detection_update_ticket_params": {
            "properties": {
                "assignee": {
                    "type": "string",
                    "format": "string",
                    "description": "The assignee of the ticket associated with the detection."
                },
                "resolution": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "action_taken",
                        "no_action_taken"
                    ],
                    "description": "The resolution of the ticket associated with the detection."
                },
                "status": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "new",
                        "in_progress",
                        "closed",
                        "acknowledged"
                    ],
                    "description": "The status of the ticket associated with the detection."
                },
                "ticket_id": {
                    "type": "string",
                    "format": "string",
                    "description": "The ID of the ticket associated with the detection."
                }
            },
            "required": [
                "ticket_id"
            ],
            "type": "object",
            "x-unsettable": [
                "ticket_id",
                "assignee",
                "status",
                "resolution"
            ]
        },
        "detectionsaccesslevel_map": {
            "properties": {
                "attribute_name": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute that grants detection privileges on the ExtraHop system."
                },
                "full": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants access to detections on the ExtraHop system."
                },
                "none": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that prevents all access to detections on the ExtraHop system."
                }
            },
            "type": "object",
            "x-unsettable": [
                "attribute_name",
                "none",
                "full"
            ]
        },
        "device_group_settings": {
            "properties": {
                "description": {
                    "type": "string",
                    "format": "string",
                    "default": "",
                    "description": "An optional description of the device group."
                },
                "editors": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of users that can edit the device group."
                },
                "field": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "any",
                        "name",
                        "ip address",
                        "mac address",
                        "vendor",
                        "type",
                        "tag",
                        "vlan",
                        "activity",
                        "node",
                        "discover time"
                    ],
                    "description": "Deprecated. Replaced by the filter parameter."
                },
                "filter": {
                    "format": "group_filter",
                    "$ref": "#/definitions/group_filter",
                    "description": "Specify the filter criteria for search results."
                },
                "include_custom_devices": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": true,
                    "description": "Deprecated. Replaced by the filter parameter."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The friendly name for the device group."
                },
                "value": {
                    "type": "string",
                    "format": "SearchString",
                    "description": "Deprecated. Replaced by the filter parameter."
                }
            },
            "required": [
                "name"
            ],
            "type": "object",
            "x-uneditable": [
                "dynamic"
            ]
        },
        "device_identification": {
            "properties": {
                "encrypted_ids": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The encrypted discovery IDs of the devices to get."
                },
                "from": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The start time in ms for which activity and software will be returned for devices."
                },
                "until": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The end time in ms for which activity and software will be returned for devices."
                }
            },
            "required": [
                "encrypted_ids"
            ],
            "type": "object",
            "x-uneditable": [
                "encrypted_ids",
                "from",
                "until"
            ],
            "x-unsettable": [
                "encrypted_ids",
                "from",
                "until"
            ]
        },
        "device_search": {
            "properties": {
                "active_from": {
                    "type": [
                        "integer",
                        "string"
                    ],
                    "format": "Timestamp",
                    "description": "The beginning timestamp for the request. Return only devices active after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes."
                },
                "active_until": {
                    "type": [
                        "integer",
                        "string"
                    ],
                    "format": "Timestamp",
                    "description": "The ending timestamp for the request. Return only devices active before this time. Follows the same time value guidelines as the active_from parameter."
                },
                "filter": {
                    "format": "search_filter",
                    "$ref": "#/definitions/search_filter",
                    "description": "Specify the filter criteria for search results."
                },
                "limit": {
                    "type": "integer",
                    "format": "int64",
                    "default": 100,
                    "description": "Limit the number of devices returned to the specified maximum number."
                },
                "offset": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Skip the specified number of devices. This parameter is often combined with the limit parameter to paginate result sets."
                },
                "result_fields": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "enum": [
                        "mod_time",
                        "node_id",
                        "id",
                        "extrahop_id",
                        "discovery_id",
                        "display_name",
                        "description",
                        "user_mod_time",
                        "discover_time",
                        "vlanid",
                        "parent_id",
                        "macaddr",
                        "vendor",
                        "is_l3",
                        "ipaddr4",
                        "ipaddr6",
                        "device_class",
                        "default_name",
                        "custom_name",
                        "cdp_name",
                        "dhcp_name",
                        "netbios_name",
                        "dns_name",
                        "custom_type",
                        "auto_role",
                        "analysis_level",
                        "analysis",
                        "role",
                        "on_watchlist",
                        "last_seen_time",
                        "activity",
                        "model",
                        "model_override",
                        "custom_make",
                        "custom_model",
                        "critical",
                        "custom_criticality",
                        "cloud_instance_id",
                        "cloud_instance_type",
                        "cloud_instance_description",
                        "cloud_instance_name",
                        "cloud_account",
                        "vpc_id",
                        "subnet_id"
                    ],
                    "description": "Returns the specified fields and the device id. If this option is not specified, all fields are returned."
                }
            },
            "type": "object",
            "x-uneditable": [
                "active_from",
                "active_until",
                "limit",
                "offset",
                "filter",
                "result_fields"
            ]
        },
        "error": {
            "properties": {
                "error_message": {
                    "type": "string"
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "extrahop_edition": {
            "properties": {
                "edition": {
                    "type": "string",
                    "format": "string",
                    "description": "The edition of the appliance."
                }
            },
            "required": [
                "edition"
            ],
            "type": "object",
            "x-uneditable": [
                "edition"
            ],
            "x-unsettable": [
                "edition"
            ]
        },
        "extrahop_idrac": {
            "properties": {
                "ipaddr": {
                    "type": "string",
                    "format": "string",
                    "description": "The iDRAC IP address of the appliance."
                }
            },
            "required": [
                "ipaddr"
            ],
            "type": "object",
            "x-uneditable": [
                "ipaddr"
            ],
            "x-unsettable": [
                "ipaddr"
            ]
        },
        "extrahop_info": {
            "properties": {
                "display_host": {
                    "type": "string",
                    "format": "string",
                    "description": "The host value displayed in the absolute URL for the appliance. Returns the value of the external_hostname field. If the value of external_hostname is null, returns the value of the hostname field. If hostname is null, returns the value of the mgmt_ipaddr field."
                },
                "external_hostname": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname specified in the \"external_hostname\" field of the running configuration file. If the field is not set, returns null."
                },
                "hostname": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname specified in the \"hostname\" field of the running configuration file. If the value of the field is \"extrahop\", returns null."
                },
                "mgmt_ipaddr": {
                    "type": "string",
                    "format": "string",
                    "description": "The primary management IP address of the appliance."
                },
                "platform": {
                    "type": "string",
                    "format": "string",
                    "description": "The platform name of the appliance."
                },
                "version": {
                    "type": "string",
                    "format": "string",
                    "description": "The firmware version running on the appliance."
                }
            },
            "required": [
                "version",
                "platform",
                "hostname",
                "mgmt_ipaddr",
                "display_host",
                "external_hostname"
            ],
            "type": "object",
            "x-uneditable": [
                "version",
                "platform",
                "hostname",
                "mgmt_ipaddr",
                "display_host",
                "external_hostname"
            ],
            "x-unsettable": [
                "version",
                "platform",
                "hostname",
                "mgmt_ipaddr",
                "display_host",
                "external_hostname"
            ]
        },
        "extrahop_platform": {
            "properties": {
                "platform": {
                    "type": "string",
                    "format": "string",
                    "description": "The platform name of the appliance."
                }
            },
            "required": [
                "platform"
            ],
            "type": "object",
            "x-uneditable": [
                "platform"
            ],
            "x-unsettable": [
                "platform"
            ]
        },
        "extrahop_version": {
            "properties": {
                "version": {
                    "type": "string",
                    "format": "string",
                    "description": "The firmware version running on the appliance."
                }
            },
            "required": [
                "version"
            ],
            "type": "object",
            "x-uneditable": [
                "version"
            ],
            "x-unsettable": [
                "version"
            ]
        },
        "fetch_cursor_body": {
            "properties": {
                "cursor": {
                    "type": "string",
                    "format": "string",
                    "description": "The unique identifier of the cursor that specifies the next page of results in the query."
                }
            },
            "required": [
                "cursor"
            ],
            "type": "object",
            "x-uneditable": [
                "cursor"
            ]
        },
        "filter": {
            "properties": {
                "field": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the field in the record to be filtered. The query compares the contents of the field parameter to the value of the operand parameter. If the specified field name is \".any\", the union of all field values will be searched. If the specified field name is \".ipaddr\" or \".port\", the client, server, sender, and receiver roles are included in the search. Field names are located in record formats that can be viewed in the ExtraHop system."
                },
                "operand": {
                    "type": [
                        "object",
                        "string",
                        "integer"
                    ],
                    "format": "any",
                    "description": "The value that the query attempts to match. The query compares the value of the operand to the contents of the field parameter and applies the compare method specified by the operator parameter. You can explicitly specify the operand data type as described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#operand-values-in-record-queries)."
                },
                "operator": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "\u003e",
                        "\u003c",
                        "\u003c=",
                        "\u003e=",
                        "=",
                        "!=",
                        "startswith",
                        "~",
                        "!~",
                        "and",
                        "or",
                        "not",
                        "exists",
                        "not_exists",
                        "in",
                        "not_in"
                    ],
                    "description": "The compare method applied when matching the operand value against the field contents. All filter objects require an operator."
                },
                "rules": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/filter"
                    },
                    "description": "The list of one or more filter objects within a single filter object. Filter objects can be embedded recursively. Only \"and\", \"or\", and \"not\" operators are allowed for this parameter."
                }
            },
            "required": [
                "operator"
            ],
            "type": "object",
            "x-uneditable": [
                "field",
                "operator",
                "operand",
                "rules"
            ]
        },
        "firmware_download_unprocessable_entity": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "firmware_hopcloud_download_parameters": {
            "properties": {
                "upgrade": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Specifies whether to upgrade the appliance after the firmware download is complete."
                },
                "version": {
                    "type": "string",
                    "format": "string",
                    "description": "The version of the firmware to download."
                }
            },
            "required": [
                "version"
            ],
            "type": "object",
            "x-uneditable": [
                "version",
                "upgrade"
            ]
        },
        "firmware_rollback_error": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The firmware rollback error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "firmware_rollback_info": {
            "properties": {
                "backup_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The last time that a backup file was created for the previous firmware version, expressed in milliseconds since the epoch. If the system is rolled back, customizations and resources from this backup file are restored."
                },
                "version": {
                    "type": "string",
                    "format": "string",
                    "description": "The previous version of firmware that you can roll back the appliance to."
                }
            },
            "required": [
                "version",
                "backup_time"
            ],
            "type": "object",
            "x-uneditable": [
                "version",
                "backup_time"
            ],
            "x-unsettable": [
                "version",
                "backup_time"
            ]
        },
        "firmware_upgrade_parameters": {
            "properties": {
                "force": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Specifies whether to skip compatibility verification. Skip verification only if ExtraHop Support has reviewed and approved the upgrade."
                },
                "restart_after": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether to restart the appliance after the upgrade is complete."
                },
                "silent": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Specifies whether to disable the ExtraHop Web UI during the upgrade process. If an upgrade fails, the appliance will automatically revert to the previous firmware version."
                }
            },
            "type": "object",
            "x-uneditable": [
                "force"
            ]
        },
        "firmware_upgrade_success": {
            "properties": {
                "success_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The success message."
                }
            },
            "required": [
                "success_message"
            ],
            "type": "object",
            "x-uneditable": [
                "success_message"
            ],
            "x-unsettable": [
                "success_message"
            ]
        },
        "firmware_upgrade_unprocessable_entity": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "firmware_upload_success": {
            "properties": {
                "success_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The success message."
                }
            },
            "required": [
                "success_message"
            ],
            "type": "object",
            "x-uneditable": [
                "success_message"
            ],
            "x-unsettable": [
                "success_message"
            ]
        },
        "firmware_upload_unprocessable_entity": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "firmware_upload_unsupported_media": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "firmware_url_download_parameters": {
            "properties": {
                "firmware_url": {
                    "type": "string",
                    "format": "string",
                    "description": "The URL of the firmware to download. HTTPS, HTTP, and FTP schemes are supported."
                },
                "force": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Specifies whether to skip compatibility verification. Skip verification only if ExtraHop Support has reviewed and approved the upgrade."
                },
                "upgrade": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Specifies whether to upgrade the appliance after the firmware download is complete."
                }
            },
            "required": [
                "firmware_url"
            ],
            "type": "object",
            "x-uneditable": [
                "firmware_url",
                "upgrade",
                "force"
            ]
        },
        "flowlogs_secret_response": {
            "properties": {
                "secret": {
                    "type": "string",
                    "format": "string",
                    "description": "The secret value."
                }
            },
            "required": [
                "secret"
            ],
            "type": "object",
            "x-uneditable": [
                "secret"
            ],
            "x-unsettable": [
                "secret"
            ]
        },
        "get_config_manager": {
            "properties": {
                "manager": {
                    "format": "get_manager",
                    "$ref": "#/definitions/get_manager",
                    "description": "The object that contains information about the console that manages analysis priority rules for the local sensor."
                }
            },
            "required": [
                "manager"
            ],
            "type": "object",
            "x-uneditable": [
                "manager"
            ],
            "x-unsettable": [
                "manager"
            ]
        },
        "get_manager": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname of the console that manages analysis priority rules for the local sensor, or the hostname of the local sensor if the rules are self-managed."
                },
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier of the console that manages analysis priority rules for the local sensor, or the value is 0 if the rules are self-managed by the sensor."
                }
            },
            "required": [
                "id",
                "hostname"
            ],
            "type": "object",
            "x-uneditable": [
                "id",
                "hostname"
            ],
            "x-unsettable": [
                "id",
                "hostname"
            ]
        },
        "group_filter": {
            "properties": {},
            "required": [
                "operator"
            ],
            "type": "object",
            "x-uneditable": [
                "field",
                "operator",
                "operand",
                "rules"
            ]
        },
        "http": {
            "properties": {
                "additional_header": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies an additional HTTP header to include in each request. Headers must be specified in the following format: \"\u003ckey\u003e:\u003cvalue\u003e\". For example: \"additional_header\": \"Accept: text/html\"."
                },
                "authentication": {
                    "format": "http_auth",
                    "$ref": "#/definitions/http_auth",
                    "description": "An object that contains HTTP authentication credentials."
                },
                "host": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname or IP address of the remote HTTP server."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name for the target."
                },
                "pipeline": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether multiple concurrent HTTP connections are enabled, which can improve throughput speed."
                },
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The TCP port number of the HTTP server."
                },
                "protocol": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "http",
                        "https"
                    ],
                    "description": "The protocol to transmit data over."
                },
                "skip_cert_verification": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether to bypass TLS certificate verification for encrypted data. This parameter is valid only if `protocol` is set to `https`."
                }
            },
            "required": [
                "name",
                "host",
                "port",
                "protocol",
                "pipeline",
                "authentication"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "host",
                "port",
                "protocol",
                "skip_cert_verification",
                "pipeline",
                "additional_header",
                "authentication"
            ]
        },
        "http_auth": {
            "properties": {
                "access_key": {
                    "type": "string",
                    "format": "string",
                    "description": "The access key ID. This option is required for AWS and Azure Storage authentication."
                },
                "auth_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "none",
                        "basic",
                        "aws",
                        "azure_storage",
                        "azure_ad",
                        "crowdstrike"
                    ],
                    "description": "The type of HTTP authentication."
                },
                "client_id": {
                    "type": "string",
                    "format": "string",
                    "description": "The client ID. This option is required for Microsoft Entra ID and Crowdstrike authentication."
                },
                "client_secret": {
                    "type": "string",
                    "format": "string",
                    "description": "The client Secret Key. This option is required for Microsoft Entra ID and Crowdstrike authentication."
                },
                "grant_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "client",
                        "resource_owner"
                    ],
                    "description": "The OAuth 2.0 grant type. This option is required for Microsoft Entra ID authentication."
                },
                "password": {
                    "type": "string",
                    "format": "string",
                    "description": "The password of the user. This option is required if `auth_type` is set to `basic` or if `auth_type` is set to `azure_ad` and `grant_type` is set to `resource_owner`."
                },
                "region": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the AWS region, such as \"us-west-1\". This option is required for AWS authentication."
                },
                "resource": {
                    "type": "string",
                    "format": "string",
                    "description": "The Microsoft Entra ID resource URI. This option is required for Microsoft Entra ID authentication."
                },
                "secret_key": {
                    "type": "string",
                    "format": "string",
                    "description": "The secret access key. This option is required for AWS authentication."
                },
                "service": {
                    "type": "string",
                    "format": "string",
                    "description": "The service code of the AWS service, such as \"AmazonEC2\". This option is required for AWS authentication."
                },
                "token_endpoint": {
                    "type": "string",
                    "format": "string",
                    "description": "The Microsoft Entra ID /token  endpoint. For example: \"https://login.microsoftonline.com/\u003ctenant_id\u003e/oauth2/token\". This option is required for Microsoft Entra ID authentication."
                },
                "username": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the user. This option is required if `auth_type` is set to `basic` or if `auth_type` is set to `azure_ad` and `grant_type` is set to `resource_owner`."
                }
            },
            "required": [
                "auth_type"
            ],
            "type": "object",
            "x-uneditable": [
                "auth_type",
                "username",
                "password",
                "access_key",
                "secret_key",
                "service",
                "region",
                "grant_type",
                "client_id",
                "client_secret",
                "resource",
                "token_endpoint"
            ]
        },
        "idp_bad_request": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string"
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "important_device": {
            "properties": {
                "oid": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The oid of the device to mark as important."
                },
                "reason": {
                    "type": "string",
                    "format": "string",
                    "description": "The reason why the device is important."
                }
            },
            "required": [
                "oid",
                "reason"
            ],
            "type": "object",
            "x-uneditable": [
                "oid",
                "reason"
            ]
        },
        "important_devices": {
            "properties": {
                "important_devices": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/important_device"
                    },
                    "description": "The set of devices to mark as important."
                }
            },
            "required": [
                "important_devices"
            ],
            "type": "object",
            "x-uneditable": [
                "important_devices"
            ]
        },
        "invalid_search": {
            "properties": {
                "detail": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                },
                "type": {
                    "type": "string",
                    "format": "string",
                    "description": "The error return type."
                }
            },
            "required": [
                "type",
                "detail"
            ],
            "type": "object",
            "x-uneditable": [
                "type",
                "detail"
            ],
            "x-unsettable": [
                "type",
                "detail"
            ]
        },
        "investigation_create_params": {
            "properties": {
                "assessment": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "malicious_true_positive",
                        "benign_true_positive",
                        "false_positive",
                        "undecided"
                    ],
                    "description": "The assessment of the investigation."
                },
                "assignee": {
                    "type": "string",
                    "format": "string",
                    "description": "The username of the investigation assignee."
                },
                "event_ids": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The list of IDs for detections in the investigation."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the investigation."
                },
                "notes": {
                    "type": "string",
                    "format": "string",
                    "description": "Optional notes about the investigation."
                },
                "status": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "open",
                        "in_progress",
                        "closed"
                    ],
                    "description": "The status of the investigation."
                }
            },
            "required": [
                "name"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "status",
                "notes",
                "event_ids",
                "assignee",
                "assessment"
            ]
        },
        "investigation_search_params": {
            "properties": {
                "creation_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Returns investigations that were created after the specified date, expressed in milliseconds since the epoch."
                },
                "is_user_created": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Returns only investigations that were created manually by a user."
                },
                "update_time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Returns investigations that were updated after the specified date, expressed in milliseconds since the epoch."
                }
            },
            "type": "object",
            "x-uneditable": [
                "update_time",
                "creation_time",
                "is_user_created"
            ]
        },
        "investigation_update_params": {
            "properties": {
                "assessment": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "malicious_true_positive",
                        "benign_true_positive",
                        "false_positive",
                        "undecided"
                    ],
                    "description": "The assessment of the investigation."
                },
                "assignee": {
                    "type": "string",
                    "format": "string",
                    "description": "The username of the investigation assignee."
                },
                "event_ids": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The list of IDs for detections in the investigation. If you specify this field, the new list of IDs replaces the existing list."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the investigation."
                },
                "notes": {
                    "type": "string",
                    "format": "string",
                    "description": "Optional notes about the investigation."
                },
                "status": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "open",
                        "in_progress",
                        "closed"
                    ],
                    "description": "The status of the investigation."
                }
            },
            "type": "object",
            "x-unsettable": [
                "name",
                "status",
                "notes",
                "event_ids",
                "assignee",
                "assessment"
            ]
        },
        "kafka": {
            "properties": {
                "authentication": {
                    "format": "kafka_auth",
                    "$ref": "#/definitions/kafka_auth",
                    "description": "An object that contains Kafka authentication credentials."
                },
                "brokers": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/kafka_brokers"
                    },
                    "description": "An array of one or more objects that contain information about Kafka Brokers."
                },
                "compression": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "none",
                        "gzip",
                        "snappy"
                    ],
                    "default": "none",
                    "description": "The compression method to apply to transmitted data."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name for the target."
                },
                "partition_strategy": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "hash_key",
                        "manual",
                        "random",
                        "round_robin"
                    ],
                    "default": "hash_key",
                    "description": "The partitioning method to apply to transmitted data."
                },
                "protocol": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "tcp",
                        "tls"
                    ],
                    "default": "tcp",
                    "description": "The protocol to transmit data over."
                },
                "skip_cert_verification": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether to bypass TLS certificate verification for encrypted data. This parameter is valid only if protocol is set to tls."
                },
                "tls_ca_certs": {
                    "type": "string",
                    "format": "string",
                    "description": "The trusted certificates to validate the Kafka server certificate with, in PEM format. Specify this option if your Kafka server certificate has not been signed by a valid Certificate Authority (CA). If this option is not specified, the server certificate is validated with the built-in list of valid CA certificates. This option is valid only if the protocol is TLS."
                },
                "tls_client_cert": {
                    "type": "string",
                    "format": "string",
                    "description": "The TLS client certificate that is sent to the Kafka server during the TLS handshake. Specify this option if client authentication is enabled on the Kafka server."
                },
                "tls_client_key": {
                    "type": "string",
                    "format": "string",
                    "description": "The private key of the TLS client certificate specified by the tls_client_cert parameter. Specify this option if client authentication is enabled on the Kafka server."
                }
            },
            "required": [
                "name",
                "brokers",
                "protocol"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "brokers",
                "compression",
                "partition_strategy",
                "protocol",
                "tls_client_cert",
                "tls_client_key",
                "skip_cert_verification",
                "tls_ca_certs",
                "authentication"
            ]
        },
        "kafkaODS": {
            "properties": {
                "brokers": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/kafka_brokers"
                    },
                    "description": "An array of one or more objects that contain information about Kafka Brokers."
                },
                "compression": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "none",
                        "gzip",
                        "snappy"
                    ],
                    "default": "none",
                    "description": "The compression method applied to transmitted data."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the target."
                },
                "partition_strategy": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "hash_key",
                        "manual",
                        "random",
                        "round_robin"
                    ],
                    "default": "hash_key",
                    "description": "The partitioning method applied to transmitted data."
                },
                "protocol": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "tcp",
                        "tls"
                    ],
                    "default": "tcp",
                    "description": "The protocol that data is transmitted over."
                },
                "skip_cert_verification": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether TLS certificate verification is bypassed for encrypted data."
                },
                "tls_ca_certs": {
                    "type": "string",
                    "format": "string",
                    "description": "The trusted certificates that the Kafka server certificate is validated with, in PEM format."
                },
                "tls_client_cert": {
                    "type": "string",
                    "format": "string",
                    "description": "The TLS client certificate that is sent to the Kafka server during the TLS handshake."
                },
                "tls_client_key": {
                    "type": "string",
                    "format": "string",
                    "description": "The encrypted private key of the TLS client certificate."
                }
            },
            "required": [
                "name",
                "brokers",
                "protocol"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "brokers",
                "compression",
                "partition_strategy",
                "protocol",
                "tls_client_cert",
                "tls_client_key",
                "skip_cert_verification",
                "tls_ca_certs"
            ]
        },
        "kafka_auth": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "sha256",
                        "sha512"
                    ],
                    "description": "The hashing algorithm for SASL authentication."
                },
                "auth_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "scram"
                    ],
                    "description": "The type of SASL authentication."
                },
                "password": {
                    "type": "string",
                    "format": "string",
                    "description": "The password of the SASL user."
                },
                "username": {
                    "type": "string",
                    "format": "string",
                    "description": "The username of the SASL user."
                }
            },
            "required": [
                "auth_type",
                "username",
                "password",
                "algorithm"
            ],
            "type": "object",
            "x-uneditable": [
                "auth_type",
                "username",
                "password",
                "algorithm"
            ]
        },
        "kafka_brokers": {
            "properties": {
                "host": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname or IP address of the remote Kafka broker."
                },
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The TCP port number of the Kafka broker."
                }
            },
            "required": [
                "host",
                "port"
            ],
            "type": "object",
            "x-uneditable": [
                "host",
                "port"
            ]
        },
        "license_error": {
            "properties": {
                "message": {
                    "type": "string",
                    "format": "string",
                    "description": "The message describing the license error."
                },
                "properties": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/properties"
                    },
                    "description": "The list of properties for each EXA that returned the license error."
                }
            },
            "required": [
                "message",
                "properties"
            ],
            "type": "object",
            "x-uneditable": [
                "message",
                "properties"
            ],
            "x-unsettable": [
                "message",
                "properties"
            ]
        },
        "license_errors": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "Information about the status of the request."
                },
                "errors": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/license_error"
                    },
                    "description": "The list of one or more license errors and the properties of each EXA that returned an error."
                }
            },
            "required": [
                "error_message",
                "errors"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message",
                "errors"
            ],
            "x-unsettable": [
                "error_message",
                "errors"
            ]
        },
        "manual_observation_body": {
            "properties": {
                "observations": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/observation"
                    },
                    "description": "An array of observations."
                },
                "source": {
                    "type": "string",
                    "format": "string",
                    "description": "The source of the observations."
                }
            },
            "required": [
                "observations"
            ],
            "type": "object",
            "x-uneditable": [
                "observations",
                "source"
            ]
        },
        "metric_query": {
            "properties": {
                "cycle": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "auto",
                        "1sec",
                        "30sec",
                        "5min",
                        "1hr",
                        "24hr"
                    ],
                    "description": "The aggregation period for metrics."
                },
                "from": {
                    "type": [
                        "integer",
                        "string"
                    ],
                    "format": "Timestamp",
                    "description": "The beginning timestamp for the request. Return only metrics collected after this time. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--42) for supported time units and suffixes."
                },
                "metric_category": {
                    "type": "string",
                    "format": "string",
                    "description": "The group of metrics that are searchable in the metric catalog."
                },
                "metric_specs": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/metric_spec"
                    },
                    "description": "An array of metric specification objects."
                },
                "object_ids": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The list of numeric values that represent unique identifiers. Unique identifiers can be retrieved through the /networks, /devices, /applications, /vlans, /devicegroups, /activitygroups, and /appliances resources. For system health metrics, specify the ID of the sensor or console and set the object_type parameter to \"system\"."
                },
                "object_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "network",
                        "device",
                        "application",
                        "vlan",
                        "device_group",
                        "system"
                    ],
                    "description": "Indicates the object type of unique identifiers specified in the object_ids property."
                },
                "until": {
                    "type": [
                        "integer",
                        "string"
                    ],
                    "format": "Timestamp",
                    "description": "The ending timestamp for the request. Return only metrics collected before this time. Follows the same time value guidelines as the from parameter."
                }
            },
            "required": [
                "from",
                "until",
                "cycle",
                "object_type",
                "object_ids",
                "metric_category",
                "metric_specs"
            ],
            "type": "object",
            "x-uneditable": [
                "from",
                "until",
                "cycle",
                "object_type",
                "object_ids",
                "metric_category",
                "metric_specs"
            ]
        },
        "metric_response": {
            "properties": {
                "clock": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The current time on the sensor."
                },
                "cycle": {
                    "type": "string",
                    "format": "string",
                    "description": "The aggregation period for metrics."
                },
                "from": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Only metrics collected after this time are returned. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix."
                },
                "node_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The ID of the sensor that the metrics were retrieved from."
                },
                "num_results": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/stat_response"
                    },
                    "description": "The number of result sets that were retrieved. Run the GET /metrics/next/{xid} operation the specified number of times to retrieve all metric results. This field is returned only if the metric query requested activity group metrics from a console."
                },
                "stats": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/stat_response"
                    },
                    "description": "The metrics returned by the search."
                },
                "until": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Only metrics collected before this time are returned. Time is expressed in milliseconds since the epoch. 0 indicates the time of the request. A negative value is evaluated relative to the current time. The default unit for a negative value is milliseconds, but other units can be specified with a unit suffix."
                },
                "xid": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/stat_response"
                    },
                    "description": "The unique identifier to specify in the GET /metrics/next/{xid} operation. This field is returned only if the metric query requested activity group metrics from a console."
                }
            },
            "type": "object",
            "x-uneditable": [
                "cycle",
                "node_id",
                "clock",
                "from",
                "until",
                "stats",
                "xid",
                "num_results"
            ],
            "x-unsettable": [
                "cycle",
                "node_id",
                "clock",
                "from",
                "until",
                "stats",
                "xid",
                "num_results"
            ]
        },
        "metric_spec": {
            "properties": {
                "calc_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "mean",
                        "percentiles"
                    ],
                    "description": "The type of calculation to perform."
                },
                "key1": {
                    "type": "string",
                    "format": "string",
                    "description": "Filter detail metrics. Detail metrics break down data through keys, which are strings or IP addresses. For example, the metric \"HTTP Requests by Method\" accepts a key1 value of \"GET.\" Keys can also be regular expressions that are delimited with forward slashes (\"/GET/\")."
                },
                "key2": {
                    "type": "string",
                    "format": "string",
                    "description": "Enable additional filtering on detail metrics."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The field name for the metric. When filtering in the metric catalog on a metric_category, each result is a potential metric_spec name. When a result is selected from the catalog, the \"Metric\" field value is a valid option for this field."
                },
                "percentiles": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The list of percentiles, sorted in ascending order, which should be returned. This parameter is only required if the calc_type parameter is set to \"percentiles\". If the calc_type parameter is set to mean, the percentiles property cannot be set."
                }
            },
            "required": [
                "name"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "key1",
                "key2",
                "calc_type",
                "percentiles"
            ]
        },
        "mongodb": {
            "properties": {
                "authentication": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/mongodb_auth"
                    },
                    "description": "An array of objects that contain MongoDB authentication credentials."
                },
                "encrypt": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether data is encrypted with TLS."
                },
                "host": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname or IP address of the remote MongoDB server."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name for the target."
                },
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The TCP port number of the MongoDB server."
                },
                "skip_cert_verification": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether to bypass TLS certificate verification for encrypted data. This parameter is valid only if `encrypt` is set to `true`."
                }
            },
            "required": [
                "name",
                "host",
                "port"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "host",
                "port",
                "encrypt",
                "skip_cert_verification"
            ]
        },
        "mongodb_auth": {
            "properties": {
                "database": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the MongoDB database."
                },
                "password": {
                    "type": "string",
                    "format": "string",
                    "description": "The password of the user."
                },
                "user": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the user that has permission to modify the specified database."
                }
            },
            "required": [
                "database",
                "user",
                "password"
            ],
            "type": "object",
            "x-uneditable": [
                "database",
                "user",
                "password"
            ]
        },
        "ndrlevel_map": {
            "properties": {
                "attribute_name": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute that grants NDR privileges on the ExtraHop system."
                },
                "full": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants access to NDR on the ExtraHop system."
                },
                "none": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that prevents all access to NDR on the ExtraHop system."
                }
            },
            "type": "object",
            "x-unsettable": [
                "attribute_name",
                "none",
                "full"
            ]
        },
        "new_ssl_key": {
            "properties": {
                "certificate": {
                    "type": "string",
                    "format": "string",
                    "description": "The SSL certificate associated with this decryption key."
                },
                "enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicate whether this SSL decryption key is active."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The friendly name for the SSL decryption key."
                },
                "private_key": {
                    "type": "string",
                    "format": "string",
                    "description": "The SSL private key that decrypts traffic."
                }
            },
            "required": [
                "enabled",
                "name",
                "certificate",
                "private_key"
            ],
            "type": "object",
            "x-uneditable": [
                "enabled",
                "name",
                "certificate",
                "private_key"
            ]
        },
        "node_firmware_upgrade_parameters": {
            "properties": {
                "system_ids": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of unique identifiers for the remote appliances. You can retrieve appliance IDs with the GET /api/v1/appliances operation; appliance IDs are returned in the id fields of the response."
                },
                "version": {
                    "type": "string",
                    "format": "string",
                    "description": "The firmware version to upgrade appliances to. You can retrieve a list of valid versions with the GET /api/v1/appliances/firmware/next operation."
                }
            },
            "required": [
                "version",
                "system_ids"
            ],
            "type": "object",
            "x-uneditable": [
                "version",
                "system_ids"
            ]
        },
        "node_firmware_upgrade_unprocessable_entity": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "npmlevel_map": {
            "properties": {
                "attribute_name": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute that grants NPM privileges on the ExtraHop system."
                },
                "full": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants access to NPM on the ExtraHop system."
                },
                "none": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that prevents all access to NPM on the ExtraHop system."
                }
            },
            "type": "object",
            "x-unsettable": [
                "attribute_name",
                "none",
                "full"
            ]
        },
        "observation": {
            "properties": {
                "associated_ipaddr": {
                    "type": "string",
                    "format": "string",
                    "description": "The associated IP address."
                },
                "ipaddr": {
                    "type": "string",
                    "format": "string",
                    "description": "The device IP address observed by the sensor or console."
                },
                "timestamp": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the observation was created by the source, expressed in milliseconds since the epoch."
                }
            },
            "required": [
                "ipaddr",
                "associated_ipaddr",
                "timestamp"
            ],
            "type": "object",
            "x-uneditable": [
                "ipaddr",
                "associated_ipaddr",
                "timestamp"
            ]
        },
        "packets_search_request": {
            "properties": {
                "always_return_body": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Specifies the behavior if the query does not match any packets or if the packets matched by the query do not contain any files. If the value is true, the system returns an empty file and a 200 status code. If the value is false, the system returns a 204 status code but does not return a file."
                },
                "bpf": {
                    "type": "string",
                    "format": "string",
                    "description": "The Berkeley Packet Filter (BPF) syntax for the packet search. For more information about BPF syntax, see [Filter packets with Berkeley Packet Filter syntax](https://docs.extrahop.com/9.8/bpf-syntax/)."
                },
                "decrypt_files": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Specifies whether to decrypt extracted files with stored secrets. This option is valid only if the `output` parameter is `extract`."
                },
                "from": {
                    "type": "string",
                    "format": "string",
                    "default": "-30m",
                    "description": "The beginning timestamp of the time range the search will include, expressed in milliseconds since the epoch. A negative value specifies that the search will begin with packets captured at a time in the past. For example, specify -10m to begin the search with packets captured 10 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes."
                },
                "include_secrets": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Whether or not to include TLS secrets together with packet data in .pcapng files. Only valid if \"output\" is \"pcapng\"."
                },
                "ip1": {
                    "type": "string",
                    "format": "string",
                    "description": "Returns packets sent to or received by the specified IP address."
                },
                "ip2": {
                    "type": "string",
                    "format": "string",
                    "description": "Returns packets sent to or received by the specified IP address."
                },
                "limit_bytes": {
                    "type": "string",
                    "format": "string",
                    "default": "100MB",
                    "description": "The approximate maximum number of bytes to return. After the ExtraHop system finds packets that match the size specified in the search criteria, the system stops searching for additional packets. However, because the system analyzes multiple packets at a time, the total size of the packets returned might be larger than the specified size. The default unit is bytes, but you can specify other units with a unit suffix. The default value is \"100MB\". **Note**: If the output is \"extract\", there is a maximum value for this field. The default maximum is \"100MB\", but the maximum can be modified in the running configuration. If the output is not \"extract\", there is no maximum value."
                },
                "limit_search_duration": {
                    "type": "string",
                    "format": "string",
                    "default": "5m",
                    "description": "The approximate maximum amount of time to perform the packet search. After the specified amount of time has passed, the ExtraHop system stops searching for additional packets. However, the system will extend past the specified time to finish analyzing packets that were being searched before the time expired, and the system analyzes multiple packets at a time. Therefore, the search might last longer than the specified time. The default unit is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes. The default value is \"5m\". **Note**: If the output is \"extract\", there is a maximum value for this field. The default maximum is \"5m\", but the maximum can be modified in the running configuration. If the output is not \"extract\", there is no maximum value."
                },
                "output": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "pcap",
                        "keylog_txt",
                        "pcapng",
                        "zip",
                        "extract"
                    ],
                    "default": "pcap",
                    "description": "The output format."
                },
                "port1": {
                    "type": "string",
                    "format": "string",
                    "description": "Returns packets sent from or received on the specified port."
                },
                "port2": {
                    "type": "string",
                    "format": "string",
                    "description": "Returns packets sent from or received on the specified port."
                },
                "until": {
                    "type": "string",
                    "format": "string",
                    "description": "The ending timestamp of the time range the search will include, expressed in milliseconds since the epoch. A 0 value specifies that the search will end with packets captured at the time of the search. A negative value specifies that the search will end with packets captured at a time in the past. For example, specify -5m to end the search with packets captured 5 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units-) for supported time units and suffixes."
                }
            },
            "required": [
                "from"
            ],
            "type": "object",
            "x-uneditable": [
                "output",
                "include_secrets",
                "decrypt_files",
                "limit_bytes",
                "limit_search_duration",
                "always_return_body",
                "from",
                "until",
                "bpf",
                "ip1",
                "port1",
                "ip2",
                "port2"
            ]
        },
        "packetslevel_map": {
            "properties": {
                "attribute_name": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute that grants packet privileges on the ExtraHop system."
                },
                "full": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants access to packets on the ExtraHop system."
                },
                "full_with_keys": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants access to packets and session keys on the ExtraHop system."
                },
                "none": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that prevents all access to packets on the ExtraHop system."
                },
                "slices_only": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants access to only packet slices on the ExtraHop system."
                }
            },
            "type": "object",
            "x-unsettable": [
                "attribute_name",
                "none",
                "full_with_keys",
                "full",
                "slices_only"
            ]
        },
        "partialsuccess": {
            "properties": {
                "failures": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/partialsuccessfailure"
                    }
                },
                "message": {
                    "type": "string",
                    "description": "Status information about request"
                }
            },
            "required": [
                "message",
                "failures"
            ],
            "type": "object",
            "x-uneditable": [
                "message",
                "failures"
            ],
            "x-unsettable": [
                "message",
                "failures"
            ]
        },
        "partialsuccessfailure": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "The type of action which was requested"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the object this error is about"
                },
                "reason": {
                    "type": "string",
                    "description": "Specific reason this operation failed"
                }
            },
            "required": [
                "action",
                "id",
                "reason"
            ],
            "type": "object",
            "x-uneditable": [
                "action",
                "id",
                "reason"
            ],
            "x-unsettable": [
                "action",
                "id",
                "reason"
            ]
        },
        "patch_body": {
            "properties": {
                "description": {
                    "type": "string",
                    "format": "string",
                    "description": "An optional description of the network locality entry."
                },
                "external": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether the network is internal or external."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the network locality."
                },
                "network": {
                    "type": "string",
                    "format": "string",
                    "description": "Deprecated. Specify CIDR blocks or IP addresses with the networks field."
                },
                "networks": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of CIDR blocks or IP addresses that define the network locality."
                }
            },
            "type": "object"
        },
        "product_key": {
            "properties": {
                "product_key": {
                    "type": "string",
                    "format": "string",
                    "description": "Apply the specified product key to the appliance."
                }
            },
            "required": [
                "product_key"
            ],
            "type": "object",
            "x-unsettable": [
                "product_key"
            ]
        },
        "properties": {
            "properties": {
                "host": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname of the EXA."
                },
                "license_status": {
                    "type": "string",
                    "format": "string",
                    "description": "The status of the license on the EXA."
                }
            },
            "required": [
                "host",
                "license_status"
            ],
            "type": "object",
            "x-uneditable": [
                "host",
                "license_status"
            ],
            "x-unsettable": [
                "host",
                "license_status"
            ]
        },
        "raw": {
            "properties": {
                "compression": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether gzip compression is applied to transmitted data."
                },
                "gzip_threshold_bytes": {
                    "type": "integer",
                    "format": "int64",
                    "default": 64000,
                    "description": "The number of bytes that specifies the threshold for creating a new message. Every 30 seconds, the sensor or console sends messages that exceed the specified size to prevent messages from growing too large. This option is valid only if `compression` is set to `true`."
                },
                "gzip_threshold_seconds": {
                    "type": "integer",
                    "format": "int64",
                    "default": 300,
                    "description": "The number of seconds that specifies the threshold for creating a new message.  Every 30 seconds, the sensor or console sends messages that have been written for more than the specified time period to prevent messages from growing too large. This option is valid only if `compression` is set to `true`."
                },
                "host": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname or IP address of the remote server."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name for the target."
                },
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The TCP or UDP port number of the remote server."
                },
                "protocol": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "tcp",
                        "udp"
                    ],
                    "description": "The protocol to transmit data over."
                }
            },
            "required": [
                "name",
                "host",
                "port",
                "protocol"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "host",
                "port",
                "protocol",
                "compression",
                "gzip_threshold_bytes",
                "gzip_threshold_seconds"
            ]
        },
        "record_query": {
            "properties": {
                "context_ttl": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The amount of time to keep the search context active. The default unit is milliseconds, but other units can be specified with a unit suffix. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--54) for supported time units and suffixes. In RevealX Enterprise, this field is only valid if records are stored on an ExtraHop recordstore (such as an EXA 5300) or on CrowdStrike LogScale. In RevealX 360, this field is only valid for systems that have a cloud-based recordstore with Premium Investigation. In both RevealX Enterprise with CrowdStrike LogScale and RevealX 360 with Premium Investigation, this field is invalid if the sort or offset fields are specified."
                },
                "filter": {
                    "format": "filter",
                    "$ref": "#/definitions/filter",
                    "description": "The object containing the parameters that specify the filter criteria. The parameters are defined under the filter section below. If no filter values are provided, the query returns all records that match the time range and any specified record formats."
                },
                "from": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The beginning timestamp of the time range the query will search, expressed in milliseconds since the epoch. A negative value specifies that the search will begin with records created at a time in the past. For example, specify -600000ms to begin the search with records created 10 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--54) for supported time units and suffixes."
                },
                "limit": {
                    "type": "integer",
                    "format": "int64",
                    "default": 100,
                    "description": "The maximum number of records returned by the query. The maximum value cannot exceed 10000. The default value is 100."
                },
                "offset": {
                    "type": "integer",
                    "format": "int64",
                    "default": 0,
                    "description": "The number of records to skip in the query results. The query will return records starting from the offset value. This parameter is often combined with the limit and sort parameters. The default value is 0. For ExtraHop recordstores, the maximum value is 10,000; to retrieve records returned after the first 10,000, see POST /records/cursor/. For third-party recordstores, there is no maximum value."
                },
                "sort": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/sort_item"
                    },
                    "description": "The list of one or more sort objects that specify sort priorities. The returned records are sorted in the order the objects are listed. The parameters are defined under the sort_item section below. If no sort_item values are provided, records are sorted by timestamp in descending order."
                },
                "types": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of one or more record formats. The query returns only records that match the specified formats. If no value is specified, the query returns records of any type. Valid values for this field are displayed in the Record Type field on the Record Formats page. For example: \"~cifs\"."
                },
                "until": {
                    "type": "integer",
                    "format": "int64",
                    "default": 0,
                    "description": "The ending timestamp of the time range the query will search, expressed in milliseconds since the epoch. A 0 value specifies that the search will end with records created at the time of the request. A negative value specifies that the search will end with records created at a time in the past. For example, specify -300000ms to end the search with records created 5 minutes before the time of the request. Negative values can be specified with a time unit other than milliseconds, such as seconds or hours. See the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#supported-time-units--54) for supported time units and suffixes."
                }
            },
            "required": [
                "from"
            ],
            "type": "object",
            "x-uneditable": [
                "from",
                "until",
                "types",
                "limit",
                "offset",
                "sort",
                "filter",
                "context_ttl"
            ]
        },
        "record_response": {
            "properties": {
                "cursor": {
                    "type": "string",
                    "format": "string",
                    "description": "A cursor ID that specifies the next page in a collection of results, which can be passed to POST /records/cursor/ to retrieve the next collection of results. A cursor ID is returned in the response only if a non-null value for the context_ttl field is specified."
                },
                "from": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The beginning timestamp of the absolute time range the query searched. The timestamp is expressed in milliseconds since the epoch. A negative value indicates a time in the past relative to the current time. For example, -300000ms indicates 5 minutes before the current time. 0 indicates the current time."
                },
                "lookback_exceeded": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "For RevealX 360, this field indicates whether all of the specified time range is outside of the licensed record lookback; if the value is true, no records are returned. For RevealX Enterprise, this field is invalid, and the value is always false."
                },
                "lookback_truncated": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "For RevealX 360, this field indicates whether part of the specified time range is outside of the licensed record lookback; if the value is true, the results are truncated and only return records within the lookback period. For RevealX Enterprise, this field is invalid, and the value is always false."
                },
                "records": {
                    "type": "object",
                    "format": "json",
                    "description": "The list of individual records that match the query request."
                },
                "total": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The total number of records that match the query request."
                },
                "until": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The ending timestamp of the absolute time range that was searched. The timestamp is expressed in milliseconds since the epoch. A negative value indicates a time in the past relative to the current time. For example, -300000ms indicates 5 minutes before the current time. 0 indicates the current time."
                },
                "warnings": {
                    "type": "object",
                    "format": "json",
                    "description": "The list of EXAs with licenses in a pre-expired or pre-disconnected state. The list includes the warning message, hostname, license state, and license expiration timestamp."
                }
            },
            "required": [
                "records",
                "total",
                "from",
                "until"
            ],
            "type": "object",
            "x-uneditable": [
                "records",
                "total",
                "from",
                "until",
                "cursor",
                "warnings",
                "lookback_truncated",
                "lookback_exceeded"
            ],
            "x-unsettable": [
                "records",
                "total",
                "from",
                "until",
                "cursor",
                "warnings",
                "lookback_truncated",
                "lookback_exceeded"
            ]
        },
        "relationship": {
            "properties": {
                "protocol": {
                    "type": "string",
                    "format": "string",
                    "description": "The metric protocol associated with the relationship, such as \"HTTP\" or \"DNS\". The operation only locates connections between devices over the specified protocol."
                },
                "role": {
                    "type": "string",
                    "format": "string",
                    "description": "The device role associated with the metric protocol of the relationship. The operation only locates connections between devices over the associated protocol in the specified role. Supported role values are \"client\", \"server\", or \"any\". Set to \"any\" to locate all client, server, and peer device relationships associated with the specified protocol."
                }
            },
            "type": "object"
        },
        "remote_job": {
            "properties": {
                "details": {
                    "type": "string",
                    "format": "string",
                    "description": "Details about the status of the job on the remote system."
                },
                "job_id": {
                    "type": "string",
                    "format": "string",
                    "description": "The ID of the job on the remote system."
                },
                "status": {
                    "type": "string",
                    "format": "string",
                    "description": "The status of the job on the remote system."
                },
                "step_description": {
                    "type": "string",
                    "format": "string",
                    "description": "A description of the step the job is currently performing on the remote system."
                },
                "step_number": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of the step the job is currently performing on the remote system."
                },
                "system_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The ID of the remote system the job is running on."
                },
                "total_steps": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The total number of steps in the job on the remote system."
                }
            },
            "required": [
                "system_id",
                "status"
            ],
            "type": "object",
            "x-uneditable": [
                "system_id",
                "job_id",
                "status",
                "details",
                "step_number",
                "total_steps",
                "step_description"
            ],
            "x-unsettable": [
                "system_id",
                "job_id",
                "status",
                "details",
                "step_number",
                "total_steps",
                "step_description"
            ]
        },
        "search_filter": {
            "properties": {
                "field": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "name",
                        "discovery_id",
                        "ipaddr",
                        "macaddr",
                        "vendor",
                        "tag",
                        "activity",
                        "node",
                        "vlan",
                        "discover_time",
                        "role",
                        "dns_name",
                        "dhcp_name",
                        "netbios_name",
                        "cdp_name",
                        "custom_name",
                        "software",
                        "software_type",
                        "model",
                        "is_critical",
                        "instance_id",
                        "instance_name",
                        "instance_type",
                        "cloud_account",
                        "vpc_id",
                        "subnet_id",
                        "is_active",
                        "analysis",
                        "network_locality_type",
                        "network_locality_id",
                        "id"
                    ],
                    "description": "The name of the field to filter results on. The search compares the contents of the field parameter to the value of the operand parameter."
                },
                "operand": {
                    "type": [
                        "integer",
                        "object",
                        "array",
                        "string"
                    ],
                    "format": "any",
                    "description": "The value that the query attempts to match. The query compares the value of the operand to the contents of the field parameter and applies the compare method specified by the operator parameter. You can specify the operand as a string, integer, or object. For information about object values, see the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#operand-values-for-device-search)."
                },
                "operator": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "\u003e",
                        "\u003c",
                        "\u003c=",
                        "\u003e=",
                        "=",
                        "!=",
                        "startswith",
                        "and",
                        "or",
                        "not",
                        "exists",
                        "not_exists",
                        "~",
                        "!~",
                        "in",
                        "not_in"
                    ],
                    "description": "The compare method applied when matching the operand value against the field contents. All filter objects require an operator."
                },
                "rules": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/search_filter"
                    },
                    "description": "An array of one or more filter objects, which can be embedded recursively. Only \"and\", \"or\", and \"not\" operators are allowed for this parameter."
                }
            },
            "required": [
                "operator"
            ],
            "type": "object",
            "x-uneditable": [
                "field",
                "operator",
                "operand",
                "rules"
            ]
        },
        "service_error_value": {
            "properties": {
                "detail": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                },
                "type": {
                    "type": "string",
                    "format": "string",
                    "description": "The error return type."
                }
            },
            "required": [
                "type",
                "detail"
            ],
            "type": "object",
            "x-uneditable": [
                "type",
                "detail"
            ],
            "x-unsettable": [
                "type",
                "detail"
            ]
        },
        "service_settings": {
            "properties": {
                "admin": {
                    "format": "service_value",
                    "$ref": "#/definitions/service_value",
                    "description": "The settings of the Management GUI service, which provides browser-based access to the appliance."
                },
                "keyreceiver": {
                    "format": "service_value",
                    "$ref": "#/definitions/service_value",
                    "description": "The settings of the SSL Session Key Receiver, which enables the appliance to receive and decrypt session keys from the session key forwarder."
                },
                "snmp": {
                    "format": "service_value",
                    "$ref": "#/definitions/service_value",
                    "description": "The settings of the SNMP service, which enables your network device monitoring software to collect information from the ExtraHop System."
                },
                "ssh": {
                    "format": "service_value",
                    "$ref": "#/definitions/service_value",
                    "description": "The settings of the SSH service, which enables users to securely log in to the ExtraHop command-line interface (CLI)."
                }
            },
            "type": "object",
            "x-unsettable": [
                "admin",
                "snmp",
                "ssh",
                "keyreceiver"
            ]
        },
        "service_value": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether the service is enabled."
                }
            },
            "required": [
                "enabled"
            ],
            "type": "object",
            "x-unsettable": [
                "enabled"
            ]
        },
        "setup_generate_apikey": {
            "properties": {
                "password": {
                    "type": "string",
                    "format": "string",
                    "description": "The password for the setup user."
                }
            },
            "required": [
                "password"
            ],
            "type": "object",
            "x-uneditable": [
                "password"
            ]
        },
        "sort_item": {
            "properties": {
                "direction": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "asc",
                        "desc"
                    ],
                    "default": "asc",
                    "description": "The order in which returned records are sorted. The default order is descending. After all other sorting criteria are applied, or if no sorting criteria was specified, the default order is descending by timestamp."
                },
                "field": {
                    "type": "string",
                    "format": "string",
                    "description": "The field name that returned records are sorted by."
                }
            },
            "type": "object",
            "x-uneditable": [
                "field",
                "direction"
            ]
        },
        "source": {
            "properties": {
                "id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the device or device group associated with the application."
                },
                "type": {
                    "type": "string",
                    "format": "string",
                    "description": "The type of metric source associated with the application. Supported source type values are 'device' and 'device_group'."
                }
            },
            "required": [
                "type",
                "id"
            ],
            "type": "object"
        },
        "source_object": {
            "properties": {
                "object_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the source object."
                },
                "object_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "device",
                        "device_group"
                    ],
                    "description": "The metric source type."
                }
            },
            "required": [
                "object_type",
                "object_id"
            ],
            "type": "object"
        },
        "stat_response": {
            "properties": {
                "duration": {
                    "type": "integer",
                    "format": "int64",
                    "description": "For the /metrics endpoint, the aggregation period for the metric, expressed in milliseconds. For the /metrics/total and /metrics/totalbyobject endpoints, the timestamp of the end of the metric aggregation period, expressed in milliseconds since the epoch."
                },
                "oid": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The ID of the object that the metric applies to."
                },
                "time": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The time that the metrics began."
                },
                "values": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "object"
                    },
                    "description": "An array that contains a metric value for each metric requested. For top-level metrics, each value is a number. For detail metrics, each value is a list of objects that specify both the metric value and the key that the metric is broken out by."
                }
            },
            "type": "object",
            "x-uneditable": [
                "oid",
                "time",
                "duration",
                "values"
            ],
            "x-unsettable": [
                "oid",
                "time",
                "duration",
                "values"
            ]
        },
        "step": {
            "properties": {
                "peer_in": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/source_object"
                    },
                    "description": "The list of one or more peer device objects to include in the activity map. Only relationships to peers of the specified source object are included. Object contents are defined in the \"source_object\" section below."
                },
                "peer_not_in": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/source_object"
                    },
                    "description": "The list of one or more peer device objects to exclude from the activity map. Relationships to peers of the specified source object are excluded. Object contents are defined in the \"source_object\" section below."
                },
                "relationships": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/relationship"
                    },
                    "description": "The list of one or more filters that define the relationship between two devices. The filters specify which roles and protocols to search for when locating peer devices in the step. Relationships are represented as an edge in the activity map. Object contents are defined in the \"relationship\" section below. If no value is specified, the operation will locate all peers."
                }
            },
            "type": "object"
        },
        "subject_alternative_name": {
            "properties": {
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "Name of Subject Alternative Name."
                },
                "type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "dns",
                        "ip"
                    ],
                    "description": "Type of Subject Alternative Name."
                }
            },
            "required": [
                "type",
                "name"
            ],
            "type": "object",
            "x-uneditable": [
                "type",
                "name"
            ]
        },
        "syslog": {
            "properties": {
                "batch_min_bytes": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The minimum number of bytes to send at a time to the syslog server."
                },
                "concurrent_connections": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of concurrent connections to send messages over."
                },
                "host": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname or IP address of the remote Syslog server."
                },
                "localtime": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether timestamps reference the local time zone of the sensor or console. If this parameter is set to false, timestamps reference GMT."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name for the target."
                },
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The TCP or UDP port number of the remote Syslog server."
                },
                "protocol": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "tcp",
                        "udp",
                        "tls"
                    ],
                    "description": "The protocol to transmit data over."
                },
                "skip_cert_verification": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether to bypass TLS certificate verification for encrypted data. This parameter is valid only if protocol is set to tls."
                },
                "tcp_length_prefix_framing": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether to prepend the number of bytes in a message to the beginning of the message. If this parameter is set to false, the end of each message is delimited by a trailing newline."
                },
                "tls_ca_certs": {
                    "type": "string",
                    "format": "string",
                    "description": "The trusted certificates to validate the Syslog server certificate with, in PEM format. Specify this option if your Syslog server certificate has not been signed by a valid Certificate Authority (CA). If this option is not specified, the server certificate is validated with the built-in list of valid CA certificates. This option is valid only if the protocol is TLS and skip_cert_verification is false."
                },
                "tls_client_cert": {
                    "type": "string",
                    "format": "string",
                    "description": "The TLS client certificate that is sent to the Syslog server during the TLS handshake. Specify this option if client authentication is enabled on the Syslog server."
                },
                "tls_client_key": {
                    "type": "string",
                    "format": "string",
                    "description": "The private key of the TLS client certificate specified by the tls_client_cert parameter. Specify this option if client authentication is enabled on the Syslog server."
                }
            },
            "required": [
                "name",
                "host",
                "port",
                "protocol"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "host",
                "port",
                "tcp_length_prefix_framing",
                "batch_min_bytes",
                "concurrent_connections",
                "localtime",
                "protocol",
                "tls_client_cert",
                "tls_client_key",
                "skip_cert_verification",
                "tls_ca_certs"
            ]
        },
        "syslogODS": {
            "properties": {
                "batch_min_bytes": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The minimum number of bytes sent at a time to the syslog server."
                },
                "concurrent_connections": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The number of concurrent connections that messages are sent over."
                },
                "host": {
                    "type": "string",
                    "format": "string",
                    "description": "The hostname or IP address of the remote Syslog server."
                },
                "localtime": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates whether timestamps reference the local time zone of the sensor or console."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The name of the target."
                },
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The TCP or UDP port number of the remote Syslog server."
                },
                "protocol": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "tcp",
                        "udp",
                        "tls"
                    ],
                    "description": "The protocol that data is transmitted over."
                },
                "skip_cert_verification": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether TLS certificate verification is bypassed for encrypted data."
                },
                "tcp_length_prefix_framing": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether to prepend the number of bytes in a message to the beginning of the message."
                },
                "tls_ca_certs": {
                    "type": "string",
                    "format": "string",
                    "description": "The trusted certificates that the Syslog server certificate is validated with, in PEM format."
                },
                "tls_client_cert": {
                    "type": "string",
                    "format": "string",
                    "description": "The TLS client certificate that is sent to the Syslog server during the TLS handshake."
                },
                "tls_client_key": {
                    "type": "string",
                    "format": "string",
                    "description": "The encrypted private key of the TLS client certificate."
                }
            },
            "required": [
                "name",
                "host",
                "port",
                "protocol"
            ],
            "type": "object",
            "x-uneditable": [
                "name",
                "host",
                "port",
                "tcp_length_prefix_framing",
                "batch_min_bytes",
                "concurrent_connections",
                "localtime",
                "protocol",
                "tls_client_cert",
                "tls_client_key",
                "skip_cert_verification",
                "tls_ca_certs"
            ]
        },
        "ticket_tracking_parameters": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Deprecated. Replaced by the external_ticketing_enabled and internal_ticketing_enabled fields."
                },
                "external_ticketing_enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether detections are tracked from an external ticketing system. This field is required if the internal_ticketing_enabled field is specified."
                },
                "internal_ticketing_enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether detections are tracked from within the ExtraHop System. This field is required if the external_ticketing_enabled field is specified."
                },
                "url_template": {
                    "type": "string",
                    "format": "string",
                    "description": "The URL template that links detections to external tickets. The template must include the $ticket_id variable. This field applies only if detections are tracked from an external ticketing system."
                }
            },
            "type": "object"
        },
        "topology_captive_request": {
            "properties": {
                "edge_annotations": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "enum": [
                        "protocols",
                        "appearances"
                    ],
                    "default": [],
                    "description": "The list of one or more edge annotations to include in the topology query."
                },
                "from": {
                    "type": [
                        "integer",
                        "string"
                    ],
                    "format": "Timestamp",
                    "description": "The beginning timestamp of the time range the query will search, expressed in milliseconds since the epoch."
                },
                "until": {
                    "type": [
                        "integer",
                        "string"
                    ],
                    "format": "Timestamp",
                    "default": 0,
                    "description": "The ending timestamp of the time range the query will search, expressed in milliseconds since the epoch. If no value is set, the query end defaults to \"now\"."
                }
            },
            "required": [
                "from"
            ],
            "type": "object",
            "x-uneditable": [
                "from",
                "until",
                "edge_annotations"
            ]
        },
        "topology_edge": {
            "properties": {
                "annotations": {
                    "format": "topology_edge_annotations",
                    "$ref": "#/definitions/topology_edge_annotations",
                    "default": {},
                    "description": "The annotation object that specifies the appearance and protocols of the edge. Object contents are defined in the \"topology_edge_annotations\" section below."
                },
                "from": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique object identifier for the client/sender device object."
                },
                "to": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique object identifier for the server/receiver device object."
                },
                "weight": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The total weight of the edge. The unit of measure is determined by the value set in the \"weighting\" parameter."
                }
            },
            "required": [
                "from",
                "to",
                "weight"
            ],
            "type": "object",
            "x-uneditable": [
                "from",
                "to",
                "weight",
                "annotations"
            ],
            "x-unsettable": [
                "from",
                "to",
                "weight",
                "annotations"
            ]
        },
        "topology_edge_annotations": {
            "properties": {
                "appearances": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_edge_appearance_annotation"
                    },
                    "default": [],
                    "description": "The appearance object that specifies the walk and steps that contain the edge. Object contents are defined in the \"topology_edge_appearance_annotation\" section below."
                },
                "protocols": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_edge_protocol_annotation"
                    },
                    "default": [],
                    "description": "The protocol object that specifies the protocol stack and the weight contributed by the protocol. Object contents are defined in the \"topology_edge_protocol_annotation\" section below."
                }
            },
            "type": "object",
            "x-uneditable": [
                "protocols",
                "appearances"
            ],
            "x-unsettable": [
                "protocols",
                "appearances"
            ]
        },
        "topology_edge_appearance_annotation": {
            "properties": {
                "step": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Identifies the step and associated walk from the \"step\" array that returned the edge."
                },
                "walk": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Identifies the walk from the \"walk\" array that returned the edge."
                }
            },
            "required": [
                "walk",
                "step"
            ],
            "type": "object",
            "x-uneditable": [
                "walk",
                "step"
            ],
            "x-unsettable": [
                "walk",
                "step"
            ]
        },
        "topology_edge_protocol_annotation": {
            "properties": {
                "protocol": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more protocol stacks associated with the edge, such as [IPv4, TCP, SSL, HTTP]."
                },
                "weight": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The weight the protocol contributed to the total weight of the edge."
                }
            },
            "required": [
                "weight",
                "protocol"
            ],
            "type": "object",
            "x-uneditable": [
                "weight",
                "protocol"
            ],
            "x-unsettable": [
                "weight",
                "protocol"
            ]
        },
        "topology_relationship": {
            "properties": {
                "protocol": {
                    "type": "string",
                    "format": "string",
                    "default": "any",
                    "description": "The protocol over which the origin device is communicating, such as \"HTTP\". If no value is set, the object includes any protocol."
                },
                "role": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "client",
                        "server",
                        "any"
                    ],
                    "default": "any",
                    "description": "The role of the peer device in relation to the origin device."
                }
            },
            "type": "object",
            "x-uneditable": [
                "role",
                "protocol"
            ]
        },
        "topology_request": {
            "properties": {
                "edge_annotations": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "type": "string"
                    },
                    "enum": [
                        "protocols",
                        "appearances"
                    ],
                    "default": [],
                    "description": "The list of one or more edge annotations to include in the topology query."
                },
                "from": {
                    "type": [
                        "integer",
                        "string"
                    ],
                    "format": "Timestamp",
                    "description": "The beginning timestamp of the time range the query will search, expressed in milliseconds since the epoch."
                },
                "until": {
                    "type": [
                        "integer",
                        "string"
                    ],
                    "format": "Timestamp",
                    "default": 0,
                    "description": "The ending timestamp of the time range the query will search, expressed in milliseconds since the epoch. If no value is set, the query end defaults to \"now\"."
                },
                "walks": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_walk"
                    },
                    "description": "The list of one or more walk objects to include in the topology query. A walk is the path of traffic composed of one or more steps. Each walk begins with one or more origin devices and expands to connections to peer devices that are based on protocol activity. Each expansion from the origin is a step. Object contents are defined in the \"topology_walk\" section below."
                },
                "weighting": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "bytes",
                        "connections",
                        "turns"
                    ],
                    "default": "bytes",
                    "description": "The metric value that determines how activity is weighted between devices."
                }
            },
            "required": [
                "from",
                "walks"
            ],
            "type": "object",
            "x-uneditable": [
                "from",
                "until",
                "weighting",
                "edge_annotations",
                "walks"
            ]
        },
        "topology_response": {
            "properties": {
                "edges": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_edge"
                    },
                    "description": "The list of one or more edge objects that compose the topology graph. Each object specifies the edge annotations, devices, and weight included in the edge. The contents of the object are defined in the \"topology_edge\" section below."
                },
                "from": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The beginning timestamp of the absolute time range of the topology graph. The timestamp is expressed in milliseconds since the epoch."
                },
                "until": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The ending timestamp of the absolute time range for the topology graph. The timestamp is expressed in milliseconds since the epoch."
                },
                "warnings": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_warning"
                    },
                    "description": "The list of one or more warning objects returned by the request. The graph might be incomplete if a warning occurs. Each object specifies the warning message, properties, and type. The contents of the object are defined in the \"topology_warning\" section below."
                }
            },
            "required": [
                "from",
                "until",
                "warnings",
                "edges"
            ],
            "type": "object",
            "x-uneditable": [
                "from",
                "until",
                "warnings",
                "edges"
            ],
            "x-unsettable": [
                "from",
                "until",
                "warnings",
                "edges"
            ]
        },
        "topology_source": {
            "properties": {
                "object_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the source object. Set to 0 if the value of the \"object_type\" parameter is \"all_devices\"."
                },
                "object_type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "all_devices",
                        "device_group",
                        "device"
                    ],
                    "description": "The type of source object."
                }
            },
            "required": [
                "object_type",
                "object_id"
            ],
            "type": "object",
            "x-uneditable": [
                "object_type",
                "object_id",
                "filter"
            ],
            "x-unsettable": [
                "filter"
            ]
        },
        "topology_step": {
            "properties": {
                "peer_in": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_source"
                    },
                    "default": [],
                    "description": "The list of one or more peer devices to include in the topology graph. Only relationships to peers of the specified source object are included. Object contents are defined in the \"topology_source\" section below."
                },
                "peer_not_in": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_source"
                    },
                    "default": [],
                    "description": "The list of one or more peer devices to exclude from the topology graph. Relationships to peer devices of the specified source object are excluded. Object contents are defined in the \"topology_source\" section below."
                },
                "relationships": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_relationship"
                    },
                    "default": [
                        {
                            "protocol": "any",
                            "role": "any"
                        }
                    ],
                    "description": "The list of one or more filters that define the relationship between two devices. The filters specify which roles and protocols to search for when locating peer devices in the step. Relationships are represented as an edge in the activity map. If no value is set, the operation includes all peers. Object contents are defined in the \"topology_relationship\" section below."
                }
            },
            "type": "object",
            "x-uneditable": [
                "relationships",
                "peer_in",
                "peer_not_in"
            ]
        },
        "topology_walk": {
            "properties": {
                "origins": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_source"
                    },
                    "description": "The list of one or more origin devices of the first step within the walk. Object contents are defined in the \"topology_source\" section below."
                },
                "steps": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/topology_step"
                    },
                    "description": "The list of one or more steps within the walk. Each step is defined by the protocol activity between devices of the previous step to a new set of peer devices. Object contents are defined in the \"topology_step\" section below."
                }
            },
            "required": [
                "origins",
                "steps"
            ],
            "type": "object",
            "x-uneditable": [
                "origins",
                "steps"
            ]
        },
        "topology_warning": {
            "properties": {
                "message": {
                    "type": "string",
                    "format": "string",
                    "description": "A user-friendly description of the warning."
                },
                "properties": {
                    "$ref": "#/definitions/topology_warning_properties",
                    "description": "Additional information about the warning. Available information will vary by warning type and ExtraHop system. Object contents are defined in the \"topology_warning properties\" section below."
                },
                "type": {
                    "type": "string",
                    "format": "string",
                    "description": "The warning type. Supported warning type values are \"node_metrics_failed\", \"node_offline\", \"node_check_license\", or \"node_version_unsupported\"."
                }
            },
            "required": [
                "type",
                "message",
                "properties"
            ],
            "type": "object",
            "x-uneditable": [
                "type",
                "message",
                "properties"
            ],
            "x-unsettable": [
                "type",
                "message",
                "properties"
            ]
        },
        "topology_warning_properties": {
            "properties": {
                "node_hostname": {
                    "type": "string",
                    "format": "string",
                    "description": "If available, the hostname of the sensor that caused the warning."
                },
                "node_id": {
                    "type": "integer",
                    "format": "int64",
                    "description": "If available, the ID of the sensor that caused the warning."
                }
            },
            "type": "object",
            "x-uneditable": [
                "node_id",
                "node_hostname"
            ],
            "x-unsettable": [
                "node_id",
                "node_hostname"
            ]
        },
        "triggers_external_data": {
            "properties": {
                "body": {
                    "type": "object",
                    "format": "json",
                    "description": "The data to send to triggers through the EXTERNAL_DATA event. This data can be accessed in the trigger with the 'ExternalData.body' property."
                },
                "type": {
                    "type": "string",
                    "format": "string",
                    "description": "A string identifier that describes the data contained in the body parameter. For example, you could specify 'phantom-data' for data sent from the Phantom SOAR platform."
                }
            },
            "type": "object",
            "x-uneditable": [
                "type",
                "body"
            ]
        },
        "update_config_manager": {
            "properties": {
                "manager": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The unique identifier for the managing sensor or console."
                }
            },
            "type": "object"
        },
        "update_services_input_error": {
            "properties": {
                "error_message": {
                    "format": "service_error_value",
                    "$ref": "#/definitions/service_error_value",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "update_services_internal_error": {
            "properties": {
                "error_message": {
                    "format": "service_error_value",
                    "$ref": "#/definitions/service_error_value",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "update_services_unlicensed_error": {
            "properties": {
                "error_message": {
                    "format": "service_error_value",
                    "$ref": "#/definitions/service_error_value",
                    "description": "The error message."
                }
            },
            "required": [
                "error_message"
            ],
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "user_create_bad_request": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string"
                }
            },
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "user_create_response": {
            "properties": {
                "apikey": {
                    "type": "string",
                    "format": "string",
                    "description": "The API key generated for the newly created user."
                },
                "username": {
                    "type": "string",
                    "format": "string",
                    "description": "The login name of the newly created user."
                }
            },
            "required": [
                "username"
            ],
            "type": "object",
            "x-uneditable": [
                "username",
                "apikey"
            ],
            "x-unsettable": [
                "username",
                "apikey"
            ]
        },
        "user_create_with_pw": {
            "properties": {
                "create_apikey": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Generate and return a new API key for the created user."
                },
                "eh_account_team": {
                    "type": "boolean",
                    "format": "boolean",
                    "default": false,
                    "description": "Indicates an ExtraHop Account Team user that accesses the ExtraHop system through ExtraHop Cloud Services."
                },
                "enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether the user can login to the ExtraHop system."
                },
                "granted_roles": {
                    "type": "object",
                    "format": "json",
                    "default": {
                        "write": "limited"
                    },
                    "description": "The privileges for the user. Supported permission levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#privilege-levels)."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The friendly name for the user."
                },
                "password": {
                    "type": "string",
                    "format": "string",
                    "description": "The password for the user. Passwords must meet the requirements configured in the Administration settings."
                },
                "type": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "local",
                        "remote"
                    ],
                    "default": "local",
                    "description": "The authentication method used by this user to log in."
                },
                "username": {
                    "type": "string",
                    "format": "string",
                    "description": "The login name for the user."
                }
            },
            "required": [
                "name",
                "username",
                "password"
            ],
            "type": "object",
            "x-uneditable": [
                "enabled",
                "name",
                "username",
                "password",
                "granted_roles",
                "create_apikey",
                "type",
                "eh_account_team"
            ]
        },
        "user_language_code": {
            "properties": {
                "language_code": {
                    "type": "string",
                    "format": "string",
                    "description": "The user's preferred language."
                }
            },
            "required": [
                "language_code"
            ],
            "type": "object",
            "x-uneditable": [
                "language_code"
            ],
            "x-unsettable": [
                "language_code"
            ]
        },
        "user_preferences": {
            "properties": {
                "theme": {
                    "type": "string",
                    "format": "string",
                    "enum": [
                        "light",
                        "dark",
                        "space",
                        "contrast"
                    ],
                    "description": "The user's preferred theme."
                },
                "view_markers": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether to show detection markers in charts."
                }
            },
            "type": "object",
            "x-uneditable": [
                "theme",
                "view_markers"
            ],
            "x-unsettable": [
                "theme",
                "view_markers"
            ]
        },
        "user_update_with_pw": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "format": "boolean",
                    "description": "Indicates whether the user can login to the ExtraHop system."
                },
                "granted_roles": {
                    "type": "object",
                    "format": "json",
                    "description": "The privileges for the user. Supported permission levels are described in the [REST API Guide](https://docs.extrahop.com/9.8/rest-api-guide/#privilege-levels)."
                },
                "name": {
                    "type": "string",
                    "format": "string",
                    "description": "The friendly name for the user."
                },
                "password": {
                    "type": "string",
                    "format": "string",
                    "description": "The password for the user. Passwords must meet the requirements configured in the Administration settings."
                }
            },
            "type": "object"
        },
        "usergroup_bad_request": {
            "properties": {
                "error_message": {
                    "type": "string",
                    "format": "string",
                    "description": "The error message."
                }
            },
            "type": "object",
            "x-uneditable": [
                "error_message"
            ],
            "x-unsettable": [
                "error_message"
            ]
        },
        "walk": {
            "properties": {
                "origins": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/source_object"
                    },
                    "description": "The list of one or more origin devices of the first step within the walk. Object contents are defined in the \"source_object\" section below."
                },
                "steps": {
                    "type": "array",
                    "format": "array",
                    "items": {
                        "$ref": "#/definitions/step"
                    },
                    "description": "The list of one or more steps within the walk. Each step is defined by the protocol activity between devices of the previous step to a new set of peer devices. Object contents are defined in the \"step\" section below."
                }
            },
            "required": [
                "origins",
                "steps"
            ],
            "type": "object"
        },
        "writelevel_map": {
            "properties": {
                "attribute_name": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute that grants write privileges on the ExtraHop system."
                },
                "full_readonly": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants full read-only privileges on the ExtraHop system."
                },
                "full_write": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants full write privileges on the ExtraHop system."
                },
                "limited_write": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants limited write privileges on the ExtraHop system."
                },
                "none": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that prevents all access to the ExtraHop system."
                },
                "personal_write": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants personal write privileges on the ExtraHop system."
                },
                "restricted_readonly": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants restricted read-only privileges on the ExtraHop system."
                },
                "unlimited": {
                    "type": "string",
                    "format": "string",
                    "description": "Specifies the SAML attribute value that grants unlimited write privileges on the ExtraHop system."
                }
            },
            "type": "object",
            "x-unsettable": [
                "attribute_name",
                "none",
                "unlimited",
                "full_write",
                "limited_write",
                "personal_write",
                "full_readonly",
                "restricted_readonly"
            ]
        }
    },
    "securityDefinitions": {
        "ExtraHopKey": {
            "type": "apiKey",
            "description": "API keys are available from the ExtraHop Admin UI.",
            "name": "Authorization",
            "in": "header"
        }
    },
    "security": [
        {
            "ExtraHopKey": []
        }
    ]
}